From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: John Doe <john.doe@somewhere.on.planet>
Date: Thu, 7 Aug 2025 15:18:31 +0800
Subject: Patching kernel rk35xx files drivers/bluetooth/Kconfig
 drivers/bluetooth/Makefile drivers/bluetooth/skwbt/Kconfig
 drivers/bluetooth/skwbt/Kconfig.txt drivers/bluetooth/skwbt/Makefile
 drivers/bluetooth/skwbt/makefile.txt drivers/bluetooth/skwbt/skw_btdriver.c
 drivers/bluetooth/skwbt/skw_btsnoop.c drivers/bluetooth/skwbt/skw_btsnoop.h
 drivers/bluetooth/skwbt/skw_common.c drivers/bluetooth/skwbt/skw_common.h
 drivers/bluetooth/skwbt/skw_log.c drivers/bluetooth/skwbt/skw_log.h

Signed-off-by: John Doe <john.doe@somewhere.on.planet>
---
 drivers/bluetooth/Kconfig              |    1 +
 drivers/bluetooth/Makefile             |    1 +
 drivers/bluetooth/skwbt/Kconfig        |    9 +
 drivers/bluetooth/skwbt/Kconfig.txt    |    8 +
 drivers/bluetooth/skwbt/Makefile       |   24 +
 drivers/bluetooth/skwbt/makefile.txt   |   15 +
 drivers/bluetooth/skwbt/skw_btdriver.c | 1055 ++++++++++
 drivers/bluetooth/skwbt/skw_btsnoop.c  |  178 ++
 drivers/bluetooth/skwbt/skw_btsnoop.h  |   36 +
 drivers/bluetooth/skwbt/skw_common.c   |  385 ++++
 drivers/bluetooth/skwbt/skw_common.h   |  144 ++
 drivers/bluetooth/skwbt/skw_log.c      |  122 ++
 drivers/bluetooth/skwbt/skw_log.h      |   18 +
 13 files changed, 1996 insertions(+)

diff --git a/drivers/bluetooth/Kconfig b/drivers/bluetooth/Kconfig
index ec9f6401e835..7f375ef1e456 100644
--- a/drivers/bluetooth/Kconfig
+++ b/drivers/bluetooth/Kconfig
@@ -451,6 +451,7 @@ config BT_HCIBTUSB_RTLBTUSB
 	  device with USB interface.
 
 	  Say Y here to compile support for Bluetooth USB devices into the
 	  kernel or say M to compile it as module (rtk_btusb).
 
+source "drivers/bluetooth/skwbt/Kconfig"
 endmenu
diff --git a/drivers/bluetooth/Makefile b/drivers/bluetooth/Makefile
index 1552090be54c..c9cd9fcd6819 100644
--- a/drivers/bluetooth/Makefile
+++ b/drivers/bluetooth/Makefile
@@ -1,10 +1,11 @@
 # SPDX-License-Identifier: GPL-2.0
 #
 # Makefile for the Linux Bluetooth HCI device drivers.
 #
 
+obj-y           += skwbt/
 obj-$(CONFIG_BT_HCIVHCI)	+= hci_vhci.o
 obj-$(CONFIG_BT_HCIUART)	+= hci_uart.o
 obj-$(CONFIG_BT_HCIBCM203X)	+= bcm203x.o
 obj-$(CONFIG_BT_HCIBPA10X)	+= bpa10x.o
 obj-$(CONFIG_BT_HCIBFUSB)	+= bfusb.o
diff --git a/drivers/bluetooth/skwbt/Kconfig b/drivers/bluetooth/skwbt/Kconfig
new file mode 100755
index 000000000000..0793ae4b5aee
--- /dev/null
+++ b/drivers/bluetooth/skwbt/Kconfig
@@ -0,0 +1,9 @@
+config SKW_BT
+        tristate "Seekwave BT driver"
+        depends on (SEEKWAVE_BSP_DRIVERS || SEEKWAVE_BSP_DRIVERS_V20) && MMC
+        help
+          The driver for seekwave Bluetooth chipsets .
+
+          Say Y here to compile support for Seekwave BT driver
+          into the kernel or say M to compile it as module.
+
diff --git a/drivers/bluetooth/skwbt/Kconfig.txt b/drivers/bluetooth/skwbt/Kconfig.txt
new file mode 100755
index 000000000000..bfd95f5dbf56
--- /dev/null
+++ b/drivers/bluetooth/skwbt/Kconfig.txt
@@ -0,0 +1,8 @@
+config SKW_BT
+        tristate "Seekwave BT driver"
+        depends on (SEEKWAVE_BSP_DRIVERS || SEEKWAVE_BSP_DRIVERS_V20) && MMC
+        help
+          The driver for seekwave Bluetooth chipsets with SDIO/USB interface.
+
+          Say Y here to compile support for Seekwave BT-over-SDIO/USB driver
+          into the kernel or say M to compile it as module.
\ No newline at end of file
diff --git a/drivers/bluetooth/skwbt/Makefile b/drivers/bluetooth/skwbt/Makefile
new file mode 100755
index 000000000000..204e794770aa
--- /dev/null
+++ b/drivers/bluetooth/skwbt/Makefile
@@ -0,0 +1,24 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for the Linux Bluetooth HCI device drivers.
+#
+#ccflags-y += -Iseekwave_ea6621q/include/linux/platform_data/
+ccflags-y += -I$(srctree)/include/linux/platform_data/
+
+ifneq ($(skw_extra_flags),)
+ccflags-y += $(skw_extra_flags)
+endif
+
+ifeq ($(CONFIG_SEEKWAVE_PLD_RELEASE),m)
+    ccflags-y += -DCONFIG_SEEKWAVE_PLD_RELEASE
+endif
+
+ifeq ($(CONFIG_SEEKWAVE_BSP_DRIVERS_V20),y)
+    ccflags-y += -DINCLUDE_NEW_VERSION=1
+endif
+
+obj-$(CONFIG_SKW_BT)        += skwbt.o
+skwbt-y                     := skw_btdriver.o
+skwbt-y                     += skw_btsnoop.o
+skwbt-y                     += skw_log.o
+skwbt-y                     += skw_common.o
\ No newline at end of file
diff --git a/drivers/bluetooth/skwbt/makefile.txt b/drivers/bluetooth/skwbt/makefile.txt
new file mode 100755
index 000000000000..d03253d1b79a
--- /dev/null
+++ b/drivers/bluetooth/skwbt/makefile.txt
@@ -0,0 +1,15 @@
+ccflags-y += -I$(srctree)/include/linux/platform_data/
+
+ifneq ($(skw_extra_flags),)
+ccflags-y += $(skw_extra_flags)
+endif
+
+ifeq ($(CONFIG_SEEKWAVE_BSP_DRIVERS_V20),y)
+    ccflags-y += -DINCLUDE_NEW_VERSION=1
+endif
+
+obj-$(CONFIG_SKW_BT)       += skwbt.o
+skwbt-y                    := skw_btdriver.o
+skwbt-y                    += skw_btsnoop.o
+skwbt-y                    += skw_log.o
+skwbt-y                    += skw_common.o
\ No newline at end of file
diff --git a/drivers/bluetooth/skwbt/skw_btdriver.c b/drivers/bluetooth/skwbt/skw_btdriver.c
new file mode 100755
index 000000000000..51069717cc05
--- /dev/null
+++ b/drivers/bluetooth/skwbt/skw_btdriver.c
@@ -0,0 +1,1055 @@
+/*
+ *
+ *  Seekwave Bluetooth driver
+ *
+ *  Copyright (C) 2023  Seekwave Tech Ltd.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/skbuff.h>
+#include <linux/platform_device.h>
+#include <net/bluetooth/bluetooth.h>
+#include <net/bluetooth/hci_core.h>
+//#include <linux/platform_data/skw_platform_data.h>
+#include <skw_platform_data.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <linux/workqueue.h>
+#include <linux/firmware.h>
+#include <linux/notifier.h>
+#include <linux/delay.h>
+#include <linux/version.h>
+
+#include "skw_btsnoop.h"
+#include "skw_log.h"
+#include "skw_common.h"
+
+#define VERSION "0.1"
+
+
+
+
+enum
+{
+    BT_STATE_DEFAULT = 0x00,
+    BT_STATE_CLOSE,
+    BT_STATE_REMOVE
+};
+
+int skwbt_log_disable = 0;
+int is_init_mode = 0;
+uint16_t chip_version = 0;
+wait_queue_head_t nv_wait_queue;
+wait_queue_head_t recovery_wait_queue;
+wait_queue_head_t close_wait_queue;
+Wakeup_ADV_Info_St wakeup_adv_info = {0};
+
+
+atomic_t evt_recv;
+atomic_t cmd_reject;
+atomic_t atomic_close_sync;//make sure running close func before remove func
+
+static int btseekwave_send_frame(struct hci_dev *hdev, struct sk_buff *skb);
+int btseekwave_plt_event_notifier(struct notifier_block *nb, unsigned long action, void *param);
+
+extern int skw_start_bt_service(void);
+extern int skw_stop_bt_service(void);
+struct btseekwave_data
+{
+    struct hci_dev   *hdev;
+    struct sv6160_platform_data *pdata;
+
+    struct work_struct work;
+
+    struct notifier_block plt_notifier;
+    uint8_t plt_notifier_set;
+    uint8_t bt_is_open;
+
+    struct sk_buff_head cmd_txq;
+    struct sk_buff_head data_txq;
+    struct sk_buff_head audio_txq;
+};
+
+struct btseekwave_data *skw_data = NULL;
+
+
+void btseekwave_hci_hardware_error(struct hci_dev *hdev)
+{
+    struct sk_buff *skb = NULL;
+    int len = 3;
+    uint8_t hw_err_pkt[4] = {HCI_EVENT_PKT, HCI_EVT_HARDWARE_ERROR, 0x01, 0x00};
+
+    skb = alloc_skb(len, GFP_ATOMIC);
+    if (!skb)
+    {
+        SKWBT_ERROR("%s: failed to allocate mem", __func__);
+        return;
+    }
+    memcpy(skb_put(skb, len), hw_err_pkt + 1, len);
+    bt_cb(skb)->pkt_type = HCI_EVENT_PKT;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 11, 0)
+    hci_recv_frame(hdev, skb);
+#else
+    hci_recv_frame(skb);
+#endif
+
+    SKWBT_INFO("%s enter", __func__);
+}
+
+
+static int btseekwave_tx_packet(int portno, struct btseekwave_data *data, struct sk_buff *skb)
+{
+    int err = 0;
+    u32 *d;
+
+    d = (u32 *)skb->data;
+
+    //SKWBT_INFO("%s enter size %d: 0x%x 0x%x\n", __func__, skb->len, d[0], d[1]);
+
+    if(data->pdata && data->pdata->hw_sdma_tx)
+    {
+        err = data->pdata->hw_sdma_tx(portno, skb->data, skb->len);
+    }
+    if (err < 0)
+    {
+        return err;
+    }
+
+    data->hdev->stat.byte_tx += skb->len;
+
+    //SKWBT_INFO("%s, pkt:%d, users:%d \n", __func__, bt_cb((skb))->pkt_type, skb->users.refs.counter);
+    kfree_skb(skb);
+
+    return 0;
+}
+
+static void btseekwave_work(struct work_struct *work)
+{
+    struct btseekwave_data *data = container_of(work, struct btseekwave_data, work);
+    struct sk_buff *skb;
+    int err = 0;
+
+    //SKWBT_INFO("%s %s", __func__, data->hdev->name);
+
+    if(atomic_read(&cmd_reject))
+    {
+        return ;
+    }
+
+    while ((skb = skb_dequeue(&data->cmd_txq)))
+    {
+        err = btseekwave_tx_packet(data->pdata->cmd_port, data, skb);
+        if (err < 0)
+        {
+            data->hdev->stat.err_tx++;
+            skb_queue_head(&data->cmd_txq, skb);
+            SKWBT_ERROR("btseekwave_tx_packet command failed len: %d\n", err);
+            break;
+        }
+    }
+
+    while (err >= 0 && (skb = skb_dequeue(&data->data_txq)))
+    {
+        err = btseekwave_tx_packet(data->pdata->data_port, data, skb);
+        if (err < 0)
+        {
+            data->hdev->stat.err_tx++;
+            skb_queue_head(&data->data_txq, skb);
+            SKWBT_ERROR("btseekwave_tx_packet data failed len: %d\n", err);
+            break;
+        }
+    }
+    while (err >= 0 && (skb = skb_dequeue(&data->audio_txq)))
+    {
+        err = btseekwave_tx_packet(data->pdata->audio_port, data, skb);
+        if (err < 0)
+        {
+            data->hdev->stat.err_tx++;
+            skb_queue_head(&data->audio_txq, skb);
+            SKWBT_ERROR("btseekwave_tx_packet audio failed len: %d\n", err);
+            break;
+        }
+    }
+//  SKWBT_INFO("btseekwave_work done\n");
+}
+
+
+static int btseekwave_rx_packet(struct btseekwave_data *data, u8 pkt_type, void *buf, int c_len)
+{
+    struct sk_buff *skb;
+    //SKWBT_INFO("rx hci pkt len = %d, pkt_type:%d, data = 0x%x\n", skb->len, pkt_type, d[0]);
+
+    skb = bt_skb_alloc(c_len, GFP_ATOMIC);
+    if (!skb)
+    {
+        SKWBT_ERROR("skwbt alloc skb failed, len: %d\n", c_len);
+        return 0;
+    }
+    bt_cb((skb))->expect = 0;
+    skb->dev = (void *) data->hdev;
+    bt_cb(skb)->pkt_type = pkt_type;
+    memcpy(skb_put(skb, c_len), buf, c_len);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 11, 0)
+    hci_recv_frame(data->hdev, skb);
+#else
+    hci_recv_frame(skb);
+#endif
+
+    return 0;
+}
+
+int btseekwave_rx_complete(int portno, struct scatterlist *priv, int size, void *buf)
+{
+    int ret = 0;
+    struct btseekwave_data *data = (struct btseekwave_data *)priv;
+    u8 pkt_type = 0;
+
+    //SKWBT_INFO("btseekwave_rx_complete size=%d\n", size);
+    if(size == 0)
+    {
+        return 0;
+    }
+    else if(size < 0)//CP assert/exception
+    {
+        SKWBT_ERROR("cp exception\n");
+        return 0;
+    }
+    pkt_type = *((u8 *)buf);
+    if(HCI_EVENT_SKWLOG == pkt_type)
+    {
+#if BT_CP_LOG_EN
+        skwlog_write(buf, size);
+#endif
+        return 0;
+    }
+
+
+    if((HCI_EVENT_PKT == pkt_type) || (HCI_ACLDATA_PKT == pkt_type) || (HCI_SCODATA_PKT == pkt_type))
+    {
+#if BT_HCI_LOG_EN
+        skw_btsnoop_capture(buf, 1);
+#endif
+
+        if(is_init_mode)//command complete event
+        {
+            hci_cmd_cmpl_evt_st *hci_evt = (hci_cmd_cmpl_evt_st *)buf;
+            if((HCI_EVENT_PKT == pkt_type) && (HCI_COMMAND_COMPLETE_EVENT == hci_evt->evt_op) && (HCI_CMD_READ_LOCAL_VERSION_INFO == hci_evt->cmd_op))
+            {
+                struct hci_rp_read_local_version *ver;
+                ver = (struct hci_rp_read_local_version *)(buf + 6);
+                chip_version = le16_to_cpu(ver->hci_rev);
+                SKWBT_INFO("%s, chip version:0x%X", __func__, chip_version);
+            }
+
+            atomic_inc(&evt_recv);
+            wake_up(&nv_wait_queue);
+            SKWBT_INFO("init cmd response: 0x%x \n", *((u32 *)(buf + 3)));
+            return 0;
+        }
+
+        ret = btseekwave_rx_packet(data, pkt_type, buf + 1, size - 1);
+    }
+    else
+    {
+        SKWBT_ERROR("err hci packet: %x, len:%d\n", pkt_type, size);
+    }
+
+    return ret;
+}
+
+struct sk_buff *btseekwave_prepare_cmd(struct hci_dev *hdev, u16 opcode, u32 plen,
+                                       const void *param)
+{
+    int len = HCI_COMMAND_HDR_SIZE + plen;
+    struct hci_command_hdr *hdr;
+    struct sk_buff *skb;
+
+    skb = bt_skb_alloc(len, GFP_ATOMIC);
+    if (!skb)
+    {
+        return NULL;
+    }
+
+    hdr = (struct hci_command_hdr *) skb_put(skb, HCI_COMMAND_HDR_SIZE);
+    hdr->opcode = cpu_to_le16(opcode);
+    hdr->plen   = plen;
+
+    if (plen)
+    {
+        memcpy(skb_put(skb, plen), param, plen);
+    }
+
+
+    bt_cb(skb)->pkt_type = HCI_COMMAND_PKT;
+
+    return skb;
+}
+
+void btseekwave_write_bd_addr(struct hci_dev *hdev)
+{
+    u8 cmd_pld[32] = {0x12, 0x34, 0xAB, 0xED, 0x6A, 0x56};//random addr
+    struct sk_buff *skb;
+    if(!skw_get_bd_addr(cmd_pld))//bd addr is invalid
+    {
+        return ;
+    }
+    skb = btseekwave_prepare_cmd(hdev, HCI_CMD_WRITE_BD_ADDR, BD_ADDR_LEN, cmd_pld);
+    if(skb)
+    {
+        btseekwave_send_frame(hdev, skb);
+        atomic_set(&evt_recv, 0);
+        wait_event_interruptible_timeout(nv_wait_queue,
+                                         (atomic_read(&evt_recv)),
+                                         msecs_to_jiffies(2000));
+
+    }
+    else
+    {
+        SKWBT_ERROR("%s no memory for nv command", __func__);
+    }
+}
+
+
+/*
+0: success
+other:fail
+*/
+int btseekwave_send_hci_command(struct hci_dev *hdev, u16 opcode, int len, char *cmd_pld)
+{
+    struct sk_buff *skb;
+    int ret = 0;
+
+    skb = btseekwave_prepare_cmd(hdev, opcode, len, cmd_pld);
+    if(!skb)
+    {
+        SKWBT_ERROR("%s no memory for nv command", __func__);
+        return -1;
+    }
+    btseekwave_send_frame(hdev, skb);
+
+    //waiting controller response
+    atomic_set(&evt_recv, 0);
+    ret = wait_event_interruptible_timeout(nv_wait_queue,
+                                           (atomic_read(&evt_recv)),
+                                           msecs_to_jiffies(1000));
+    if(ret > 0)
+    {
+        return 0;
+    }
+    SKWBT_INFO("%s cp response timeout", __func__);
+    return -1;
+}
+
+void btseekwave_write_ble_wakeup_adv_info(struct hci_dev *hdev)
+{
+    uint8_t adv_data_len = wakeup_adv_info.data_len;
+    if(adv_data_len > 0)
+    {
+        uint8_t p_buf[256] = {0x00};
+        uint8_t *ptr = p_buf;
+        uint8_t i, adv_len;
+        uint8_t pld_len = adv_data_len + 4;//add the length of gpio & level & grp nums & total len
+        Wakeup_ADV_Grp_St *adv_grp;
+
+        UINT8_TO_STREAM(ptr, wakeup_adv_info.gpio_no);
+        UINT8_TO_STREAM(ptr, wakeup_adv_info.level);
+        UINT8_TO_STREAM(ptr, wakeup_adv_info.grp_nums);
+        UINT8_TO_STREAM(ptr, adv_data_len);
+        for(i = 0; i < wakeup_adv_info.grp_nums; i++)
+        {
+            adv_grp = &wakeup_adv_info.adv_group[i];
+            UINT8_TO_STREAM(ptr, adv_grp->grp_len);
+            UINT8_TO_STREAM(ptr, adv_grp->addr_offset);
+            adv_len = (adv_grp->grp_len - 2) >> 1;
+
+            SKWBT_INFO("grp len:%d, adv_len:%d", adv_grp->grp_len, adv_len);
+
+            memcpy(ptr, adv_grp->data, adv_len);
+            ptr += adv_len;
+            memcpy(ptr, adv_grp->mask, adv_len);
+            ptr += adv_len;
+        }
+        btseekwave_send_hci_command(hdev, HCI_CMD_WRITE_WAKEUP_ADV_DATA, pld_len, p_buf);
+    }
+}
+
+void btseekwave_write_ble_wakeup_adv_enable(le_wakeup_op_enum enable_op)
+{
+    if((wakeup_adv_info.data_len > 0) && skw_data && (skw_data->bt_is_open))
+    {
+        char buffer[2] = {0x00};
+        struct sk_buff *skb;
+        struct hci_dev *hdev = skw_data->hdev;
+
+        buffer[0] = enable_op;
+
+        skb = btseekwave_prepare_cmd(hdev, HCI_CMD_WRITE_WAKEUP_ADV_ENABLE_PLT, 1, buffer);
+        if(!skb)
+        {
+            SKWBT_ERROR("%s no memory for nv command", __func__);
+            return ;
+        }
+        SKWBT_INFO("%s", __func__);
+        btseekwave_send_frame(hdev, skb);
+
+        msleep(5);
+    }
+}
+EXPORT_SYMBOL_GPL(btseekwave_write_ble_wakeup_adv_enable);
+
+static void btseekwave_port_close(struct btseekwave_data *data)
+{
+    if(data && data->pdata)
+    {
+        data->bt_is_open = 0;
+
+        if(data->pdata->modem_unregister_notify && data->plt_notifier_set)
+        {
+            data->plt_notifier_set = 0;
+            data->pdata->modem_unregister_notify(&data->plt_notifier);
+        }
+#if INCLUDE_NEW_VERSION
+        if(data->pdata->service_stop)
+        {
+            data->pdata->service_stop();
+        }
+        else
+        {
+            SKWBT_ERROR("func %s service_stop not exist", __func__);
+        }
+#else
+        skw_stop_bt_service();
+#endif
+        if(data->pdata->close_port)
+        {
+            data->pdata->close_port(data->pdata->cmd_port);
+            if(data->pdata->data_port != 0)
+            {
+                data->pdata->close_port(data->pdata->data_port);
+            }
+            if(data->pdata->audio_port != 0)
+            {
+                data->pdata->close_port(data->pdata->audio_port);
+            }
+        }
+    }
+
+}
+
+
+int btseekwave_download_nv(struct hci_dev *hdev)
+{
+    int page_offset = 0, ret = 0, len = 0;
+    u8 *cmd_pld = NULL;
+    const struct firmware *fw;
+    int err, count = 0;
+    uint8_t log_disable = 1;
+    SKWBT_INFO("%s", __func__);
+
+    is_init_mode = 1;
+    chip_version = SKW_CHIPID_6160;
+
+    ret = btseekwave_send_hci_command(hdev, HCI_CMD_READ_LOCAL_VERSION_INFO, 0, NULL);
+    if(ret < 0)
+    {
+        BT_ERR("%s, read local version err", __func__);
+		if(skw_data)
+		{
+			skw_data->pdata->modem_assert();
+		}
+        return -1;
+    }
+
+    if(SKW_CHIPID_6316 == chip_version)
+    {
+        err = request_firmware(&fw, NV_FILE_NAME_6316, &hdev->dev);
+    }
+    else if(SKW_CHIPID_6160_LITE == chip_version)
+    {
+        err = request_firmware(&fw, NV_FILE_NAME_6160_LITE, &hdev->dev);
+    }
+    else
+    {
+        err = request_firmware(&fw, NV_FILE_NAME, &hdev->dev);
+    }
+    if (err < 0)
+    {
+        SKWBT_ERROR("%s file load fail", NV_FILE_NAME);
+        return err;
+    }
+    cmd_pld = (u8 *)kzalloc(512, GFP_KERNEL);
+    if(cmd_pld == NULL)
+    {
+        SKWBT_ERROR("%s malloc fail", __func__);
+        release_firmware(fw);
+        return -1;
+    }
+#ifdef CONFIG_SEEKWAVE_PLD_RELEASE
+    skwbt_log_disable = 1;
+#else
+    skwbt_log_disable = 0;
+#endif
+
+    if((SKW_CHIPID_6316 == chip_version) || (SKW_CHIPID_6160_LITE == chip_version))
+    {
+        int total_len = 0;
+        int nv_pkt_len = 0;
+        uint8_t nv_tag = 0;
+        count = 4;//skip header
+        while(count < fw->size)
+        {
+            nv_tag = fw->data[count];
+            nv_pkt_len = fw->data[count + 2] + 3;
+            if((nv_pkt_len + total_len) >= NV_FILE_RD_BLOCK_SIZE)
+            {
+                cmd_pld[0] = (char)page_offset;
+                cmd_pld[1] = (char)total_len;//para len
+                ret = btseekwave_send_hci_command(hdev, HCI_CMD_SKW_BT_NVDS, total_len + 2, cmd_pld);
+                if(ret < 0)
+                {
+                    return -1;
+                }
+                page_offset ++;
+                total_len = 0;
+                continue;
+            }
+            memcpy(cmd_pld + 2 + total_len, fw->data + count, nv_pkt_len);
+            if(nv_tag == NV_TAG_DSP_LOG_SETTING)
+            {
+                log_disable = fw->data[count + 3];
+
+                *(cmd_pld + 2 + total_len + 3) = (skwbt_log_disable == 1) ? 1 : log_disable;
+                SKWBT_INFO("%s log_disable from NV:%d, skwbt_log_disable:%d", __func__, log_disable, skwbt_log_disable);
+            }
+            count += nv_pkt_len;
+            total_len += nv_pkt_len;
+        }
+        if(total_len > 0)
+        {
+            cmd_pld[0] = (char)page_offset;
+            cmd_pld[1] = (char)total_len;//para len
+            ret = btseekwave_send_hci_command(hdev, HCI_CMD_SKW_BT_NVDS, total_len + 2, cmd_pld);
+            if(ret < 0)
+            {
+                return -1;
+            }
+        }
+    }
+    else
+    {
+        log_disable = fw->data[0x131];
+        SKWBT_INFO("%s log_disable from NV:%d, skwbt_log_disable:%d", __func__, log_disable, skwbt_log_disable);
+        while(count < fw->size)
+        {
+            len = NV_FILE_RD_BLOCK_SIZE;
+            if((fw->size - count) < NV_FILE_RD_BLOCK_SIZE)
+            {
+                len = fw->size - count;
+            }
+            cmd_pld[0] = (char)page_offset;
+            cmd_pld[1] = (char)len;//para len
+            memcpy(cmd_pld + 2, fw->data + count, len);
+            count += len;
+
+            if(1 == page_offset)
+            {
+                *(cmd_pld + 2 + 53) = (skwbt_log_disable == 1) ? 1 : log_disable;
+            }
+
+            ret = btseekwave_send_hci_command(hdev, HCI_CMD_SKW_BT_NVDS, len + 2, cmd_pld);
+            if(ret < 0)
+            {
+                SKWBT_ERROR("%s cp response timeout", __func__);
+                break;
+            }
+            page_offset ++;
+        }
+    }
+
+    btseekwave_write_bd_addr(hdev);
+    btseekwave_write_ble_wakeup_adv_info(hdev);
+
+    kfree(cmd_pld);
+    release_firmware(fw);
+    is_init_mode = 0;
+
+    return 0;
+}
+
+
+static int btseekwave_open(struct hci_dev *hdev)
+{
+    struct btseekwave_data *data = hci_get_drvdata(hdev);
+    int err = -1;
+
+    SKWBT_INFO("%s enter...\n", __func__);
+
+    if(atomic_read(&cmd_reject))
+    {
+        int ret = wait_event_interruptible_timeout(recovery_wait_queue,
+                  (!atomic_read(&cmd_reject)),
+                  msecs_to_jiffies(2000));
+        if(!ret)
+        {
+            SKWBT_ERROR("%s timeout", __func__);
+            return ret;
+        }
+    }
+
+    if(data && data->pdata && data->pdata->open_port)
+    {
+        err = data->pdata->open_port(data->pdata->cmd_port, btseekwave_rx_complete,  data);
+
+        SKWBT_INFO("%s mode data_port:%d, audio_port:%d\n", __func__, data->pdata->data_port, data->pdata->audio_port);
+
+        if((!err) && (data->pdata->data_port != 0))
+        {
+            err = data->pdata->open_port(data->pdata->data_port, btseekwave_rx_complete, data);
+        }
+        if((!err) && (data->pdata->audio_port != 0))
+        {
+            err = data->pdata->open_port(data->pdata->audio_port, btseekwave_rx_complete, data);
+        }
+#if INCLUDE_NEW_VERSION
+        if(data->pdata->service_start)
+        {
+            err = data->pdata->service_start();
+            if(err != 0)
+            {
+                SKWBT_ERROR("func %s service_start err:%d", __func__, err);
+                return err;
+            }
+        }
+        else
+        {
+            SKWBT_ERROR("func %s service_start not exist", __func__);
+            return -1;
+        }
+#else
+        skw_start_bt_service();
+#endif
+        err = btseekwave_download_nv(hdev);
+        if(err == 0)
+        {
+            data->bt_is_open = 1;
+            if(data->plt_notifier_set == 0)
+            {
+                data->plt_notifier.notifier_call = btseekwave_plt_event_notifier;
+                data->pdata->modem_register_notify(&data->plt_notifier);
+                data->plt_notifier_set = 1;
+            }
+        }
+        else
+        {
+            btseekwave_port_close(data);
+        }
+
+    }
+    atomic_set(&atomic_close_sync, 0);
+    return err;
+}
+
+void btseekwave_write_bt_state(struct hci_dev *hdev)
+{
+    //char buffer[10] = {0x01, 0x80, 0xFE, 0x01, 0x00};
+    u8 cmd_pld[5] = {0x00};
+    struct sk_buff *skb = btseekwave_prepare_cmd(hdev, HCI_CMD_WRITE_BT_STATE, 1, cmd_pld);
+    if(skb)
+    {
+        btseekwave_send_frame(hdev, skb);
+        msleep(15);
+    }
+}
+
+
+static int btseekwave_close(struct hci_dev *hdev)
+{
+    struct btseekwave_data *data = hci_get_drvdata(hdev);
+    int state = 0;
+
+    SKWBT_INFO("%s enter...\n", __func__);
+
+    if(data && (data->pdata->data_port == 0))
+    {
+#if INCLUDE_NEW_VERSION
+
+#else
+        btseekwave_write_bt_state(hdev);
+#endif
+    }
+
+    if(atomic_read(&cmd_reject))
+    {
+        int ret = wait_event_interruptible_timeout(recovery_wait_queue,
+                  (!atomic_read(&cmd_reject)),
+                  msecs_to_jiffies(2000));
+        if(!ret)
+        {
+            SKWBT_ERROR("%s timeout", __func__);
+            return ret;
+        }
+    }
+    btseekwave_port_close(data);
+
+    state = atomic_read(&atomic_close_sync);
+    SKWBT_INFO("func %s, atomic_read:%d", __func__, state);
+
+    if(state == BT_STATE_DEFAULT)
+    {
+        atomic_set(&atomic_close_sync, BT_STATE_CLOSE);
+    }
+    else
+    {
+        atomic_set(&atomic_close_sync, BT_STATE_CLOSE);
+        wake_up(&close_wait_queue);
+    }
+    return 0;
+}
+
+static int btseekwave_flush(struct hci_dev *hdev)
+{
+    struct btseekwave_data *data = hci_get_drvdata(hdev);
+
+    SKWBT_INFO("%s", hdev->name);
+
+    if (work_pending(&data->work))
+    {
+        cancel_work_sync(&data->work);
+    }
+
+    skb_queue_purge(&data->cmd_txq);
+    skb_queue_purge(&data->data_txq);
+    skb_queue_purge(&data->audio_txq);
+
+    return 0;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 11, 0)
+//
+#else
+/*for low version*/
+static int btseekwave_send_frame_lv(struct sk_buff *skb)
+{
+    struct hci_dev *hdev = (struct hci_dev *) skb->dev;
+    return btseekwave_send_frame(hdev, skb);
+}
+#endif
+
+static int btseekwave_send_frame(struct hci_dev *hdev, struct sk_buff *skb)
+{
+    struct btseekwave_data *data = hci_get_drvdata(hdev);
+    u8 pkt_type = bt_cb(skb)->pkt_type;
+    u8 *d = skb_push(skb, 1);
+    *d = pkt_type;
+
+    if(data->pdata == NULL)
+    {
+        SKWBT_ERROR("%s pointer is null", __func__);
+        return -EILSEQ;
+    }
+    if((pkt_type == HCI_COMMAND_PKT) || ((pkt_type == HCI_ACLDATA_PKT) && (data->pdata->data_port == 0))
+            || ((pkt_type == HCI_SCODATA_PKT) && (data->pdata->audio_port == 0)))
+    {
+        hdev->stat.cmd_tx++;
+        skb_queue_tail(&data->cmd_txq, skb);
+    }
+    else if(pkt_type == HCI_ACLDATA_PKT)
+    {
+        hdev->stat.acl_tx++;
+        skb_queue_tail(&data->data_txq, skb);
+    }
+    else if(pkt_type == HCI_SCODATA_PKT)
+    {
+        skb_queue_tail(&data->audio_txq, skb);
+        hdev->stat.sco_tx++;
+    }
+    else
+    {
+        return -EILSEQ;
+    }
+
+#if BT_HCI_LOG_EN
+    skw_btsnoop_capture(skb->data, 0);
+#endif
+    schedule_work(&data->work);
+
+    return 0;
+}
+
+
+static int btseekwave_setup(struct hci_dev *hdev)
+{
+    SKWBT_INFO("%s", __func__);
+    return 0;
+}
+
+
+/*
+must be in DEVICE_ASSERT_EVENT to DEVICE_DUMPDONE_EVENT closing USB
+*/
+int btseekwave_plt_event_notifier(struct notifier_block *nb, unsigned long action, void *param)
+{
+    SKWBT_INFO("%s, action:%d", __func__, (int)action);
+    if(skw_data == NULL)
+    {
+        return 0;
+    }
+#if 1
+    switch(action)
+    {
+        case DEVICE_ASSERT_EVENT:
+        {
+            //make surce host data cann't send to plt driver before close usb
+            atomic_set(&cmd_reject, 1);
+#if INCLUDE_NEW_VERSION
+            if((skw_data) && (skw_data->pdata) && (skw_data->pdata->service_stop))
+            {
+                skw_data->pdata->service_stop();
+            }
+            else
+            {
+                SKWBT_ERROR("func %s service_stop not exist", __func__);
+            }
+#else
+            skw_stop_bt_service();
+#endif
+        }
+        break;
+        case DEVICE_BSPREADY_EVENT://
+        {
+            if(atomic_read(&cmd_reject))
+            {
+                struct btseekwave_data *data = skw_data;//container_of(nb, struct btseekwave_data, plt_notifier);
+                atomic_set(&cmd_reject, 0);
+                wake_up(&recovery_wait_queue);
+
+                if(data)
+                {
+                    btseekwave_flush(data->hdev);
+                    btseekwave_hci_hardware_error(data->hdev);//report to host
+                }
+            }
+        }
+        break;
+        case DEVICE_DUMPDONE_EVENT:
+        {
+
+        }
+        break;
+        case DEVICE_BLOCKED_EVENT:
+        {
+
+        }
+        break;
+        default:
+        {
+
+        }
+        break;
+
+    }
+#endif
+    return NOTIFY_OK;
+}
+
+static int btseekwave_probe(struct platform_device *pdev)
+{
+    struct btseekwave_data *data;
+    struct device *dev = &pdev->dev;
+    struct sv6160_platform_data *pdata = dev->platform_data;
+    struct hci_dev *hdev;
+    int err;
+    if(pdata == NULL)
+    {
+        SKWBT_ERROR("%s pdata is null", __func__);
+        return -ENOMEM;
+    }
+
+    SKWBT_INFO("%s pdev name %s\n", __func__, pdata->port_name);
+
+    data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);
+    if (!data)
+    {
+        SKWBT_ERROR("%s alloc fail", __func__);
+        return -ENOMEM;
+    }
+
+    skw_data = data;
+    data->plt_notifier_set = 0;
+    data->bt_is_open = 0;
+
+    data->pdata = pdata;
+
+    INIT_WORK(&data->work, btseekwave_work);
+
+    skb_queue_head_init(&data->cmd_txq);
+    skb_queue_head_init(&data->data_txq);
+    skb_queue_head_init(&data->audio_txq);
+
+    hdev = hci_alloc_dev();
+    if (!hdev)
+    {
+        return -ENOMEM;
+    }
+
+    hdev->bus = HCI_SDIO;
+    hci_set_drvdata(hdev, data);
+
+    data->hdev = hdev;
+
+    SET_HCIDEV_DEV(hdev, dev);
+
+    hdev->open     = btseekwave_open;
+    hdev->close    = btseekwave_close;
+    hdev->flush    = btseekwave_flush;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 11, 0)
+    hdev->send     = btseekwave_send_frame;
+#else
+    hdev->send     = btseekwave_send_frame_lv;
+#endif
+    hdev->setup    = btseekwave_setup;
+
+    atomic_set(&hdev->promisc, 0);
+
+
+    err = hci_register_dev(hdev);
+    if (err < 0)
+    {
+        hci_free_dev(hdev);
+        return err;
+    }
+
+    platform_set_drvdata(pdev, data);
+
+    skw_bd_addr_gen_init();
+    atomic_set(&cmd_reject, 0);
+    atomic_set(&atomic_close_sync, BT_STATE_DEFAULT);
+
+    return 0;
+}
+
+static int btseekwave_remove(struct platform_device *pdev)
+{
+    int state = atomic_read(&atomic_close_sync);
+
+    SKWBT_INFO("func %s, atomic_read:%d", __func__, state);
+	
+	atomic_set(&cmd_reject, 0);
+    if(BT_STATE_DEFAULT == state)
+    {
+        atomic_set(&atomic_close_sync, BT_STATE_REMOVE);
+        wait_event_interruptible_timeout(close_wait_queue,
+                                         (BT_STATE_CLOSE == atomic_read(&atomic_close_sync)),
+                                         msecs_to_jiffies(500));
+    }
+
+    atomic_set(&atomic_close_sync, BT_STATE_DEFAULT);
+    skw_data = NULL;
+    if(pdev)
+    {
+        struct btseekwave_data *data = platform_get_drvdata(pdev);
+        struct hci_dev *hdev;
+
+        if (!data)
+        {
+            return 0;
+        }
+        hdev = data->hdev;
+        data->bt_is_open = 0;
+
+        if(data->pdata && data->pdata->modem_unregister_notify && data->plt_notifier_set)
+        {
+            SKWBT_INFO("func %s modem_unregister_notify", __func__);
+            data->pdata->modem_unregister_notify(&data->plt_notifier);
+            data->plt_notifier_set = 0;
+        }
+
+        btseekwave_flush(hdev);
+
+        platform_set_drvdata(pdev, NULL);
+
+        hci_unregister_dev(hdev);
+
+        hci_free_dev(hdev);
+    }
+    SKWBT_INFO("func %s end", __func__);
+    return 0;
+}
+
+static struct platform_driver  btseekwave_driver =
+{
+    .driver = {
+        .name   = (char *)"btseekwave",
+        .bus    = &platform_bus_type,
+        .pm     = NULL,
+    },
+    .probe      = btseekwave_probe,
+    .remove     = btseekwave_remove,
+};
+
+int  btseekwave_init(void)
+{
+    SKWBT_INFO("Seekwave Bluetooth driver ver %s\n", VERSION);
+    init_waitqueue_head(&nv_wait_queue);
+    init_waitqueue_head(&recovery_wait_queue);
+    init_waitqueue_head(&close_wait_queue);
+    atomic_set(&evt_recv, 0);
+
+    wakeup_adv_info.data_len = 0;
+
+#ifdef BLE_WAKEUP_ADV_INFO
+    skw_parse_wakeup_adv_conf(BLE_WAKEUP_ADV_INFO, &wakeup_adv_info);
+#endif
+
+#if BT_HCI_LOG_EN
+    skw_btsnoop_init();
+#endif
+#if BT_CP_LOG_EN
+    skwlog_init();
+#endif
+
+    return platform_driver_register(&btseekwave_driver);
+}
+
+void  btseekwave_exit(void)
+{
+#if BT_HCI_LOG_EN
+    skw_btsnoop_close();
+#endif
+#if BT_CP_LOG_EN
+    skwlog_close();
+#endif
+
+    platform_driver_unregister(&btseekwave_driver);
+}
+
+module_init(btseekwave_init);
+module_exit(btseekwave_exit);
+
+MODULE_DESCRIPTION("Seekwave Bluetooth driver ver " VERSION);
+MODULE_VERSION(VERSION);
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/bluetooth/skwbt/skw_btsnoop.c b/drivers/bluetooth/skwbt/skw_btsnoop.c
new file mode 100755
index 000000000000..6c15556c0992
--- /dev/null
+++ b/drivers/bluetooth/skwbt/skw_btsnoop.c
@@ -0,0 +1,178 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2020-2021 SeekWave Technology
+ *
+ *
+ ******************************************************************************/
+
+#define LOG_TAG "skw_btsnoop"
+
+#include "skw_btsnoop.h"
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <linux/time.h>
+//#include <linux/timekeeping.h>
+#include "skw_common.h"
+
+static const uint64_t BTSNOOP_EPOCH_DELTA = 0x00dcddb30f2f8000ULL;
+
+uint64_t skw_btsnoop_timestamp(void)
+{
+    //uint64_t timestamp = ktime_get_ns() / 1000LL + BTSNOOP_EPOCH_DELTA;
+    //uint64_t timestamp = do_div(ktime_get_ns(), 1000) + BTSNOOP_EPOCH_DELTA;
+    uint64_t timestamp = div_u64(ktime_get_ns(), 1000) + BTSNOOP_EPOCH_DELTA;
+
+    return timestamp;
+}
+
+
+#if BT_HCI_LOG_EN
+
+static struct mutex btsnoop_log_lock;
+
+
+extern int skwbt_log_disable;
+
+
+struct file *skw_btsnoop_open(void)
+{
+    struct file *hci_btsnoop_fd = NULL;
+    char log_path[256] = {0}, is_new_file = 1;
+    int file_size = 0;
+    int file_mode = O_WRONLY | O_CREAT | O_APPEND;
+    struct file *fp = NULL;
+
+    snprintf(log_path, 256, "%s/btsnoop-hci.cfa", SEEKWAVE_BT_LOG_PATH);
+
+    fp = filp_open(log_path, O_RDONLY, 0644);
+    if(!IS_ERR(fp))
+    {
+        file_size = (int)vfs_llseek(fp, 0, SEEK_END);
+        //pr_info("btsnoop file size:%d", file_size);
+        filp_close(fp, NULL);
+    }
+    if(file_size >= MAX_BT_LOG_SIZE)
+    {
+        char tmp_path[256] = {0};
+        snprintf(tmp_path, 256, "%s/btsnoop-hci.cfa.last", SEEKWAVE_BT_LOG_PATH);
+        skw_file_copy(log_path, tmp_path);
+        file_mode = O_CREAT | O_WRONLY | O_TRUNC;
+    }
+    else if(file_size > 0)
+    {
+        is_new_file = 0;
+    }
+
+    //pr_info("btsnoop_rev_length:%d", btsnoop_rev_length);
+
+    hci_btsnoop_fd = filp_open(log_path, file_mode, 0644);
+
+    if ((hci_btsnoop_fd == NULL) || IS_ERR(hci_btsnoop_fd))
+    {
+        //pr_info("btsnoop open fail, err:%lld", PTR_ERR(fp));
+        hci_btsnoop_fd = NULL;
+        return NULL;
+    }
+
+    if(is_new_file)
+    {
+        skw_file_write(hci_btsnoop_fd, "btsnoop\0\0\0\0\1\0\0\x3\xea", 16);
+    }
+    return hci_btsnoop_fd;
+}
+
+void skw_btsnoop_init(void)
+{
+    mutex_init(&btsnoop_log_lock);
+}
+
+void skw_btsnoop_close(void)
+{
+    mutex_unlock(&btsnoop_log_lock);
+}
+
+static void skw_btsnoop_write(struct file *fp, const void *data, size_t length)
+{
+    if (fp != NULL)
+    {
+        skw_file_write(fp, data, length);
+    }
+}
+
+void skw_btsnoop_capture(const unsigned char *packet, unsigned char is_received)
+{
+    int length_he = 0;
+    int length    = 0;
+    int flags     = 0;
+    int drops     = 0;
+    unsigned char type = packet[0];
+
+    uint64_t timestamp = skw_btsnoop_timestamp();
+    unsigned int time_hi = timestamp >> 32;
+    unsigned int time_lo = timestamp & 0xFFFFFFFF;
+    struct file *fp = NULL;
+    if(skwbt_log_disable)
+    {
+        return ;
+    }
+
+    mutex_lock(&btsnoop_log_lock);
+
+    fp = skw_btsnoop_open();
+    if((fp == NULL) || IS_ERR(fp))
+    {
+        mutex_unlock(&btsnoop_log_lock);
+        return ;
+    }
+
+    switch (type)
+    {
+        case HCI_COMMAND_PKT:
+            length_he = packet[3] + 4;
+            flags = 2;
+            break;
+        case HCI_ACLDATA_PKT:
+            length_he = (packet[4] << 8) + packet[3] + 5;
+            flags = is_received;
+            break;
+        case HCI_SCODATA_PKT:
+            length_he = packet[3] + 4;
+            flags = is_received;
+            break;
+        case HCI_EVENT_PKT:
+            length_he = packet[2] + 3;
+            flags = 3;
+            break;
+        default:
+            mutex_unlock(&btsnoop_log_lock);
+            return;
+    }
+
+
+    length = htonl(length_he);
+    flags = htonl(flags);
+    drops = htonl(drops);
+    time_hi = htonl(time_hi);
+    time_lo = htonl(time_lo);
+
+    skw_btsnoop_write(fp, &length, 4);
+    skw_btsnoop_write(fp, &length, 4);
+    skw_btsnoop_write(fp, &flags, 4);
+    skw_btsnoop_write(fp, &drops, 4);
+    skw_btsnoop_write(fp, &time_hi, 4);
+    skw_btsnoop_write(fp, &time_lo, 4);
+
+    skw_btsnoop_write(fp, packet, length_he);
+
+    filp_close(fp, NULL);
+
+    mutex_unlock(&btsnoop_log_lock);
+}
+
+EXPORT_SYMBOL_GPL(skw_btsnoop_init);
+EXPORT_SYMBOL_GPL(skw_btsnoop_capture);
+EXPORT_SYMBOL_GPL(skw_btsnoop_close);
+EXPORT_SYMBOL_GPL(skw_btsnoop_timestamp);
+
+#endif
diff --git a/drivers/bluetooth/skwbt/skw_btsnoop.h b/drivers/bluetooth/skwbt/skw_btsnoop.h
new file mode 100755
index 000000000000..6ba8bf00006c
--- /dev/null
+++ b/drivers/bluetooth/skwbt/skw_btsnoop.h
@@ -0,0 +1,36 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2020-2021 SeekWave Technology
+ *
+ *
+ ******************************************************************************/
+
+
+#ifndef __SKW_BTSNOOP_H__
+#define __SKW_BTSNOOP_H__
+
+
+#include <linux/types.h>
+
+
+
+/* HCI Packet types */
+#define HCI_COMMAND_PKT     0x01
+#define HCI_ACLDATA_PKT     0x02
+#define HCI_SCODATA_PKT     0x03
+#define HCI_EVENT_PKT       0x04
+#define HCI_ISODATA_PKT		0x05
+#define HCI_EVENT_SKWLOG    0x07
+
+
+void skw_btsnoop_init(void);
+
+void skw_btsnoop_close(void);
+
+void skw_btsnoop_capture(const unsigned char *packet, unsigned char is_received);
+
+uint64_t skw_btsnoop_timestamp(void);
+
+
+
+#endif
diff --git a/drivers/bluetooth/skwbt/skw_common.c b/drivers/bluetooth/skwbt/skw_common.c
new file mode 100755
index 000000000000..16cd7acce69c
--- /dev/null
+++ b/drivers/bluetooth/skwbt/skw_common.c
@@ -0,0 +1,385 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2020-2023 SeekWave Technology
+ *
+ *
+ ******************************************************************************/
+
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/time.h>
+#include <linux/err.h>
+
+#include "skw_common.h"
+#include "skw_btsnoop.h"
+
+#if ((BT_HCI_LOG_EN == 1) || (BT_CP_LOG_EN == 1))
+
+#define FILE_RW_ENABLE
+
+#endif
+
+#ifndef BD_ADDR_FILE_PATH
+//#define BD_ADDR_FILE_PATH SEEKWAVE_BT_LOG_PATH
+#else
+
+#endif
+
+#define BD_ADDR_FILE_PATH "/devinfo/skwbt"
+//typedef unsigned long mm_segment_t;
+
+static unsigned char bdaddr_lap[4] = {0x12, 0x24, 0x56};
+static char bdaddr_valid = 0;
+static unsigned int randseed;
+
+
+
+#if 0
+mm_segment_t skwbt_get_fs(void)
+{
+    mm_segment_t oldfs;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 9, 0)
+    oldfs = force_uaccess_begin();
+#else
+    oldfs = get_fs();
+    set_fs(KERNEL_DS);
+#endif
+
+    return oldfs;
+}
+
+void skwbt_set_fs(mm_segment_t fs)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 9, 0)
+    force_uaccess_end(fs);
+#else
+    set_fs(fs);
+#endif
+
+}
+#endif
+
+ssize_t skw_file_write(struct file *fp, const void *buf, size_t len)
+{
+    ssize_t res_len = 0;
+    loff_t pos = fp->f_pos;
+    //mm_segment_t fs = skwbt_get_fs();
+#ifdef FILE_RW_ENABLE
+    res_len = skw_write(fp, buf, len, &pos);
+#endif
+    fp->f_pos = pos;
+    //skwbt_set_fs(fs);
+
+    return res_len;
+}
+EXPORT_SYMBOL_GPL(skw_file_write);
+
+
+ssize_t skw_file_read(struct file *fp, void *buf, size_t len)
+{
+    ssize_t res_len = 0;
+    loff_t pos = fp->f_pos;
+    //mm_segment_t fs = skwbt_get_fs();
+#ifdef FILE_RW_ENABLE
+    res_len = skw_read(fp, buf, len, &pos);
+#endif
+    fp->f_pos = pos;
+    //skwbt_set_fs(fs);
+    return res_len;
+}
+EXPORT_SYMBOL_GPL(skw_file_read);
+
+
+
+/*
+file copy
+return 1:success
+*/
+char skw_file_copy(char *scr_file, char *des_file)
+{
+#ifdef FILE_RW_ENABLE
+    struct file *src_fp = filp_open(scr_file, O_RDONLY, 0644);
+    struct file *des_fp = filp_open(des_file, O_RDWR | O_CREAT, 0644);
+    char *pld_buf;
+    int len;
+
+    if(IS_ERR(src_fp) || (IS_ERR(des_fp)))
+    {
+        return -1;
+    }
+    pld_buf = (char *)kzalloc(1025, GFP_KERNEL);
+
+    while(1)
+    {
+        len = skw_file_read(src_fp, pld_buf, 1024);
+        if(len <= 0)
+        {
+            break;
+        }
+        skw_file_write(des_fp, pld_buf, len);
+    }
+
+    kfree(pld_buf);
+    filp_close(src_fp, NULL);
+    filp_close(des_fp, NULL);
+#endif
+    return 1;
+}
+EXPORT_SYMBOL_GPL(skw_file_copy);
+
+
+
+unsigned int skw_rand(void)
+{
+    unsigned int r;// = randseed = randseed * 1103515245 + 12345;
+
+    do
+    {
+        r = randseed = randseed * 1103515245 + 12345;
+        r = (r << 16) | ((r >> 16) & 0xFFFF);
+    } while(r == 0);
+
+    return r;
+}
+
+void skw_srand(void)
+{
+    randseed = (unsigned int) ktime_get_ns();
+    skw_rand();
+    skw_rand();
+    skw_rand();
+}
+
+
+void skw_bd_addr_gen_init(void)
+{
+#ifdef BD_ADDR_FILE_PATH
+
+#ifdef FILE_RW_ENABLE
+    struct file *fp = NULL;
+    char file_path[256] = {0};
+    if(bdaddr_valid)
+    {
+        return ;
+    }
+    skw_srand();
+
+    snprintf(file_path, 256, "%s/skwbdaddr", BD_ADDR_FILE_PATH);
+
+    SKWBT_INFO("skwbdaddr init path:%s\n", file_path);
+
+    fp = filp_open(file_path, O_RDWR, 0666);
+    if((fp == NULL) || IS_ERR(fp))
+    {
+        fp = filp_open(file_path, O_RDWR | O_CREAT | O_TRUNC, 0666);
+        if((fp == NULL) || IS_ERR(fp))
+        {
+            SKWBT_INFO("skwbdaddr open err:%ld\n", PTR_ERR(fp));
+        }
+        else
+        {
+            bdaddr_lap[0] = (unsigned char)(skw_rand() & 0xFF);
+            bdaddr_lap[1] = (unsigned char)(skw_rand() & 0xFF);
+            bdaddr_lap[2] = (unsigned char)(skw_rand() & 0xFF);
+            SKWBT_INFO("skwbd addr:%x\n", *((u32 *)bdaddr_lap));
+            if(skw_file_write(fp, bdaddr_lap, 3) != 3)
+            {
+                SKWBT_INFO("skwbd addr write err:%ld\n", PTR_ERR(fp));
+            }
+            bdaddr_valid = 1;
+            filp_close(fp, NULL);
+
+        }
+    }
+    else
+    {
+        if(skw_file_read(fp, bdaddr_lap, 3) > 0)
+        {
+            bdaddr_valid = 1;
+        }
+
+        filp_close(fp, NULL);
+    }
+#endif
+#endif
+}
+EXPORT_SYMBOL_GPL(skw_bd_addr_gen_init);
+
+
+char skw_get_bd_addr(unsigned char *buffer)
+{
+    if(bdaddr_valid > 0)
+    {
+        buffer[0] = bdaddr_lap[0];
+        buffer[1] = bdaddr_lap[1];
+        buffer[2] = bdaddr_lap[2];
+        return 1;
+    }
+    return 0;
+}
+EXPORT_SYMBOL_GPL(skw_get_bd_addr);
+
+
+
+char *skw_strchr(char *str, const char ch)
+{
+    char *ptr = str;
+
+    while((ptr != NULL) && ((*ptr) != '\r') && ((*ptr) != '\n') && ((*ptr) != 0))
+    {
+        if((*ptr) == ch)
+        {
+            return ptr;
+        }
+        ptr ++;
+    }
+    return NULL;
+}
+
+int skw_strlen(char *str)
+{
+    char *ptr = str;
+    int str_len = 0;
+    while((ptr != NULL) && ((*ptr) != '\r') && ((*ptr) != '\n') && ((*ptr) != 0))
+    {
+        ptr ++;
+        str_len ++;
+    }
+    return str_len;
+}
+
+unsigned char skw_char2hex(char ch)
+{
+    unsigned char num = 0;
+    if(ch >= '0' && ch <= '9')
+    {
+        num = ch - 48;//0:48
+    }
+    else if(ch >= 'a' && ch <= 'f')
+    {
+        num = ch + 10 - 97;//a:97
+    }
+    else if(ch >= 'A' && ch <= 'F')
+    {
+        num = ch + 10 - 65;//A:65
+    }
+    return num;
+}
+
+
+/*
+    data_str = "xxxx;...."
+*/
+char *skwbt_config_get_uint8(char *data_str, uint8_t *value)
+{
+    char *split0 = skw_strchr(data_str, ';');
+    uint8_t len = 0;
+    char buffer[8] = {0};
+    if((split0 == NULL) || (split0 == data_str))
+    {
+        return NULL;
+    }
+    len = split0 - data_str;
+    if(len > 4)//invalid
+    {
+        SKWBT_INFO("%s, invalid str , %s", __func__, data_str);
+        return NULL;
+    }
+    memcpy(buffer, data_str, len);
+    *value = (int)simple_strtol(buffer, NULL, 10);
+    return split0 + 1;//skip ;
+}
+
+void skw_parse_wakeup_adv_conf(char *data_str, Wakeup_ADV_Info_St *wakeup_adv_info)
+{
+    //WakeupADVData=GPIO_No(decimal);Level(decimal);addr offset(decimal);ADVData(Hex);Mask(Hex)
+    int str_len = strlen(data_str);
+    char *base_ptr = data_str;
+    char *split0, *split1;
+    uint8_t adv_grp_nums = 0, adv_len = 0, mask_len;
+    uint8_t gpio_no = 0, level = 0, addr_offset;
+    uint8_t i = 0, j = 0, k;
+    Wakeup_ADV_Grp_St *adv_grp;
+    int total_len = 0;
+
+    wakeup_adv_info->data_len = 0;
+    if(str_len > 512)
+    {
+        SKWBT_INFO("%s, invalid config str, %s", __func__, data_str);
+        return ;
+    }
+    if((base_ptr = skwbt_config_get_uint8(base_ptr, &gpio_no)) == NULL)
+    {
+        return ;
+    }
+    if((base_ptr = skwbt_config_get_uint8(base_ptr, &level)) == NULL)
+    {
+        return ;
+    }
+    for(k = 0; k < BLE_ADV_WAKEUP_GRP_NUMS; k++)
+    {
+        //addr offset(decimal);ADVData(Hex);Mask(Hex)
+        if((base_ptr = skwbt_config_get_uint8(base_ptr, &addr_offset)) == NULL)
+        {
+            break;
+        }
+        if((addr_offset == 1) || (addr_offset > 26))
+        {
+            SKWBT_INFO("%s, invalid addr_offset , %s", __func__, data_str);
+            return ;
+        }
+        adv_grp = &wakeup_adv_info->adv_group[k];
+        split0 = strchr(base_ptr, ';');
+        if(split0 == NULL)
+        {
+            SKWBT_INFO("%s, invalid config , %s", __func__, data_str);
+            return ;
+        }
+        split1 = strchr(split0 + 1, ';');
+
+        adv_len = split0 - base_ptr;
+        adv_grp->addr_offset = addr_offset;
+        adv_grp->grp_len = adv_len + 2;//add addr_offset & self length
+
+        split0 ++;//skip ;
+        if(split1 == NULL)
+        {
+            mask_len = data_str + str_len - split0;
+        }
+        else
+        {
+            mask_len = split1 - split0;
+        }
+        if(mask_len != adv_len)
+        {
+            SKWBT_INFO("%s, mask_len != adv_len , %s", __func__, data_str);
+            return ;
+        }
+        SKWBT_INFO("grp len:%d, adv_len:%d", adv_grp->grp_len, adv_len);
+        for(i = 0, j = 0; i < adv_len; j ++, i += 2)
+        {
+            adv_grp->data[j] = (skw_char2hex(base_ptr[i]) << 4) | skw_char2hex(base_ptr[i + 1]);
+            adv_grp->mask[j] = (skw_char2hex(split0[i]) << 4) | skw_char2hex(split0[i + 1]);
+        }
+        total_len += adv_grp->grp_len;
+        adv_grp_nums ++;
+        if(split1 == NULL)
+        {
+            break;
+        }
+        base_ptr = split1 + 1;
+    }
+    wakeup_adv_info->data_len = total_len;//not contain gpio, level, grp_nums, gpio_no
+    wakeup_adv_info->grp_nums = adv_grp_nums;
+    wakeup_adv_info->gpio_no = gpio_no;
+    wakeup_adv_info->level = level;
+
+    SKWBT_INFO("ADV str len:%d, gpio:%d, level:%d, adv_grp_nums:%d, total_len:%d, Data:%s", str_len, gpio_no, level, adv_grp_nums, total_len, data_str);
+}
+
+EXPORT_SYMBOL_GPL(skw_parse_wakeup_adv_conf);
+
diff --git a/drivers/bluetooth/skwbt/skw_common.h b/drivers/bluetooth/skwbt/skw_common.h
new file mode 100755
index 000000000000..a5292252b037
--- /dev/null
+++ b/drivers/bluetooth/skwbt/skw_common.h
@@ -0,0 +1,144 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2020-2023 SeekWave Technology
+ *
+ *
+ ******************************************************************************/
+
+#ifndef __SKW_COMMON_H__
+#define __SKW_COMMON_H__
+
+#include <linux/types.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/module.h>
+
+
+#define BT_HCI_LOG_EN  0
+#define BT_CP_LOG_EN   0
+
+//WakeupADVData=gpio No;effactive level;addr offset;ADVData;Mask  ### ADVData size must be equal Mask size
+//#define BLE_WAKEUP_ADV_INFO "19;1;0;020106031980010FFF00112233AABBCCDD;0000FF0000FFFFFF000000000000000000"
+
+
+#ifndef INCLUDE_NEW_VERSION
+#define INCLUDE_NEW_VERSION 0
+#endif
+
+
+#define MAX_BT_LOG_SIZE (5*1024*1024) //500M
+
+
+#define SEEKWAVE_BT_LOG_PATH     "/mnt/skwbt"
+#define NV_FILE_NAME             "sv6160.nvbin"
+#define NV_FILE_NAME_6316        "sv6316.nvbin"
+#define NV_FILE_NAME_6160_LITE   "sv6160lite.nvbin"
+
+//#define BD_ADDR_FILE_PATH        ""
+
+
+#define BD_ADDR_LEN 6
+
+#define LOG_TYPE_HCI 0x01
+#define LOG_TYPE_CP  0x07
+
+
+#define SKWBT_INFO(format, ...) 	pr_info("[SKWBT_INFO] "format, ##__VA_ARGS__)
+#define SKWBT_ERROR(format, ...) 	pr_err("[SKWBT_ERROR] "format, ##__VA_ARGS__)
+
+#define SKW_CHIPID_6316       0x5301
+#define SKW_CHIPID_6160       0x0017
+#define SKW_CHIPID_6160_LITE  0x5302
+
+
+
+#define NV_FILE_RD_BLOCK_SIZE    252
+
+#define HCI_CMD_READ_LOCAL_VERSION_INFO 0x1001
+
+#define HCI_CMD_SKW_BT_NVDS                 0xFC80
+#define HCI_CMD_WRITE_BD_ADDR               0xFC82
+#define HCI_CMD_WRITE_BT_STATE              0xFE80
+#define HCI_CMD_WRITE_WAKEUP_ADV_DATA       0xFC84
+#define HCI_CMD_WRITE_WAKEUP_ADV_ENABLE     0xFC85
+#define HCI_CMD_WRITE_WAKEUP_ADV_ENABLE_PLT 0xFC86
+
+#define HCI_COMMAND_COMPLETE_EVENT      0x0E
+#define HCI_EVT_HARDWARE_ERROR          0x10
+
+#define NV_TAG_DSP_LOG_SETTING  0x05
+
+#ifndef UINT8_TO_STREAM
+#define UINT8_TO_STREAM(p, u8)   {*(p)++ = (uint8_t)(u8);}
+#endif
+
+
+#ifndef UINT16_TO_STREAM
+#define UINT16_TO_STREAM(p, u16) {*(p)++ = (uint8_t)(u16); *(p)++ = (uint8_t)((u16) >> 8);}
+#endif
+
+
+#if KERNEL_VERSION(4, 14, 0) <= LINUX_VERSION_CODE
+#define skw_read   kernel_read
+#define skw_write  kernel_write
+#else
+#define skw_read   vfs_read
+#define skw_write  vfs_write
+#endif
+
+#ifdef CONFIG_NO_GKI
+MODULE_IMPORT_NS(VFS_internal_I_am_really_a_filesystem_and_am_NOT_a_driver);
+#endif
+
+typedef struct{
+	uint8_t  type;
+	uint8_t  evt_op;
+	uint8_t  len;
+	uint8_t  nums;
+	uint16_t cmd_op;
+	uint8_t  status;
+}__packed hci_cmd_cmpl_evt_st;
+
+
+typedef struct
+{
+    uint8_t grp_len;
+    uint8_t addr_offset;
+    uint8_t data[32];
+    uint8_t mask[32];
+} Wakeup_ADV_Grp_St;
+
+#define BLE_ADV_WAKEUP_GRP_NUMS 3
+
+typedef struct
+{
+    uint8_t gpio_no;
+    uint8_t level;
+    uint8_t data_len;//total len
+    uint8_t grp_nums;
+    Wakeup_ADV_Grp_St adv_group[BLE_ADV_WAKEUP_GRP_NUMS];
+} Wakeup_ADV_Info_St;
+
+typedef enum{
+	WAKEUP_OP_DISABLE = 0x00,
+	WAKEUP_OP_SCAN_ONLY,
+	WAKEUP_OP_SCAN_ADV_HOST,//use host paramater
+	WAKEUP_OP_SCAN_ADV_SKW //use skw data: SeekwaveBT
+}le_wakeup_op_enum;
+
+ssize_t skw_file_write(struct file *, const void *, size_t);
+
+ssize_t skw_file_read(struct file *fp, void *buf, size_t len);
+
+char skw_file_copy(char *scr_file, char *des_file);
+
+void skw_bd_addr_gen_init(void);
+
+char skw_get_bd_addr(unsigned char *buffer);
+
+
+
+#endif
diff --git a/drivers/bluetooth/skwbt/skw_log.c b/drivers/bluetooth/skwbt/skw_log.c
new file mode 100755
index 000000000000..2fe323384920
--- /dev/null
+++ b/drivers/bluetooth/skwbt/skw_log.c
@@ -0,0 +1,122 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2020-2021 SeekWave Technology
+ *
+ *
+ ******************************************************************************/
+
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+//#include <linux/timekeeping.h>
+#include "skw_common.h"
+#include "skw_log.h"
+#include <linux/version.h>
+
+#if BT_CP_LOG_EN
+
+static struct mutex skwlog_lock;
+extern int skwbt_log_disable;
+
+struct file *skwlog_open(void)
+{
+    char log_path[256] = {0}, is_new_file = 1;
+    int file_size = 0;
+    int file_mode = O_CREAT | O_WRONLY | O_TRUNC;
+    struct file *fp = NULL;
+
+
+    snprintf(log_path, 256, "%s/skwbt_cp.log", SEEKWAVE_BT_LOG_PATH);
+
+    fp = filp_open(log_path, O_RDONLY, 0644);
+    if(!IS_ERR(fp))//file exist
+    {
+        file_size = (int)vfs_llseek(fp, 0, SEEK_END);
+        //pr_info("bt cp log file size:%d", file_size);
+        filp_close(fp, NULL);
+		file_mode = O_WRONLY;
+    }
+    if(file_size >= MAX_BT_LOG_SIZE)
+    {
+        char tmp_path[256] = {0};
+        snprintf(tmp_path, 256, "%s/skwbt_cp.log.last", SEEKWAVE_BT_LOG_PATH);
+        skw_file_copy(log_path, tmp_path);
+        file_mode = O_CREAT | O_WRONLY | O_TRUNC;
+		file_size = 0;
+    }
+    else if(file_size > 0)
+    {
+        is_new_file = 0;
+    }
+
+    fp = filp_open(log_path, file_mode, 0644);
+
+    if ((fp == NULL) || IS_ERR(fp))
+    {
+        return NULL;
+    }
+	fp->f_pos = file_size;
+	
+    if(is_new_file)
+    {
+        struct tm tm;
+        struct timespec64 tv;
+        unsigned char buffer[16] = {0x07, 0xFF, 0x08, 0x00, 0x01, 0xD0, 0x55, 0x55};
+        ktime_get_real_ts64(&tv);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,0,0)
+        time64_to_tm(tv.tv_sec, 0, &tm);
+#else
+        time_to_tm(tv.tv_sec, 0, &tm);
+#endif
+
+        buffer[8] = tm.tm_sec;//[0,59]
+        buffer[9] = tm.tm_min;//[0,59]
+        buffer[10] = tm.tm_hour;//[0,23]
+        buffer[11] = tm.tm_mday;//[1,31]
+
+
+        skw_file_write(fp, "skwcplog\0\1\0\2\0\0\x3\xEA", 16);
+        skw_file_write(fp, buffer, 12);
+    }
+    return fp;
+}
+
+
+void skwlog_init(void)
+{
+    mutex_init(&skwlog_lock);
+}
+
+
+void skwlog_write(unsigned char *buffer, unsigned int length)
+{
+	if(!skwbt_log_disable)
+	{
+		struct file *fp;
+		mutex_lock(&skwlog_lock);
+		fp = skwlog_open();
+		
+		if((fp == NULL) || IS_ERR(fp))
+		{
+			//pr_info("%s err:%ld", PTR_ERR(fp));
+		}
+		else
+		{
+			skw_file_write(fp, buffer, length);
+			filp_close(fp, NULL);
+		}
+		mutex_unlock(&skwlog_lock);
+	}
+}
+
+void skwlog_close(void)
+{
+    mutex_unlock(&skwlog_lock);
+}
+
+EXPORT_SYMBOL_GPL(skwlog_init);
+EXPORT_SYMBOL_GPL(skwlog_write);
+EXPORT_SYMBOL_GPL(skwlog_close);
+
+#endif
diff --git a/drivers/bluetooth/skwbt/skw_log.h b/drivers/bluetooth/skwbt/skw_log.h
new file mode 100755
index 000000000000..a99720d0901d
--- /dev/null
+++ b/drivers/bluetooth/skwbt/skw_log.h
@@ -0,0 +1,18 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2020-2021 SeekWave Technology
+ *
+ *
+ ******************************************************************************/
+
+#ifndef __SKW_LOG_H__
+#define __SKW_LOG_H__
+
+void skwlog_init(void);
+
+void skwlog_write(unsigned char *buffer, unsigned int length);
+
+void skwlog_close(void);
+
+
+#endif
-- 
Created with Armbian build tools https://github.com/armbian/build

