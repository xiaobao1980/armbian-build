From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: John Doe <john.doe@somewhere.on.planet>
Date: Thu, 7 Aug 2025 15:22:12 +0800
Subject: Patching kernel rk35xx files drivers/misc/Kconfig
 drivers/misc/Makefile drivers/misc/seekwaveplatform_v20/Kconfig
 drivers/misc/seekwaveplatform_v20/Makefile
 drivers/misc/seekwaveplatform_v20/pcie/.gitignore
 drivers/misc/seekwaveplatform_v20/pcie/Kconfig
 drivers/misc/seekwaveplatform_v20/pcie/README
 drivers/misc/seekwaveplatform_v20/pcie/skw_edma_drv.c
 drivers/misc/seekwaveplatform_v20/pcie/skw_edma_drv.h
 drivers/misc/seekwaveplatform_v20/pcie/skw_edma_reg.h
 drivers/misc/seekwaveplatform_v20/pcie/skw_pcie_boot.c
 drivers/misc/seekwaveplatform_v20/pcie/skw_pcie_debugfs.c
 drivers/misc/seekwaveplatform_v20/pcie/skw_pcie_debugfs.h
 drivers/misc/seekwaveplatform_v20/pcie/skw_pcie_drv.c
 drivers/misc/seekwaveplatform_v20/pcie/skw_pcie_drv.h
 drivers/misc/seekwaveplatform_v20/pcie/skw_pcie_log.c
 drivers/misc/seekwaveplatform_v20/pcie/skw_pcie_log.h
 drivers/misc/seekwaveplatform_v20/pcie/skw_pcie_loopcheck.c
 drivers/misc/seekwaveplatform_v20/pcie/trace.c
 drivers/misc/seekwaveplatform_v20/pcie/trace.h
 drivers/misc/seekwaveplatform_v20/sdio/Kconfig
 drivers/misc/seekwaveplatform_v20/sdio/README.md
 drivers/misc/seekwaveplatform_v20/sdio/skw_sdio.h
 drivers/misc/seekwaveplatform_v20/sdio/skw_sdio_debugfs.c
 drivers/misc/seekwaveplatform_v20/sdio/skw_sdio_debugfs.h
 drivers/misc/seekwaveplatform_v20/sdio/skw_sdio_log.c
 drivers/misc/seekwaveplatform_v20/sdio/skw_sdio_log.h
 drivers/misc/seekwaveplatform_v20/sdio/skw_sdio_main.c
 drivers/misc/seekwaveplatform_v20/sdio/skw_sdio_rx.c
 drivers/misc/seekwaveplatform_v20/skwutil/Kconfig
 drivers/misc/seekwaveplatform_v20/skwutil/README.md
 drivers/misc/seekwaveplatform_v20/skwutil/boot_config.h
 drivers/misc/seekwaveplatform_v20/skwutil/skw_boot.c
 drivers/misc/seekwaveplatform_v20/skwutil/skw_boot.h
 drivers/misc/seekwaveplatform_v20/skwutil/skw_log_to_file.c
 drivers/misc/seekwaveplatform_v20/skwutil/skw_log_to_file.h
 drivers/misc/seekwaveplatform_v20/skwutil/skw_mem_map.h
 drivers/misc/seekwaveplatform_v20/skwutil/skw_user_com.c
 drivers/misc/seekwaveplatform_v20/usb/Kconfig
 drivers/misc/seekwaveplatform_v20/usb/README.md
 drivers/misc/seekwaveplatform_v20/usb/skw_usb.h
 drivers/misc/seekwaveplatform_v20/usb/skw_usb_debugfs.c
 drivers/misc/seekwaveplatform_v20/usb/skw_usb_debugfs.h
 drivers/misc/seekwaveplatform_v20/usb/skw_usb_io.c
 drivers/misc/seekwaveplatform_v20/usb/skw_usb_log.c
 drivers/misc/seekwaveplatform_v20/usb/skw_usb_log.h
 drivers/misc/seekwaveplatform_v20/usb/usb_boot.c
 drivers/misc/seekwaveplatform_v20/usb/usb_boot.h

Signed-off-by: John Doe <john.doe@somewhere.on.planet>
---
 drivers/misc/Kconfig                                        |    1 +
 drivers/misc/Makefile                                       |    1 +
 drivers/misc/seekwaveplatform_v20/Kconfig                   |   21 +
 drivers/misc/seekwaveplatform_v20/Makefile                  |   67 +
 drivers/misc/seekwaveplatform_v20/pcie/.gitignore           |  137 +
 drivers/misc/seekwaveplatform_v20/pcie/Kconfig              |    9 +
 drivers/misc/seekwaveplatform_v20/pcie/README               |    3 +
 drivers/misc/seekwaveplatform_v20/pcie/skw_edma_drv.c       | 1894 ++++++
 drivers/misc/seekwaveplatform_v20/pcie/skw_edma_drv.h       |  141 +
 drivers/misc/seekwaveplatform_v20/pcie/skw_edma_reg.h       |  191 +
 drivers/misc/seekwaveplatform_v20/pcie/skw_pcie_boot.c      |  594 ++
 drivers/misc/seekwaveplatform_v20/pcie/skw_pcie_debugfs.c   |   60 +
 drivers/misc/seekwaveplatform_v20/pcie/skw_pcie_debugfs.h   |   29 +
 drivers/misc/seekwaveplatform_v20/pcie/skw_pcie_drv.c       |  887 +++
 drivers/misc/seekwaveplatform_v20/pcie/skw_pcie_drv.h       |  159 +
 drivers/misc/seekwaveplatform_v20/pcie/skw_pcie_log.c       |  392 ++
 drivers/misc/seekwaveplatform_v20/pcie/skw_pcie_log.h       |   81 +
 drivers/misc/seekwaveplatform_v20/pcie/skw_pcie_loopcheck.c |  297 +
 drivers/misc/seekwaveplatform_v20/pcie/trace.c              |    9 +
 drivers/misc/seekwaveplatform_v20/pcie/trace.h              |   75 +
 drivers/misc/seekwaveplatform_v20/sdio/Kconfig              |    9 +
 drivers/misc/seekwaveplatform_v20/sdio/README.md            |    2 +
 drivers/misc/seekwaveplatform_v20/sdio/skw_sdio.h           |  271 +
 drivers/misc/seekwaveplatform_v20/sdio/skw_sdio_debugfs.c   |  214 +
 drivers/misc/seekwaveplatform_v20/sdio/skw_sdio_debugfs.h   |   52 +
 drivers/misc/seekwaveplatform_v20/sdio/skw_sdio_log.c       |  607 ++
 drivers/misc/seekwaveplatform_v20/sdio/skw_sdio_log.h       |   85 +
 drivers/misc/seekwaveplatform_v20/sdio/skw_sdio_main.c      | 1803 ++++++
 drivers/misc/seekwaveplatform_v20/sdio/skw_sdio_rx.c        | 2929 ++++++++++
 drivers/misc/seekwaveplatform_v20/skwutil/Kconfig           |   20 +
 drivers/misc/seekwaveplatform_v20/skwutil/README.md         |    1 +
 drivers/misc/seekwaveplatform_v20/skwutil/boot_config.h     |   86 +
 drivers/misc/seekwaveplatform_v20/skwutil/skw_boot.c        | 1150 ++++
 drivers/misc/seekwaveplatform_v20/skwutil/skw_boot.h        |  259 +
 drivers/misc/seekwaveplatform_v20/skwutil/skw_log_to_file.c |  806 +++
 drivers/misc/seekwaveplatform_v20/skwutil/skw_log_to_file.h |   49 +
 drivers/misc/seekwaveplatform_v20/skwutil/skw_mem_map.h     |  116 +
 drivers/misc/seekwaveplatform_v20/skwutil/skw_user_com.c    |  561 ++
 drivers/misc/seekwaveplatform_v20/usb/Kconfig               |   10 +
 drivers/misc/seekwaveplatform_v20/usb/README.md             |    2 +
 drivers/misc/seekwaveplatform_v20/usb/skw_usb.h             |   37 +
 drivers/misc/seekwaveplatform_v20/usb/skw_usb_debugfs.c     |   60 +
 drivers/misc/seekwaveplatform_v20/usb/skw_usb_debugfs.h     |   29 +
 drivers/misc/seekwaveplatform_v20/usb/skw_usb_io.c          | 2639 +++++++++
 drivers/misc/seekwaveplatform_v20/usb/skw_usb_log.c         |  432 ++
 drivers/misc/seekwaveplatform_v20/usb/skw_usb_log.h         |   86 +
 drivers/misc/seekwaveplatform_v20/usb/usb_boot.c            |  456 ++
 drivers/misc/seekwaveplatform_v20/usb/usb_boot.h            |   94 +
 48 files changed, 17913 insertions(+)

diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index d7861dd89992..6b2283477194 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -536,6 +536,7 @@ source "drivers/misc/bcm-vk/Kconfig"
 source "drivers/misc/cardreader/Kconfig"
 source "drivers/misc/habanalabs/Kconfig"
 source "drivers/misc/uacce/Kconfig"
 source "drivers/misc/pvpanic/Kconfig"
 source "drivers/misc/mchp_pci1xxxx/Kconfig"
+source "drivers/misc/seekwaveplatform_v20/Kconfig"
 endmenu
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index 78d96b1ddfbc..3f04a13ed9e9 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -65,5 +65,6 @@ obj-$(CONFIG_XILINX_SDFEC)	+= xilinx_sdfec.o
 obj-$(CONFIG_HISI_HIKEY_USB)	+= hisi_hikey_usb.o
 obj-$(CONFIG_HI6421V600_IRQ)	+= hi6421v600-irq.o
 obj-$(CONFIG_OPEN_DICE)		+= open-dice.o
 obj-$(CONFIG_GP_PCI1XXXX)	+= mchp_pci1xxxx/
 obj-$(CONFIG_VCPU_STALL_DETECTOR)	+= vcpu_stall_detector.o
+obj-y                           += seekwaveplatform_v20/
diff --git a/drivers/misc/seekwaveplatform_v20/Kconfig b/drivers/misc/seekwaveplatform_v20/Kconfig
new file mode 100755
index 000000000000..99dc207ae0c4
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/Kconfig
@@ -0,0 +1,21 @@
+menuconfig SEEKWAVE_BSP_DRIVERS_V20
+        bool "SeekWave Platform Drivers For SeekWave Chip"
+        default n
+        help
+        This is support seekwave chip for incard board
+        if you want to buildin bsp driver
+        please say "y" 
+        Thanks.
+
+config SEEKWAVE_PLD_RELEASE
+    bool "seekwave Platfrom support chip recoverymode"
+    depends on SEEKWAVE_BSP_DRIVERS_V20
+    default n
+
+#seekwave`s wifi bluetooth device driver etc
+if  SEEKWAVE_BSP_DRIVERS_V20
+source "drivers/misc/seekwaveplatform_v20/usb/Kconfig"
+source "drivers/misc/seekwaveplatform_v20/sdio/Kconfig"
+source "drivers/misc/seekwaveplatform_v20/skwutil/Kconfig"
+source "drivers/misc/seekwaveplatform_v20/pcie/Kconfig"
+endif
diff --git a/drivers/misc/seekwaveplatform_v20/Makefile b/drivers/misc/seekwaveplatform_v20/Makefile
new file mode 100755
index 000000000000..00a759c43f8c
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/Makefile
@@ -0,0 +1,67 @@
+#
+#SeekWave Platform Drivers Makefile
+#
+#
+PWD :=$(shell pwd)
+CURFOLDER ?=$(pwd)
+
+ifeq ($(CONFIG_SKW_PCIE),m)
+ccflags-y +=-Idrivers/misc/seekwaveplatform_v20/pcie
+endif
+
+#ifdef CONFIG_SEEKWAVE_BSP_DRIVERS_V20
+#obj-$(CONFIG_SKW_USB)               += usb/
+#obj-$(CONFIG_SKW_PCIE)               += pcie/
+#obj-$(CONFIG_SKW_SDIOHAL)           += sdio/
+#obj-$(CONFIG_SEEKWAVE_BSP_DRIVERS)  += skwutil/
+#endif
+
+ifeq ($(CONFIG_SKW_BT),m)
+        ccflags-y += -DCONFIG_BT_SEEKWAVE
+endif
+
+ifneq ($(skw_extra_flags),)
+        ccflags-y += $(skw_extra_flags) -DSKW_EXT_INC
+endif
+
+ifeq ($(CONFIG_SEEKWAVE_PLD_RELEASE),m)
+	ccflags-y += -DCONFIG_SEEKWAVE_PLD_RELEASE
+endif
+
+#ccflags-y += -DCONFIG_SEEKWAVE_PLD_RELEASE
+
+obj-$(CONFIG_SKW_SDIOHAL) += skw_sdio_v20.o
+skw_sdio_v20-y := sdio/skw_sdio_main.o
+skw_sdio_v20-y += sdio/skw_sdio_rx.o
+skw_sdio_v20-y += sdio/skw_sdio_debugfs.o
+skw_sdio_v20-y += sdio/skw_sdio_log.o
+skw_sdio_v20-y += skwutil/skw_user_com.o
+skw_sdio_v20-y += skwutil/skw_log_to_file.o
+skw_sdio_v20-y += skwutil/skw_boot.o
+
+obj-$(CONFIG_SKW_PCIE) += skw_pcie.o
+skw_pcie-objs := pcie/skw_pcie_drv.o
+skw_pcie-objs += pcie/skw_edma_drv.o
+skw_pcie-objs += pcie/skw_pcie_loopcheck.o
+skw_pcie-objs += pcie/skw_pcie_boot.o
+skw_pcie-objs += pcie/skw_pcie_debugfs.o
+skw_pcie-objs += pcie/skw_pcie_log.o
+#skw_pcie-objs += pcie/trace.o
+skw_pcie-objs += skwutil/skw_user_com.o
+skw_pcie-objs += skwutil/skw_log_to_file.o
+skw_pcie-objs += skwutil/skw_boot.o
+
+#CFLAGS_trace.o := -I$(src)
+
+obj-$(CONFIG_SKW_USB) += skw_usb_v20.o
+skw_usb_v20-y := usb/skw_usb_io.o
+skw_usb_v20-y += usb/skw_usb_debugfs.o
+skw_usb_v20-y += usb/skw_usb_log.o
+#skw_usb_v20-y += ./usb/skw_test.o
+skw_usb_v20-y += skwutil/skw_user_com.o
+skw_usb_v20-y += skwutil/skw_log_to_file.o
+skw_usb_v20-y += skwutil/skw_boot.o
+
+clean:
+	@rm -rf *.o *.ko *.mod.c *.order *.a *.builtin .*.cmd .*.d
+
diff --git a/drivers/misc/seekwaveplatform_v20/pcie/.gitignore b/drivers/misc/seekwaveplatform_v20/pcie/.gitignore
new file mode 100755
index 000000000000..70f3111a4210
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/pcie/.gitignore
@@ -0,0 +1,137 @@
+#
+# NOTE! Don't add files that are generated in specific
+# subdirectories here. Add them in the ".gitignore" file
+# in that subdirectory instead.
+#
+# NOTE! Please use 'git ls-files -i --exclude-standard'
+# command after changing this file, to see if there are
+# any tracked files which get ignored after the change.
+#
+# Normal rules (sorted alphabetically)
+#
+.*
+*.a
+*.asn1.[ch]
+*.bin
+*.bz2
+*.c.[012]*.*
+*.dtb
+*.dtb.S
+*.dwo
+*.elf
+*.gcno
+*.gz
+*.i
+*.ko
+*.lex.c
+*.ll
+*.lst
+*.lz4
+*.lzma
+*.lzo
+*.mod.c
+*.o
+*.o.*
+*.order
+*.s
+*.so
+*.so.dbg
+*.su
+*.symtypes
+*.tab.[ch]
+*.tar
+*.xz
+Module.symvers
+modules.builtin
+
+#
+# Top-level generic files
+#
+/boot.img
+/kernel.img
+/resource.img
+/zboot.img
+/tags
+/TAGS
+/linux
+/vmlinux
+/vmlinux.32
+/vmlinux-gdb.py
+/vmlinuz
+/System.map
+/Module.markers
+
+#
+# RPM spec file (make rpm-pkg)
+#
+/*.spec
+
+#
+# Debian directory (make deb-pkg)
+#
+/debian/
+
+#
+# Snap directory (make snap-pkg)
+#
+/snap/
+
+#
+# tar directory (make tar*-pkg)
+#
+/tar-install/
+
+#
+# git files that we don't want to ignore even if they are dot-files
+#
+!.gitignore
+!.mailmap
+!.cocciconfig
+!.clang-format
+
+#
+# Generated include files
+#
+include/config
+include/generated
+include/ksym
+arch/*/include/generated
+
+# stgit generated dirs
+patches-*
+
+# quilt's files
+patches
+series
+
+# cscope files
+cscope.*
+ncscope.*
+
+# gnu global files
+GPATH
+GRTAGS
+GSYMS
+GTAGS
+
+# id-utils files
+ID
+
+*.orig
+*~
+\#*#
+
+#
+# Leavings from module signing
+#
+extra_certificates
+signing_key.pem
+signing_key.priv
+signing_key.x509
+x509.genkey
+
+# Kconfig presets
+all.config
+
+# Kdevelop4
+*.kdev4
diff --git a/drivers/misc/seekwaveplatform_v20/pcie/Kconfig b/drivers/misc/seekwaveplatform_v20/pcie/Kconfig
new file mode 100755
index 000000000000..72cb91197005
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/pcie/Kconfig
@@ -0,0 +1,9 @@
+config SKW_PCIE
+	tristate "Seekwave Platform  PCIE Driver Support"
+	depends on SEEKWAVE_BSP_DRIVERS_V20
+	default n
+	help
+	  Enable this module for seekwave
+	  chip sdio interface bus Support.
+	  Please insmod this module before any other
+	  seekwave subsystem. Thanks.
diff --git a/drivers/misc/seekwaveplatform_v20/pcie/README b/drivers/misc/seekwaveplatform_v20/pcie/README
new file mode 100755
index 000000000000..e8900a628a26
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/pcie/README
@@ -0,0 +1,3 @@
+#README
+#2022-0517
+#SEEKWAVE TECH LTD
diff --git a/drivers/misc/seekwaveplatform_v20/pcie/skw_edma_drv.c b/drivers/misc/seekwaveplatform_v20/pcie/skw_edma_drv.c
new file mode 100755
index 000000000000..45fa62896314
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/pcie/skw_edma_drv.c
@@ -0,0 +1,1894 @@
+/*
+ * Copyright (C) 2022 Seekwave Tech Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/platform_device.h>
+#include <uapi/linux/sched/types.h>
+#include <linux/scatterlist.h>
+#include <linux/dma-mapping.h>
+#include <linux/version.h>
+#include <linux/semaphore.h>
+#include <linux/pm_runtime.h>
+#include <linux/kthread.h>
+#include <linux/module.h>
+#include <linux/list.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/tracepoint.h>
+#include <linux/iopoll.h>
+#include <linux/dma-direct.h>
+#include "skw_pcie_drv.h"
+#include "skw_pcie_log.h"
+#include "skw_pcie_debugfs.h"
+#include "skw_edma_reg.h"
+#include "skw_edma_drv.h"
+#include "trace.h"
+
+static u64 port_dmamask = DMA_BIT_MASK(32);
+struct edma_port edma_ports[MAX_PORT_NUM] = {0};
+static struct platform_device *wifi_data_pdev;
+char firmware_version[128];
+u32 last_sent_wifi_cmd[3];
+u32 port_sta_rec[32] = {0};
+u8 *at_buffer;
+char *bt_rx_buffer[4];
+
+extern int send_modem_assert_command(void);
+struct skw_channel_cfg edma_channels[MAX_EDMA_COUNT];
+struct edma_chn_info edma_chns_info[32] = {0};
+
+void __attribute__((unused)) skw_edma_unlock(void)
+{
+	struct wcn_pcie_info *priv = get_pcie_device_info();
+#ifdef CONFIG_WAKELOCK
+	__pm_relax(&priv->wake_lock.ws);
+#else
+	__pm_relax(priv->ws);
+#endif
+}
+
+static void __attribute__((unused)) skw_edma_lock(void)
+{
+	struct wcn_pcie_info *priv = get_pcie_device_info();
+#ifdef CONFIG_WAKELOCK
+	__pm_stay_awake(&priv->wake_lock.ws);
+#else
+	__pm_stay_awake(priv->ws);
+#endif
+}
+
+void __attribute__((unused)) skw_edma_lock_event(void)
+{
+	struct wcn_pcie_info *priv = get_pcie_device_info();
+	
+#ifdef CONFIG_WAKELOCK
+	wake_lock_timeout(&priv->wake_lock, jiffies_to_msecs(HZ / 2));
+#else
+	__pm_wakeup_event(priv->ws_event, jiffies_to_msecs(HZ / 2));
+#endif
+}
+
+static void __attribute__((unused)) skw_edma_wakeup_source_init(void)
+{
+	struct wcn_pcie_info *priv = get_pcie_device_info();
+#ifdef CONFIG_WAKELOCK
+	wake_lock_init(&priv->wake_lock, WAKE_LOCK_SUSPEND,"skw edma wake lock");
+	wake_lock_init(&priv->wake_lockevent, WAKE_LOCK_SUSPEND,"skw edma wake lock evevnt");
+#else
+	priv->ws = skw_wakeup_source_register(NULL, "skw edma wake lock");
+	priv->ws_event = skw_wakeup_source_register(NULL, "skw edma wake lock evevnt");
+#endif
+}
+static void skw_edma_wakeup_source_destroy(void)
+{
+	struct wcn_pcie_info *priv = get_pcie_device_info();
+#ifdef CONFIG_WAKELOCK
+	wake_lock_destroy(&priv->rx_wl);
+	wake_lock_destroy(&priv->wake_lockevent);
+#else
+	wakeup_source_unregister(priv->ws);
+	wakeup_source_unregister(priv->ws_event);
+#endif
+}
+
+void skw_get_port_statistic(char *buffer, int size)
+{
+	int ret = 0;
+	int i;
+	if(!buffer)
+		return;
+	for(i=0; i<MAX_PORT_NUM; i++)
+	{
+		if(ret >= size)
+			break;
+		if(edma_ports[i].state)
+			ret += sprintf(&buffer[ret], "port%d: rx %d, tx  %d\n",
+					i,edma_ports[i].rx_size,edma_ports[i].tx_size);
+		}
+}
+
+static void edma_spin_lock_init(struct wcn_pcie_info *priv)
+{
+	priv->spin_lock = kmalloc(sizeof(spinlock_t), GFP_KERNEL);
+	spin_lock_init(priv->spin_lock);
+}
+
+struct edma_chn_info *get_edma_channel_info(int id)
+{
+	return &edma_chns_info[id];
+}
+
+struct edma_port *get_edma_port_info(int portno)
+{
+	return &edma_ports[portno];
+}
+
+void *edma_coherent_rcvheader_to_cpuaddr(u64 rcv_pcie_addr, struct edma_chn_info *edma_chp)
+{
+	u32 offset;
+	void *cpu_addr;
+
+	offset = rcv_pcie_addr - edma_chp->chn_cfg.header;
+	cpu_addr = (void *)((char *)edma_chp->p_link_hdr + 8 + offset);
+	return cpu_addr;
+}
+
+u32 edma_clear_src_node_count(int channel)
+{
+	return skw_pcie_read32(DMA_SRC_INT_DSCR_HIGH(channel));
+}
+
+int edma_get_node_tot_cnt(int channel)
+{
+	DMA_NODE_TOT_CNT_S node_cnt;
+
+	node_cnt.u32 = skw_pcie_read32(DMA_NODE_TOT_CNT(channel));
+
+	return node_cnt.src_tot_node_num;
+}
+
+static int inline is_legacy_irq_wifi_takeover(int ch_id)
+{
+	if (ch_id == EDMA_WIFI_TX0_FREE_ADDR || ch_id == EDMA_WIFI_TX1_FREE_ADDR
+		|| ch_id == EDMA_WIFI_RX0_PKT_ADDR || ch_id == EDMA_WIFI_RX1_PKT_ADDR
+		|| ch_id == EDMA_WIFI_RX0_FILTER_DATA_CHN || ch_id == EDMA_WIFI_RX1_FILTER_DATA_CNH
+		|| ch_id == EDMA_WIFI_TX0_PACKET_ADDR || ch_id == EDMA_WIFI_TX1_PACKET_ADDR)
+		return 1;
+	else
+		return 0;
+}
+
+
+int legacy_edma_irq_handle(void)
+{
+	struct edma_chn_info *edma_chp;
+	struct wcn_pcie_info *priv = get_pcie_device_info();
+	int ch_id;
+	EDMA_ADDR_T node_addr0={0}, node_addr1={0};
+	u64 header, tail;
+	u32 count;
+	u64 val;
+
+	DMA_SRC_INT_DSCR_HIGH_S chn_src_node_cnt;
+	DMA_DST_INT_DSCR_HIGH_S chn_dst_node_cnt;
+	DMA_SRC_INT_S reg_chn_src_int = {0};
+	DMA_DST_INT_S reg_chn_dst_int = {0};
+	u32 status;
+	ulong flags;
+
+	spin_lock_irqsave(priv->spin_lock, flags);
+	status = skw_pcie_read32(DMA_INT_MASK_STS);
+
+	if (!status) {
+		//BUG_ON(1);
+		spin_unlock_irqrestore(priv->spin_lock, flags);
+		return 0;
+	}
+
+	for (ch_id=0; ch_id<MAX_EDMA_COUNT;ch_id++) {
+		if (status & (1<<ch_id)) {
+			edma_chp = get_edma_channel_info(ch_id);
+			if (edma_chp->chn_cfg.direction == EDMA_TX) {//tx
+				reg_chn_src_int.u32 = skw_pcie_read32(DMA_SRC_INT(ch_id));
+				if (reg_chn_src_int.src_complete_mask_sts) {
+					reg_chn_src_int.src_complete_int_clr = 1;
+					skw_pcie_write32(DMA_SRC_INT(ch_id), reg_chn_src_int.u32);
+					node_addr0.addr_l32 = skw_pcie_read32(DMA_SRC_INT_DSCR_HEAD_LOW(ch_id));
+					node_addr1.addr_l32 = skw_pcie_read32(DMA_SRC_INT_DSCR_TAIL_LOW(ch_id));
+					chn_src_node_cnt.u32 = skw_pcie_read32(DMA_SRC_INT_DSCR_HIGH(ch_id));
+					count = chn_src_node_cnt.src_node_done_num;
+
+					node_addr0.addr_h8 = chn_src_node_cnt.src_int_dscr_head_high;
+					val = node_addr0.addr_h8;
+					header = (u64)(((node_addr0.addr_l32 & 0xffffffff) | ((val & 0xff) << 32)));
+
+					node_addr1.addr_h8 = chn_src_node_cnt.src_int_dscr_tail_high;
+					val = node_addr1.addr_h8;
+					tail = (u64)(((node_addr1.addr_l32 & 0xffffffff) | ((val & 0xff) << 32)));
+					if(edma_chp->chn_cfg.complete_callback){
+						edma_chp->chn_cfg.complete_callback(edma_chp->chn_cfg.context, header,tail, count);
+					}
+					if(reg_chn_src_int.src_list_empty_mask_sts){
+						reg_chn_src_int.src_list_empty_int_clr = 1;
+						skw_pcie_write32(DMA_SRC_INT(ch_id), reg_chn_src_int.u32);
+						if (edma_chp->chn_cfg.empty_callback)
+							edma_chp->chn_cfg.empty_callback(edma_chp->chn_cfg.context);
+					}
+				}
+			} else {//rx
+				reg_chn_dst_int.u32 = skw_pcie_read32(DMA_DST_INT(ch_id));
+				if (reg_chn_dst_int.dst_complete_mask_sts) {
+					if (is_legacy_irq_wifi_takeover(ch_id)) {
+						legacy_irq_wifi_takeover_handler(ch_id);
+						continue;
+					}
+					reg_chn_dst_int.dst_complete_int_clr = 1;
+					skw_pcie_write32(DMA_DST_INT(ch_id), reg_chn_dst_int.u32);
+					node_addr0.addr_l32 = skw_pcie_read32(DMA_DST_INT_DSCR_HEAD_LOW(ch_id));
+					node_addr1.addr_l32 = skw_pcie_read32(DMA_DST_INT_DSCR_TAIL_LOW(ch_id));
+					chn_dst_node_cnt.u32 = skw_pcie_read32(DMA_DST_INT_DSCR_HIGH(ch_id));
+					count = chn_dst_node_cnt.dst_node_done_num;
+
+					node_addr0.addr_h8 = chn_dst_node_cnt.dst_int_dscr_head_high;
+					val = node_addr0.addr_h8;
+					header = (u64)(((node_addr0.addr_l32 & 0xffffffff) | ((val & 0xff) << 32)));
+
+					node_addr1.addr_h8 = chn_dst_node_cnt.dst_int_dscr_tail_high;
+					val = node_addr1.addr_h8;
+					tail = (u64)(((node_addr1.addr_l32 & 0xffffffff) | ((val & 0xff) << 32)));
+					if(edma_chp->chn_cfg.complete_callback){
+						edma_chp->chn_cfg.complete_callback(edma_chp->chn_cfg.context, header, tail, count);
+					}
+					if(reg_chn_dst_int.dst_list_empty_mask_sts){
+						reg_chn_dst_int.dst_list_empty_int_clr = 1;
+						skw_pcie_write32(DMA_DST_INT(ch_id), reg_chn_dst_int.u32);
+						if (edma_chp->chn_cfg.empty_callback)
+							edma_chp->chn_cfg.empty_callback(edma_chp->chn_cfg.context);
+					}
+				}
+
+			}
+		}
+	}
+	spin_unlock_irqrestore(priv->spin_lock, flags);
+	return 0;
+}
+
+int msi_edma_channel_irq_handler(int irq_num)
+{
+	struct edma_chn_info *edma_chp;
+	struct wcn_pcie_info *priv = get_pcie_device_info();
+	int ch_id;
+	EDMA_ADDR_T node_addr0={0}, node_addr1={0};
+	u64 header, tail;
+	u32 count;
+	u64 val;
+	DMA_SRC_INT_DSCR_HIGH_S chn_src_node_cnt;
+	DMA_DST_INT_DSCR_HIGH_S chn_dst_node_cnt;
+
+	DMA_SRC_INT_S reg_chn_src_int = {0};
+	DMA_DST_INT_S reg_chn_dst_int = {0};
+	unsigned long flags;
+
+	spin_lock_irqsave(priv->spin_lock, flags);
+
+	if (priv->msix_en == 1)
+		ch_id = irq_num/2;
+	else
+		ch_id = irq_num;
+
+	edma_chp = get_edma_channel_info(ch_id);
+
+	if (edma_chp->chn_cfg.req_mode == EDMA_STD_MODE) {
+		if (edma_chp->chn_cfg.direction == EDMA_TX){
+			reg_chn_src_int.u32 = skw_pcie_read32(DMA_SRC_INT(ch_id));
+			if (priv->msix_en == 1) {
+				if ((irq_num % 2 == 0) && reg_chn_src_int.src_complete_mask_sts){
+					reg_chn_src_int.src_complete_int_clr = 1;
+					skw_pcie_write32(DMA_SRC_INT(ch_id), reg_chn_src_int.u32);
+					if (edma_chp->chn_cfg.complete_callback)
+						edma_chp->chn_cfg.complete_callback(edma_chp->chn_cfg.context, 0, 0, 0);
+				}
+				if((irq_num % 2 == 1) && reg_chn_src_int.src_list_empty_mask_sts){
+					reg_chn_src_int.src_list_empty_int_clr = 1;
+					skw_pcie_write32(DMA_SRC_INT(ch_id), reg_chn_src_int.u32);
+					if (edma_chp->chn_cfg.empty_callback)
+						edma_chp->chn_cfg.empty_callback(edma_chp->chn_cfg.context);
+				}
+			} else if (priv->msi_en == 1) {
+				if (reg_chn_src_int.src_complete_mask_sts){
+					reg_chn_src_int.src_complete_int_clr = 1;
+					skw_pcie_write32(DMA_SRC_INT(ch_id), reg_chn_src_int.u32);
+					if (edma_chp->chn_cfg.complete_callback)
+							edma_chp->chn_cfg.complete_callback(edma_chp->chn_cfg.context, 0, 0, 0);
+				}
+				if(reg_chn_src_int.src_list_empty_mask_sts){
+					reg_chn_src_int.src_list_empty_int_clr = 1;
+					skw_pcie_write32(DMA_SRC_INT(ch_id), reg_chn_src_int.u32);
+					if (edma_chp->chn_cfg.empty_callback)
+						edma_chp->chn_cfg.empty_callback(edma_chp->chn_cfg.context);
+				}
+			}
+		} else if (edma_chp->chn_cfg.direction == EDMA_RX){
+			reg_chn_dst_int.u32 = skw_pcie_read32(DMA_DST_INT(ch_id));
+			if (priv->msix_en == 1) {
+				if ((irq_num % 2 == 0) && reg_chn_dst_int.dst_complete_mask_sts){
+					reg_chn_dst_int.dst_complete_int_clr = 1;
+					skw_pcie_write32(DMA_DST_INT(ch_id), reg_chn_dst_int.u32);
+					if (edma_chp->chn_cfg.complete_callback)
+						edma_chp->chn_cfg.complete_callback(edma_chp->chn_cfg.context, 0, 0, 0);
+				}
+				if((irq_num % 2 == 1) && reg_chn_dst_int.dst_list_empty_mask_sts){
+					reg_chn_dst_int.dst_list_empty_int_clr = 1;
+					skw_pcie_write32(DMA_DST_INT(ch_id), reg_chn_dst_int.u32);
+					if (edma_chp->chn_cfg.empty_callback)
+						edma_chp->chn_cfg.empty_callback(edma_chp->chn_cfg.context);
+				}
+			} else if (priv->msi_en == 1) {
+				if (reg_chn_dst_int.dst_complete_mask_sts){
+					reg_chn_dst_int.dst_complete_int_clr = 1;
+					skw_pcie_write32(DMA_DST_INT(ch_id), reg_chn_dst_int.u32);
+					if (edma_chp->chn_cfg.complete_callback)
+							edma_chp->chn_cfg.complete_callback(edma_chp->chn_cfg.context, 0, 0, 0);
+				}
+				if(reg_chn_dst_int.dst_list_empty_mask_sts){
+					reg_chn_dst_int.dst_list_empty_int_clr = 1;
+					skw_pcie_write32(DMA_DST_INT(ch_id), reg_chn_dst_int.u32);
+					if (edma_chp->chn_cfg.empty_callback)
+						edma_chp->chn_cfg.empty_callback(edma_chp->chn_cfg.context);
+				}
+			}
+		}
+	} else if (edma_chp->chn_cfg.req_mode == EDMA_LINKLIST_MODE) {
+		if(edma_chp->chn_cfg.direction == EDMA_TX){
+			reg_chn_src_int.u32 = skw_pcie_read32(DMA_SRC_INT(ch_id));
+			if (priv->msix_en == 1) {
+				if ((irq_num % 2 == 0) && reg_chn_src_int.src_complete_mask_sts){
+					reg_chn_src_int.src_complete_int_clr = 1;
+					skw_pcie_write32(DMA_SRC_INT(ch_id), reg_chn_src_int.u32);
+					node_addr0.addr_l32 = skw_pcie_read32(DMA_SRC_INT_DSCR_HEAD_LOW(ch_id));
+					node_addr1.addr_l32 = skw_pcie_read32(DMA_SRC_INT_DSCR_TAIL_LOW(ch_id));
+					chn_src_node_cnt.u32 = skw_pcie_read32(DMA_SRC_INT_DSCR_HIGH(ch_id));
+					count = chn_src_node_cnt.src_node_done_num;
+
+					node_addr0.addr_h8 = chn_src_node_cnt.src_int_dscr_head_high;
+					val = node_addr0.addr_h8;
+					header = (u64)(((node_addr0.addr_l32 & 0xffffffff) | ((val & 0xff) << 32)));
+
+					node_addr1.addr_h8 = chn_src_node_cnt.src_int_dscr_tail_high;
+					val = node_addr1.addr_h8;
+					tail = (u64)(((node_addr1.addr_l32 & 0xffffffff) | ((val & 0xff) << 32)));
+
+					PCIE_DBG("ch_id:%d, EDMA_TX, header:%llx, tail:%llx, node_cnt:%d\n",
+						ch_id, header, tail, count);
+
+					if(edma_chp->chn_cfg.complete_callback){
+						edma_chp->chn_cfg.complete_callback(edma_chp->chn_cfg.context, header, tail, count);
+					}
+				}
+				if((irq_num % 2 == 1) && reg_chn_src_int.src_list_empty_mask_sts){
+					reg_chn_src_int.src_list_empty_int_clr = 1;
+					skw_pcie_write32(DMA_SRC_INT(ch_id), reg_chn_src_int.u32);
+					if (edma_chp->chn_cfg.empty_callback)
+						edma_chp->chn_cfg.empty_callback(edma_chp->chn_cfg.context);
+				}
+			} else if (priv->msi_en == 1) {
+				if (reg_chn_src_int.src_complete_mask_sts){
+					reg_chn_src_int.src_complete_int_clr = 1;
+					skw_pcie_write32(DMA_SRC_INT(ch_id), reg_chn_src_int.u32);
+
+					node_addr0.addr_l32 = skw_pcie_read32(DMA_SRC_INT_DSCR_HEAD_LOW(ch_id));
+					node_addr1.addr_l32 = skw_pcie_read32(DMA_SRC_INT_DSCR_TAIL_LOW(ch_id));
+					chn_src_node_cnt.u32 = skw_pcie_read32(DMA_SRC_INT_DSCR_HIGH(ch_id));
+					count = chn_src_node_cnt.src_node_done_num;
+
+					node_addr0.addr_h8 = chn_src_node_cnt.src_int_dscr_head_high;
+					val = node_addr0.addr_h8;
+					header = (u64)(((node_addr0.addr_l32 & 0xffffffff) | ((val & 0xff) << 32)));
+
+					node_addr1.addr_h8 = chn_src_node_cnt.src_int_dscr_tail_high;
+					val = node_addr1.addr_h8;
+					tail = (u64)(((node_addr1.addr_l32 & 0xffffffff) | ((val & 0xff) << 32)));
+
+					PCIE_DBG("ch_id:%d, EDMA_TX, header:%llx, tail:%llx, node_cnt:%d\n",
+						ch_id, header, tail, count);
+
+					if(edma_chp->chn_cfg.complete_callback)
+						edma_chp->chn_cfg.complete_callback(edma_chp->chn_cfg.context, header, tail, count);
+				}
+				if(reg_chn_src_int.src_list_empty_mask_sts){
+					reg_chn_src_int.src_list_empty_int_clr = 1;
+					skw_pcie_write32(DMA_SRC_INT(ch_id), reg_chn_src_int.u32);
+					if (edma_chp->chn_cfg.empty_callback) {
+						edma_chp->chn_cfg.empty_callback(edma_chp->chn_cfg.context);
+					}
+				}
+			}
+		} else if (edma_chp->chn_cfg.direction == EDMA_RX) {
+			reg_chn_dst_int.u32 = skw_pcie_read32(DMA_DST_INT(ch_id));
+			if (priv->msix_en == 1) {
+				if ((irq_num % 2 == 0) && reg_chn_dst_int.dst_complete_mask_sts){
+					reg_chn_dst_int.dst_complete_int_clr = 1;
+					//reg_chn_dst_int.dst_complete_int_en = 0;
+					skw_pcie_write32(DMA_DST_INT(ch_id), reg_chn_dst_int.u32);
+
+					node_addr0.addr_l32 = skw_pcie_read32(DMA_DST_INT_DSCR_HEAD_LOW(ch_id));
+					node_addr1.addr_l32 = skw_pcie_read32(DMA_DST_INT_DSCR_TAIL_LOW(ch_id));
+					chn_dst_node_cnt.u32 = skw_pcie_read32(DMA_DST_INT_DSCR_HIGH(ch_id));
+					count = chn_dst_node_cnt.dst_node_done_num;
+
+					node_addr0.addr_h8 = chn_dst_node_cnt.dst_int_dscr_head_high;
+					val = node_addr0.addr_h8;
+					//pcie_addr
+					header = (u64)(((node_addr0.addr_l32 & 0xffffffff) | ((val & 0xff) << 32)));
+
+					node_addr1.addr_h8 = chn_dst_node_cnt.dst_int_dscr_tail_high;
+					val = node_addr1.addr_h8;
+					//pcie_addr
+					tail = (u64)(((node_addr1.addr_l32 & 0xffffffff) | ((val & 0xff) << 32)));
+
+					PCIE_DBG("ch_id:%d, EDMA_RX, header:%llx, tail:%llx, node_cnt:%d\n",
+						ch_id, header, tail, count);
+
+					if(edma_chp->chn_cfg.complete_callback)
+						edma_chp->chn_cfg.complete_callback(edma_chp->chn_cfg.context, header, tail, count);
+
+					PCIE_DBG("exit irq!!!!!!!!!!!!\n");
+					////trace_skw_edma_channel_irq_handler(__LINE__, "exit rx irq!!!", 0);
+					reg_chn_dst_int.u32 = skw_pcie_read32(DMA_DST_INT(ch_id));
+					//reg_chn_dst_int.dst_complete_int_en = 1;
+					skw_pcie_write32(DMA_DST_INT(ch_id), reg_chn_dst_int.u32);
+				}
+				if((irq_num % 2 == 1) && reg_chn_dst_int.dst_list_empty_mask_sts){
+					reg_chn_dst_int.dst_list_empty_int_clr = 1;
+					skw_pcie_write32(DMA_DST_INT(ch_id), reg_chn_dst_int.u32);
+					if (edma_chp->chn_cfg.empty_callback)
+						edma_chp->chn_cfg.empty_callback(edma_chp->chn_cfg.context);
+				}
+			} else if (priv->msi_en == 1) {
+				if (reg_chn_dst_int.dst_complete_mask_sts){
+					reg_chn_dst_int.dst_complete_int_clr = 1;
+					skw_pcie_write32(DMA_DST_INT(ch_id), reg_chn_dst_int.u32);
+
+					node_addr0.addr_l32 = skw_pcie_read32(DMA_DST_INT_DSCR_HEAD_LOW(ch_id));
+					node_addr1.addr_l32 = skw_pcie_read32(DMA_DST_INT_DSCR_TAIL_LOW(ch_id));
+					chn_dst_node_cnt.u32 = skw_pcie_read32(DMA_DST_INT_DSCR_HIGH(ch_id));
+					count = chn_dst_node_cnt.dst_node_done_num;
+
+					node_addr0.addr_h8 = chn_dst_node_cnt.dst_int_dscr_head_high;
+					val = node_addr0.addr_h8;
+					header = (u64)(((node_addr0.addr_l32 & 0xffffffff) | ((val & 0xff) << 32)));
+
+					node_addr1.addr_h8 = chn_dst_node_cnt.dst_int_dscr_tail_high;
+					val = node_addr1.addr_h8;
+					tail = (u64)(((node_addr1.addr_l32 & 0xffffffff) | ((val & 0xff) << 32)));
+
+					PCIE_DBG("ch_id:%d, EDMA_RX, header:%llx, tail:%llx, node_cnt:%d\n",
+						ch_id, header, tail, count);
+
+					if(edma_chp->chn_cfg.complete_callback)
+						edma_chp->chn_cfg.complete_callback(edma_chp->chn_cfg.context, header, tail, count);
+
+					if(reg_chn_dst_int.dst_list_empty_mask_sts){
+						reg_chn_dst_int.dst_list_empty_int_clr = 1;
+						skw_pcie_write32(DMA_DST_INT(ch_id), reg_chn_dst_int.u32);
+						if (edma_chp->chn_cfg.empty_callback) {
+							edma_chp->chn_cfg.empty_callback(edma_chp->chn_cfg.context);
+						}
+					}
+				}
+			}
+		}
+	}
+
+	spin_unlock_irqrestore(priv->spin_lock, flags);
+
+	return 0;
+}
+
+int submit_list_to_edma_channel(int ch_id, u64 header, int count)
+{
+	struct edma_chn_info *dma_chp = get_edma_channel_info(ch_id);
+	u32 edma_req = 0;
+	DMA_NODE_TOT_CNT_S node_cnt;
+	DMA_SRC_DSCR_PTR_HIGH_S src_addr_h8 = {0};
+	DMA_SRC_DSCT_PTR_LOW_S src_addr_l32 = {0};
+	DMA_DST_DSCR_PTR_HIGH_S dst_addr_h8 = {0};
+	DMA_DST_DSCR_PTR_LOW_S dst_addr_l32 = {0};
+
+	if(ch_id >= MAX_EDMA_COUNT || !count)
+		return -EINVAL;
+	//skw_edma_lock();
+	if (ch_id < MAX_EDMA_COUNT) {
+		PCIE_DBG("ch_id:%d direction:%s,header=0x%llx count:%d\n",
+			ch_id, (dma_chp->chn_cfg.direction == EDMA_TX)?"EDMA_TX":"EDMA_RX",header, count);
+		edma_req |= (count << NODE_NUM_OFFSET);
+		edma_req |= EDMA_REQ;
+		node_cnt.u32 = skw_pcie_read32(DMA_NODE_TOT_CNT(ch_id));
+		if(dma_chp->chn_cfg.direction == EDMA_TX) {//ap is src
+			if(header) {
+				if (!node_cnt.src_tot_node_num) {
+					src_addr_l32.src_next_dscr_ptr_low = (u64)header & 0xffffffff;
+					skw_pcie_write32(DMA_SRC_DSCT_PTR_LOW(ch_id), src_addr_l32.u32);
+					src_addr_h8.src_next_dscr_ptr_high = ((u64)header>>32) & 0xff;
+					skw_pcie_write32(DMA_SRC_DSCR_PTR_HIGH(ch_id), src_addr_h8.u32);
+					PCIE_DBG("tx_reg_header=0x%x@@\n",
+						skw_pcie_read32(DMA_SRC_DSCT_PTR_LOW(ch_id)));
+				} else
+					return -EBUSY;
+			}
+			skw_pcie_write32(DMA_SRC_REQ(ch_id), edma_req);
+		} else {
+			if(header) {
+				if (!node_cnt.dst_tot_node_num) {
+					dst_addr_l32.dst_next_dscr_ptr_low = (u64)header & 0xffffffff;
+					skw_pcie_write32(DMA_DST_DSCR_PTR_LOW(ch_id), dst_addr_l32.u32);
+					dst_addr_h8.dst_next_dscr_ptr_high = ((u64)header>>32) & 0xff;
+					skw_pcie_write32(DMA_DST_DSCR_PTR_HIGH(ch_id), dst_addr_h8.u32);
+					PCIE_DBG("rx_reg_header=0x%x\n",
+						skw_pcie_read32(DMA_DST_DSCR_PTR_LOW(ch_id)));
+				} else
+					return -EBUSY;
+			}
+			skw_pcie_write32(DMA_DST_REQ(ch_id), edma_req);
+		}
+	}
+	//skw_edma_unlock();
+
+	return 0;
+}
+
+int edma_channel_init(int ch_id, void *channel_config, void *data)
+{
+	struct edma_chn_info *edma_chp = get_edma_channel_info(ch_id);
+	struct skw_channel_cfg *chn_cfg = (struct skw_channel_cfg *)channel_config;
+	DMA_SRC_NODE_S reg_src_chn_node_cfg = {0};
+	DMA_DST_NODE_S reg_dst_chn_node_cfg = {0};
+	DMA_SRC_INT_S reg_chn_int = {0};
+	DMA_CFG_S reg_chn_cfg = {0};
+	u32 reg_edma_len = 0;
+	DMA_SRC_DSCR_PTR_HIGH_S src_addr_h8 = {0};
+	DMA_SRC_DSCT_PTR_LOW_S src_addr_l32 = {0};
+	DMA_DST_DSCR_PTR_HIGH_S dst_addr_h8 = {0};
+	DMA_DST_DSCR_PTR_LOW_S dst_addr_l32 = {0};
+
+	edma_chp->chn_cfg.direction = chn_cfg->direction;
+	edma_chp->chn_cfg.priority = chn_cfg->priority;
+	edma_chp->chn_cfg.endian = chn_cfg->endian;
+	edma_chp->chn_cfg.node_count = chn_cfg->node_count;
+	edma_chp->chn_cfg.req_mode = chn_cfg->req_mode;
+	edma_chp->chn_cfg.timeout = chn_cfg->timeout;
+	edma_chp->chn_cfg.irq_threshold = chn_cfg->irq_threshold;
+	edma_chp->chn_cfg.header = chn_cfg->header;
+	edma_chp->chn_cfg.context = (void *)chn_cfg->context;
+	edma_chp->chn_cfg.complete_callback = chn_cfg->complete_callback;
+	edma_chp->chn_cfg.rx_callback = chn_cfg->rx_callback;
+	edma_chp->chn_cfg.empty_callback = chn_cfg->empty_callback;
+	edma_chp->chn_cfg.trsc_len = chn_cfg->trsc_len;
+	edma_chp->chn_cfg.split = chn_cfg->split;
+	edma_chp->chn_cfg.ring = chn_cfg->ring;
+	edma_chp->chn_cfg.opposite_node_done = chn_cfg->opposite_node_done;
+	edma_chp->chn_cfg.buf_cnt = chn_cfg->buf_cnt;
+	edma_chp->chn_cfg.buf_level = chn_cfg->buf_level;
+
+	PCIE_DBG("ch_id=%d\n", ch_id);
+	PCIE_DBG("@@########direction = %s@@\n", (edma_chp->chn_cfg.direction == EDMA_TX)?"EDMA_TX":"EDMA_RX");
+	PCIE_DBG("@@priority = 0x%x@@\n", edma_chp->chn_cfg.priority);
+	PCIE_DBG("@@endian = 0x%x@@\n", edma_chp->chn_cfg.endian);
+	PCIE_DBG("@@node_count = 0x%x@@\n", edma_chp->chn_cfg.node_count);
+	PCIE_DBG("@@req_mode = %s@@\n", (edma_chp->chn_cfg.req_mode == EDMA_STD_MODE)?"STD":"LINKLIST");
+	PCIE_DBG("@@header = 0x%llx@@\n", edma_chp->chn_cfg.header);
+	PCIE_DBG("@@split = 0x%x@@\n", edma_chp->chn_cfg.split);
+	PCIE_DBG("@@irq_threshold = 0x%x@@\n", edma_chp->chn_cfg.irq_threshold);
+
+	reg_chn_int.src_complete_int_en = 1;
+	reg_chn_int.src_cfg_err_int_en = 1;
+
+	if (edma_chp->chn_cfg.trsc_len != 0) {
+		reg_edma_len |= (edma_chp->chn_cfg.trsc_len << TRANS_LEN_OFFSET);
+	}
+
+	reg_chn_cfg.u32 = skw_pcie_read32(DMA_CFG(ch_id));
+	PCIE_DBG("1. [%d]:0x%08x\n", ch_id, reg_chn_cfg.u32);
+	//channel enable
+	skw_pcie_write32(DMA_CFG(ch_id)+0x10, BIT(0));
+
+	reg_chn_cfg.u32 = skw_pcie_read32(DMA_CFG(ch_id));
+	PCIE_DBG("2. [%d]:0x%08x\n", ch_id, reg_chn_cfg.u32);
+	reg_chn_cfg.endian_mode = edma_chp->chn_cfg.endian;
+	reg_chn_cfg.priority = edma_chp->chn_cfg.priority;
+
+	if (edma_chp->chn_cfg.req_mode == EDMA_STD_MODE) {
+		reg_chn_cfg.req_mode = 0;
+		skw_pcie_write32(DMA_CFG(ch_id)+0x20, BIT(13));
+		if (edma_chp->chn_cfg.direction == EDMA_TX) {//AP is src
+			reg_chn_cfg.dir = 0;
+			skw_pcie_write32(DMA_CFG(ch_id), reg_chn_cfg.u32);
+			skw_pcie_write32(DMA_SRC_INT(ch_id), reg_chn_int.u32);
+
+			src_addr_l32.src_next_dscr_ptr_low = edma_chp->chn_cfg.header & 0xffffffff;
+			skw_pcie_write32(DMA_SRC_DSCT_PTR_LOW(ch_id), src_addr_l32.u32);
+			src_addr_h8.src_next_dscr_ptr_high = ((edma_chp->chn_cfg.header)>>32) & 0xff;
+			skw_pcie_write32(DMA_SRC_DSCR_PTR_HIGH(ch_id), src_addr_h8.u32);
+		} else {//AP is dst
+			reg_chn_cfg.dir = 1;
+			skw_pcie_write32(DMA_CFG(ch_id), reg_chn_cfg.u32);
+			skw_pcie_write32(DMA_DST_INT(ch_id), reg_chn_int.u32);
+			dst_addr_l32.dst_next_dscr_ptr_low = edma_chp->chn_cfg.header & 0xffffffff;
+			skw_pcie_write32(DMA_DST_DSCR_PTR_LOW(ch_id), dst_addr_l32.u32);
+			dst_addr_h8.dst_next_dscr_ptr_high = ((edma_chp->chn_cfg.header)>>32) & 0xff;
+			skw_pcie_write32(DMA_DST_DSCR_PTR_HIGH(ch_id), dst_addr_h8.u32);
+		}
+		//trans len
+		skw_pcie_write32(DMA_LEN_CFG(ch_id), reg_edma_len);
+	} else if (edma_chp->chn_cfg.req_mode == EDMA_LINKLIST_MODE) {
+		reg_chn_cfg.req_mode = 1;
+		skw_pcie_write32(DMA_CFG(ch_id)+0x10, BIT(13));
+
+		if (edma_chp->chn_cfg.empty_callback)
+			reg_chn_int.src_list_empty_int_en = 1;
+
+		if (edma_chp->chn_cfg.direction == EDMA_TX) {//AP is src
+			reg_chn_cfg.dir = 0;
+			reg_chn_int.src_cmplt_en_wi_dst_node_done = edma_chp->chn_cfg.opposite_node_done;
+			reg_src_chn_node_cfg.u32 = skw_pcie_read32(DMA_SRC_NODE(ch_id));
+			reg_src_chn_node_cfg.src_data_split_en = edma_chp->chn_cfg.split;
+			reg_src_chn_node_cfg.src_ring_buf_en = edma_chp->chn_cfg.ring;
+			if (edma_chp->chn_cfg.irq_threshold != 0) {
+				reg_src_chn_node_cfg.node_num_thr_en = 1;
+				reg_src_chn_node_cfg.node_num_thr = edma_chp->chn_cfg.irq_threshold;
+			} else
+				reg_src_chn_node_cfg.node_num_thr_en = 0;
+			skw_pcie_write32(DMA_CFG(ch_id), reg_chn_cfg.u32);
+			skw_pcie_write32(DMA_SRC_INT(ch_id), reg_chn_int.u32);
+			skw_pcie_write32(DMA_SRC_NODE(ch_id), reg_src_chn_node_cfg.u32);
+
+			src_addr_l32.src_next_dscr_ptr_low = edma_chp->chn_cfg.header & 0xffffffff;
+			skw_pcie_write32(DMA_SRC_DSCT_PTR_LOW(ch_id), src_addr_l32.u32);
+			src_addr_h8.src_next_dscr_ptr_high = ((edma_chp->chn_cfg.header)>>32) & 0xff;
+			skw_pcie_write32(DMA_SRC_DSCR_PTR_HIGH(ch_id), src_addr_h8.u32);
+
+		} else {//AP is dst
+			reg_chn_cfg.dir = 1;
+			reg_chn_int.src_cmplt_en_wi_dst_node_done = edma_chp->chn_cfg.opposite_node_done;
+			reg_dst_chn_node_cfg.u32 = skw_pcie_read32(DMA_DST_NODE(ch_id));
+			reg_dst_chn_node_cfg.dst_data_split_en = 1;
+			reg_dst_chn_node_cfg.dst_ring_buf_en = edma_chp->chn_cfg.ring;
+			if (edma_chp->chn_cfg.irq_threshold != 0) {
+				reg_dst_chn_node_cfg.dst_node_num_thr_en = 1;
+				reg_dst_chn_node_cfg.dst_node_num_thr = edma_chp->chn_cfg.irq_threshold;
+			} else
+				reg_dst_chn_node_cfg.dst_node_num_thr_en = 0;
+			skw_pcie_write32(DMA_CFG(ch_id), reg_chn_cfg.u32);
+			skw_pcie_write32(DMA_DST_INT(ch_id), reg_chn_int.u32);
+			skw_pcie_write32(DMA_DST_NODE(ch_id), reg_dst_chn_node_cfg.u32);
+
+			dst_addr_l32.dst_next_dscr_ptr_low = edma_chp->chn_cfg.header & 0xffffffff;
+			skw_pcie_write32(DMA_DST_DSCR_PTR_LOW(ch_id), dst_addr_l32.u32);
+			dst_addr_h8.dst_next_dscr_ptr_high = ((edma_chp->chn_cfg.header)>>32) & 0xff;
+			skw_pcie_write32(DMA_DST_DSCR_PTR_HIGH(ch_id), dst_addr_h8.u32);
+
+		}
+	}
+
+
+	return 0;
+}
+
+static int close_edma_channel(int ch_id)
+{
+	struct edma_chn_info *dma_chp = get_edma_channel_info(ch_id);
+	DMA_SRC_NODE_S reg_chn_node_cfg = {0};
+	DMA_SRC_INT_S reg_chn_int = {0};
+
+	if(ch_id >= MAX_EDMA_COUNT)
+		return -1;
+
+	PCIE_INFO("ch_id:%d\n", ch_id);
+	dma_chp->chn_cfg.complete_callback = NULL;
+	dma_chp->chn_cfg.empty_callback = NULL;
+	dma_chp->chn_cfg.irq_threshold = 0;
+	reg_chn_int.src_complete_int_en = 0;
+	reg_chn_int.src_cfg_err_int_en = 0;
+	reg_chn_int.src_list_empty_int_en = 0;
+	reg_chn_node_cfg.node_num_thr_en = 0;
+
+	if(dma_chp->chn_cfg.direction == EDMA_TX) {
+		skw_pcie_write32(DMA_SRC_INT(ch_id), reg_chn_int.u32);
+		skw_pcie_write32(DMA_SRC_NODE(ch_id), reg_chn_node_cfg.u32);
+	} else {
+		skw_pcie_write32(DMA_DST_INT(ch_id), reg_chn_int.u32);
+		skw_pcie_write32(DMA_DST_NODE(ch_id), reg_chn_node_cfg.u32);
+	}
+	//channel close
+	skw_pcie_write32(DMA_CFG(ch_id)+0x20, BIT(0));
+
+	return 0;
+}
+
+int edma_adma_send(int ch_id, struct scatterlist *sg, int node_cnt, int size)
+{
+	struct edma_chn_info *edma_chp = get_edma_channel_info(ch_id);
+	u32 edma_req = 0;
+
+	if(ch_id >= MAX_EDMA_COUNT)
+		return -EINVAL;
+
+	//skw_edma_lock();
+	PCIE_DBG("req_mod=%d, ch_id=%d\n", edma_chp->chn_cfg.req_mode, ch_id);
+	if (edma_chp->chn_cfg.req_mode == EDMA_STD_MODE) {
+		edma_req |= EDMA_REQ;
+		if (edma_chp->chn_cfg.direction == EDMA_TX)
+			skw_pcie_write32(DMA_SRC_REQ(ch_id), edma_req);
+		else
+			skw_pcie_write32(DMA_DST_REQ(ch_id), edma_req);
+
+	} else if (edma_chp->chn_cfg.req_mode == EDMA_LINKLIST_MODE) {
+		edma_req |= (node_cnt << NODE_NUM_OFFSET);
+		edma_req |= EDMA_REQ;
+		if (edma_chp->chn_cfg.direction == EDMA_TX) {
+			skw_pcie_write32(DMA_SRC_REQ(ch_id), edma_req);
+		} else {
+			skw_pcie_write32(DMA_DST_REQ(ch_id), edma_req);
+		}
+	}
+	//skw_edma_unlock();
+	return 0;
+}
+
+static int edma_port_read(struct edma_port *port, char *buffer, int size)
+{
+	struct wcn_pcie_info *priv= get_pcie_device_info();
+	struct device *dev = &(priv->dev->dev);
+	struct edma_chn_info *edma_chp;
+	EDMA_HDR_T *nodep = port->rx_node;
+	u8 ch_id = port->rx_ch;
+	int ret;
+	//mutex_lock(&port->rx_mutex);
+	PCIE_DBG("[+], portno=%d, port_state=%d, ch_id=%d\n",
+			port->portno,
+			port->state,
+			ch_id);
+	//if (port->portno == EDMA_LOOPCHECK_PORT)
+	//	print_hex_dump(KERN_ERR, "1. loopcheck:", 0, 16, 1, buffer, 32, 1);
+	edma_chp = get_edma_channel_info(ch_id);
+
+	edma_chp->n_pld_sz = size;
+
+	if (port->portno != EDMA_AT_PORT)
+		nodep->data_addr = edma_virtaddr_to_pcieaddr(buffer);
+	else
+		nodep->data_addr = edma_virtaddr_to_pcieaddr(at_buffer);
+	//map payload
+	if (port->portno != EDMA_AT_PORT)
+		edma_chp->map_pld_addr = dma_map_single(dev, buffer, edma_chp->n_pld_sz, DMA_FROM_DEVICE);
+	else
+		edma_chp->map_pld_addr = dma_map_single(dev, at_buffer, edma_chp->n_pld_sz, DMA_FROM_DEVICE);
+	if (dma_mapping_error(dev, edma_chp->map_pld_addr)) {
+			PCIE_ERR("dma_mapping_error\n");
+			BUG_ON(1);
+			return -1;
+	}
+	reinit_completion(&port->rx_done);
+
+	if (port->portno == EDMA_AT_PORT) {
+		if (at_buffer[0] == 0x0) {
+			edma_adma_send(ch_id, NULL, 1, 0);
+		}
+	} else
+		edma_adma_send(ch_id, NULL, 1, 0);
+
+	if (port->rx_submit) {
+		port->rx_submit(port->portno, NULL, 0, nodep);
+	}
+
+	if (!((port->portno == EDMA_AT_PORT) && (at_buffer[0] != 0))) {
+		ret = wait_for_completion_interruptible(&port->rx_done);
+		if(ret < 0)
+			return -ETIMEDOUT;
+		if(port->state == PORT_STATE_CLSE) {
+			port->state = PORT_STATE_IDLE;
+			return -EAGAIN;
+		}else if(port->state == PORT_STATE_ASST) {
+			PCIE_ERR("The CP assert  portno =%d error code =%d!!!!\n", port->portno, ENOTCONN);
+			if(priv->cp_state != 0){
+				if(port->portno == EDMA_LOG_PORT)
+					port->state = PORT_STATE_OPEN;
+				return -ENOTCONN;
+			}
+		}
+	}
+
+	if (port->portno == EDMA_AT_PORT) {
+		memcpy(buffer, at_buffer, 256);
+		memset(at_buffer, 0, 256);
+	}
+
+	if (port->portno == EDMA_LOOPCHECK_PORT)
+		print_hex_dump(KERN_ERR, "loopcheck:", 0, 16, 1, buffer, 32, 1);
+
+	if(port->state == PORT_STATE_CLSE) {
+		port->state = PORT_STATE_IDLE;
+		return -EAGAIN;
+	}
+
+	PCIE_DBG("[-], portno=%d, port_state=%d, ch_id=%d\n",
+		port->portno,
+		port->state,
+		ch_id);
+	//mutex_unlock(&port->rx_mutex);
+	return nodep->data_len;
+}
+
+static int edma_port_write(struct edma_port *port, char *buffer, int size)
+{
+	struct wcn_pcie_info *priv= get_pcie_device_info();
+	struct device *dev = &(priv->dev->dev);
+	struct edma_chn_info *edma_chp;
+	EDMA_HDR_T *nodep = port->tx_node;
+	u8 ch_id = port->tx_ch;
+	int ret;
+
+	PCIE_DBG("[+]\n");
+	edma_chp = get_edma_channel_info(ch_id);
+
+	edma_chp->n_pld_sz = size;
+
+	nodep->data_addr = edma_virtaddr_to_pcieaddr(buffer);
+
+	if (port->portno == EDMA_LOG_PORT)
+		dump_stack();
+
+	nodep->data_addr = edma_virtaddr_to_pcieaddr(buffer);
+	nodep->data_len = size;
+
+	//print_hex_dump(KERN_ERR, "plt:", 0, 16, 1, buffer, 64, 1);
+	PCIE_DBG("portno=%d, port_state=%d, ch_id=%d\n",
+			port->portno,
+			port->state,
+			ch_id);
+
+	//map payload
+	edma_chp->map_pld_addr = dma_map_single(dev, buffer, edma_chp->n_pld_sz, DMA_TO_DEVICE);
+	if (dma_mapping_error(dev, edma_chp->map_pld_addr)) {
+			BUG_ON(1);
+			return -1;
+	}
+	reinit_completion(&port->tx_done);
+	edma_adma_send(ch_id, NULL, 1, 0);
+
+
+	ret = wait_for_completion_interruptible(&port->tx_done);
+	if(ret < 0)
+		return -ETIMEDOUT;
+	if(port->state == PORT_STATE_CLSE) {
+		port->state = PORT_STATE_IDLE;
+		return -EAGAIN;
+	}
+	PCIE_DBG("[-]\n");
+	return nodep->data_len;
+}
+
+
+int recv_data(int portno, char *buffer, int size)
+{
+	struct edma_port *port;
+	char *data = buffer;
+	int read;
+
+	if (portno == EDMA_LOOPCHECK_PORT)
+		PCIE_DBG("[+] portno=%d!! \n",portno);
+	if(size==0)
+		return 0;
+	if(portno >= MAX_PORT_NUM)
+		return -EINVAL;
+	port = &edma_ports[portno];
+	if(!port->state)
+		return -EIO;
+	read = edma_port_read(port, data, size);
+	if (portno == EDMA_LOOPCHECK_PORT)
+		PCIE_DBG("[-] portno=%d!! \n",portno);
+	return read;
+}
+
+int send_data(int portno, char *buffer, int size)
+{
+	struct edma_port *port = get_edma_port_info(portno);
+
+	PCIE_DBG("[+]\n");
+	PCIE_DBG("size:%d portno:%d port->state:%d\n", size, portno, port->state);
+	if(size==0)
+		return 0;
+	if(portno >= MAX_PORT_NUM)
+		return -EINVAL;
+	if(!port->state)
+		return -EIO;
+
+	return edma_port_write(port, buffer, size);
+}
+
+static void *edma_malloc_node(u8 ch, u8 count)
+{
+	struct wcn_pcie_info *priv= get_pcie_device_info();
+	struct device *dev = &(priv->dev->dev);
+	struct edma_chn_info *edma_chp = get_edma_channel_info(ch);
+	EDMA_HDR_T *nodep;
+
+	if (!dev) {
+		PCIE_ERR("(NULL)\n");
+		return NULL;
+	}
+
+	if (dma_set_mask(dev, DMA_BIT_MASK(64))) {
+		PCIE_ERR("dma_set_mask err\n");
+		if (dma_set_coherent_mask(dev, DMA_BIT_MASK(64))) {
+			PCIE_ERR("dma_set_coherent_mask err\n");
+			return NULL;
+		}
+	}
+
+	edma_chp->p_link_hdr = (EDMA_HDR_T *)dma_alloc_coherent(dev, PAGE_ALIGN(count * sizeof(EDMA_HDR_T)),
+					(dma_addr_t *)(&(edma_chp->dma_hdr_handle)), GFP_DMA);
+	if (!edma_chp->p_link_hdr) {
+		PCIE_ERR("alloc mem fail\n");
+		return NULL;
+	}
+
+#if 0
+	/* build ring linklist */
+	for (i = 0;i < count;i++) {
+			edma_chp->p_link_hdr[i].next_hdr =
+				edma_phyaddr_to_pcieaddr(edma_chp->dma_hdr_handle + ((i + 1) % count) * sizeof(EDMA_HDR_T) + 8);
+	}
+#endif
+	nodep = (EDMA_HDR_T *)edma_chp->p_link_hdr;
+
+	return nodep;
+}
+
+static int port_rx_int_cb(void *context, u64 head, u64 tail, int count)
+{
+	struct edma_chn_info *edma_chp = context;
+	struct wcn_pcie_info *priv= get_pcie_device_info();
+	struct device *dev = &(priv->dev->dev);
+	u8 ch = edma_chp->chn_id;
+	u8 portno = EDMACH2PORTNO(ch);
+	struct edma_port *port = &edma_ports[portno];
+	u64 tmp;
+
+	edma_chp = get_edma_channel_info(ch);
+	edma_chp->rcv_tail_cpu_addr = edma_coherent_rcvheader_to_cpuaddr((u64)tail, edma_chp);
+	edma_chp->rcv_header_cpu_addr = edma_coherent_rcvheader_to_cpuaddr((u64)head, edma_chp);
+	while(!(((EDMA_HDR_T *)((char *)edma_chp->rcv_tail_cpu_addr-8))->done)){
+		mdelay(1);
+		barrier();
+		PCIE_DBG("wait for ch_id:%d node done flag...\n", ch);
+	}
+
+	((EDMA_HDR_T *)((char *)edma_chp->rcv_header_cpu_addr-8))->done = 0;
+
+	tmp = edma_pcieaddr_to_phyaddr(((EDMA_HDR_T *)((char *)edma_chp->rcv_tail_cpu_addr-8))->data_addr);
+	dma_unmap_single(dev, tmp, edma_chp->n_pld_sz, DMA_FROM_DEVICE);
+
+	complete(&port->rx_done);
+#ifdef CONFIG_BT_SEEKWAVE
+	if (portno == EDMA_BTCMD_PORT || portno == EDMA_BTACL_PORT ||
+		portno == EDMA_BTAUDIO_PORT || portno == EDMA_ISOC_PORT) {
+			port->state = PORT_STATE_BUSY;
+			port->rx_size = ((EDMA_HDR_T *)((char *)edma_chp->rcv_header_cpu_addr-8))->data_len;
+			port->rx_buf_addr = bt_rx_buffer[portno];
+			if(port->rx_submit)
+				schedule_work(&priv->bt_rx_work);
+	}
+#endif
+
+	return 0;
+}
+
+static int port_tx_int_cb(void *context, u64 head, u64 tail, int count)
+{
+	struct edma_chn_info *edma_chp = context;
+	struct wcn_pcie_info *priv= get_pcie_device_info();
+	u8 ch = edma_chp->chn_id;
+	struct device *dev = &(priv->dev->dev);
+	u8 portno = EDMACH2PORTNO(ch);
+	struct edma_port *port = &edma_ports[portno];
+	u64 tmp;
+
+	edma_chp->rcv_tail_cpu_addr = edma_coherent_rcvheader_to_cpuaddr((u64)tail, edma_chp);
+	tmp = edma_pcieaddr_to_phyaddr(((EDMA_HDR_T *)((char *)edma_chp->rcv_tail_cpu_addr-8))->data_addr);
+	dma_unmap_single(dev, tmp, edma_chp->n_pld_sz, DMA_TO_DEVICE);
+	complete(&port->tx_done);
+
+	return 0;
+}
+
+
+int open_edma_port(int portno, void *callback, void *data)
+{
+	struct edma_port *port;
+	EDMA_HDR_T *nodep;
+	struct skw_channel_cfg chn_cfg_rx = {0}, chn_cfg_tx = {0};
+	struct edma_chn_info *rx_edma_chp;
+	struct edma_chn_info *tx_edma_chp;
+
+	if(portno >= MAX_PORT_NUM)
+		return -EINVAL;
+	PCIE_DBG("[+]\n");
+	port = &edma_ports[portno];
+	port->rx_ch = PORT_TO_EDMA_RX_CHANNEL(portno);
+	port->tx_ch = PORT_TO_EDMA_TX_CHANNEL(portno);
+	rx_edma_chp = get_edma_channel_info(port->rx_ch);
+	tx_edma_chp = get_edma_channel_info(port->tx_ch);
+
+	if((port->state==PORT_STATE_OPEN) || port->rx_submit)
+		return -EBUSY;
+	port->rx_submit = callback;
+	port->rx_data = data;
+	port->rx_wp = port->rx_rp = 0;
+	port->portno = portno;
+	init_completion(&port->rx_done);
+	init_completion(&port->tx_done);
+	mutex_init(&port->rx_mutex);
+	port->state = PORT_STATE_OPEN;
+
+	chn_cfg_rx.direction = EDMA_RX;
+	nodep = edma_malloc_node(port->rx_ch, 1);
+	if(nodep) {
+		nodep->next_hdr = edma_phyaddr_to_pcieaddr(rx_edma_chp->dma_hdr_handle) + 8;
+		chn_cfg_rx.complete_callback = port_rx_int_cb;
+		chn_cfg_rx.empty_callback = NULL;
+		chn_cfg_rx.header = nodep->next_hdr;
+		chn_cfg_rx.split = 1;
+		chn_cfg_rx.node_count = 1;
+		chn_cfg_rx.req_mode = EDMA_LINKLIST_MODE;
+		chn_cfg_rx.context = get_edma_channel_info(port->rx_ch);
+		edma_channel_init(port->rx_ch, &chn_cfg_rx, NULL);
+		port->rx_node = nodep;
+	} else
+		return -EINVAL;
+
+	chn_cfg_tx.direction = EDMA_TX;
+	chn_cfg_tx.split = 1;
+	nodep = edma_malloc_node(port->tx_ch, 1);
+	if(nodep) {
+		nodep->next_hdr = edma_phyaddr_to_pcieaddr(tx_edma_chp->dma_hdr_handle) + 8;
+		chn_cfg_tx.complete_callback = port_tx_int_cb;
+		chn_cfg_tx.empty_callback = NULL;
+		chn_cfg_tx.header = nodep->next_hdr;
+		chn_cfg_tx.split = 1;
+		chn_cfg_tx.node_count = 1;
+		chn_cfg_tx.req_mode = EDMA_LINKLIST_MODE;
+		chn_cfg_tx.context = get_edma_channel_info(port->tx_ch);
+		edma_channel_init(port->tx_ch, &chn_cfg_tx, NULL);
+		port->tx_node = nodep;
+	} else
+		return -EINVAL;
+#ifdef CONFIG_BT_SEEKWAVE
+	if (portno == EDMA_BTCMD_PORT || portno == EDMA_BTACL_PORT ||
+		portno == EDMA_BTAUDIO_PORT || portno == EDMA_ISOC_PORT) {
+		if (bt_rx_prepare(portno))
+			return -1;
+		}
+#endif
+	port_sta_rec[portno] = 1;
+	PCIE_DBG("[-], portno=%d, port_state=%d\n",
+				portno,
+				port->state);
+	return 0;
+}
+
+int close_edma_port(int portno)
+{
+	struct edma_port *port = &edma_ports[portno];
+	struct wcn_pcie_info *priv= get_pcie_device_info();
+	struct device *dev = &(priv->dev->dev);
+	struct edma_chn_info *edma_chp;
+	u32 val;
+#ifdef CONFIG_BT_SEEKWAVE
+	int i;
+#endif
+
+	if(portno == EDMA_LOG_PORT){
+		skw_pcie_cp_log(1);
+		mdelay(100);
+	}
+
+	PCIE_INFO("[+]close port[%d]\n", portno);
+	mutex_lock(&port->rx_mutex);
+	if (port_sta_rec[portno] == 0) {
+		PCIE_INFO("[-]port[%d] no open, exit\n", portno);
+		mutex_unlock(&port->rx_mutex);
+		return 0;
+	}
+#if 1 //XXX: for debug
+	val = skw_pcie_read32(DMA_SRC_INT(port->tx_ch));
+	if (val & BIT(8)) {
+		PCIE_INFO("1.port->tx_ch=%d, edma_src_int=0x%08x\n", port->tx_ch, val);
+		mdelay(10);
+		val = skw_pcie_read32(DMA_SRC_INT(port->tx_ch));
+		PCIE_INFO("2.port->tx_ch=%d, edma_src_int=0x%08x\n", port->tx_ch, val);
+		mdelay(10);
+		val = skw_pcie_read32(DMA_SRC_INT(port->tx_ch));
+		PCIE_INFO("3.port->tx_ch=%d, edma_src_int=0x%08x\n", port->tx_ch, val);
+		send_modem_assert_command();
+		BUG_ON(1);
+	}
+	val = skw_pcie_read32(DMA_DST_INT(port->rx_ch));
+	if (val & BIT(8)) {
+		PCIE_INFO("1.port->rx_ch=%d, edma_dst_int=0x%08x\n", port->rx_ch, val);
+		mdelay(10);
+		val = skw_pcie_read32(DMA_DST_INT(port->rx_ch));
+		PCIE_INFO("2.port->rx_ch=%d, edma_dst_int=0x%08x\n", port->rx_ch, val);
+		mdelay(10);
+		val = skw_pcie_read32(DMA_DST_INT(port->rx_ch));
+		PCIE_INFO("3.port->rx_ch=%d, edma_dst_int=0x%08x\n", port->rx_ch, val);
+		send_modem_assert_command();
+		BUG_ON(1);
+	}
+#endif
+	close_edma_channel(port->tx_ch);
+	edma_chp = get_edma_channel_info(port->tx_ch);
+	dma_free_coherent(dev, PAGE_ALIGN(1 * sizeof(EDMA_HDR_T)),
+			edma_chp->p_link_hdr, edma_chp->dma_hdr_handle);
+	close_edma_channel(port->rx_ch);
+	edma_chp = get_edma_channel_info(port->rx_ch);
+	dma_free_coherent(dev, PAGE_ALIGN(1 * sizeof(EDMA_HDR_T)),
+			edma_chp->p_link_hdr, edma_chp->dma_hdr_handle);
+#ifdef CONFIG_BT_SEEKWAVE
+for (i = 0;i < 4;i++)
+		kfree(bt_rx_buffer[i]);
+#endif
+	//while(!rx_done_reset);
+	//complete(&port->rx_done);
+	port->state = PORT_STATE_CLSE;
+	port->tx_line = NULL;
+	port->rx_line = NULL;
+	port->tx_index = 0;
+	port->rx_wp = port->rx_rp = 0;
+	port->rx_submit = NULL;
+	complete(&port->rx_done);
+	complete(&port->tx_done);
+	//memset(port, 0, sizeof(struct edma_port));
+	port_sta_rec[portno] = 0;
+	PCIE_INFO("[-]port[%d] closed\n", portno);
+	mutex_unlock(&port->rx_mutex);
+	return 0;
+}
+
+static int wifi_service_start(void)
+{
+	int ret =0;
+	struct wcn_pcie_info *priv= get_pcie_device_info();
+	if(priv->boot_data==NULL)
+		return ret;
+
+	ret=priv->boot_data->wifi_start();
+	return ret;
+}
+
+static int wifi_service_stop(void)
+{
+	int ret =0;
+	struct wcn_pcie_info *priv= get_pcie_device_info();
+	if(priv->boot_data ==NULL|| priv->cp_state)
+		return ret;
+
+	ret=priv->boot_data->wifi_stop();
+	return ret;
+}
+
+static int bt_service_start(void)
+{
+	int ret =0;
+	struct wcn_pcie_info *priv= get_pcie_device_info();
+	if(priv->boot_data==NULL)
+		return ret;
+
+	ret=priv->boot_data->bt_start();
+	return ret;
+}
+
+static int bt_service_stop(void)
+{
+	int ret =0;
+	struct wcn_pcie_info *priv= get_pcie_device_info();
+	if(priv->boot_data ==NULL|| priv->cp_state)
+		return ret;
+
+	ret=priv->boot_data->bt_stop();
+	return ret;
+}
+
+void edma_unmask_channel(int channel)
+{
+	DMA_DST_INT_S reg_chn_dst_int = {0};
+	DMA_SRC_INT_S reg_chn_src_int = {0};
+
+	if (channel == EDMA_WIFI_TX0_FREE_ADDR || channel == EDMA_WIFI_TX1_FREE_ADDR
+		|| channel == EDMA_WIFI_RX0_PKT_ADDR || channel == EDMA_WIFI_RX1_PKT_ADDR
+		|| channel == EDMA_WIFI_RX0_FILTER_DATA_CHN || channel == EDMA_WIFI_RX1_FILTER_DATA_CNH) {
+
+		reg_chn_dst_int.u32 = skw_pcie_read32(DMA_DST_INT(channel));
+		reg_chn_dst_int.dst_complete_int_en = 1;
+		reg_chn_dst_int.dst_cfg_err_int_en = 1;
+		reg_chn_dst_int.dst_list_empty_int_en = 0;
+
+		skw_pcie_write32(DMA_DST_INT(channel), reg_chn_dst_int.u32);
+	} else if (channel == EDMA_WIFI_TX0_PACKET_ADDR || channel == EDMA_WIFI_TX1_PACKET_ADDR) {
+		reg_chn_src_int.u32 = skw_pcie_read32(DMA_SRC_INT(channel));
+		reg_chn_src_int.src_complete_int_en = 1;
+		reg_chn_src_int.src_cfg_err_int_en = 1;
+		reg_chn_src_int.src_list_empty_int_en = 0;
+
+		skw_pcie_write32(DMA_SRC_INT(channel), reg_chn_src_int.u32);
+	}
+}
+
+void edma_mask_channel(int channel)
+{
+	DMA_DST_INT_S reg_chn_dst_int = {0};
+	DMA_SRC_INT_S reg_chn_src_int = {0};
+
+	if (channel == EDMA_WIFI_TX0_FREE_ADDR || channel == EDMA_WIFI_TX1_FREE_ADDR
+		|| channel == EDMA_WIFI_RX0_PKT_ADDR || channel == EDMA_WIFI_RX1_PKT_ADDR
+		|| channel == EDMA_WIFI_RX0_FILTER_DATA_CHN || channel == EDMA_WIFI_RX1_FILTER_DATA_CNH) {
+
+		reg_chn_dst_int.u32 = skw_pcie_read32(DMA_DST_INT(channel));
+		reg_chn_dst_int.dst_complete_int_en = 0;
+		reg_chn_dst_int.dst_cfg_err_int_en = 0;
+		reg_chn_dst_int.dst_list_empty_int_en = 0;
+
+		skw_pcie_write32(DMA_DST_INT(channel), reg_chn_dst_int.u32);
+	} else if (channel == EDMA_WIFI_TX0_PACKET_ADDR || channel == EDMA_WIFI_TX1_PACKET_ADDR) {
+		reg_chn_src_int.u32 = skw_pcie_read32(DMA_SRC_INT(channel));
+		reg_chn_src_int.src_complete_int_en = 0;
+		reg_chn_src_int.src_cfg_err_int_en = 0;
+		reg_chn_src_int.src_list_empty_int_en = 0;
+
+		skw_pcie_write32(DMA_SRC_INT(channel), reg_chn_src_int.u32);
+	}
+}
+
+int msi_irq_wifi_takeover_handler(int irq_num)
+{
+	struct edma_chn_info *edma_chp;
+	struct wcn_pcie_info *priv = get_pcie_device_info();
+	int ch_id;
+	unsigned long flags;
+	DMA_DST_INT_S reg_chn_dst_int = {0};
+
+	spin_lock_irqsave(priv->spin_lock, flags);
+
+	if (priv->msix_en == 1)
+		ch_id = irq_num/2;
+	else
+		ch_id = irq_num;
+
+	edma_chp = get_edma_channel_info(ch_id);
+	if (ch_id == EDMA_WIFI_TX0_FREE_ADDR || ch_id == EDMA_WIFI_TX1_FREE_ADDR
+		|| ch_id == EDMA_WIFI_RX0_PKT_ADDR || ch_id == EDMA_WIFI_RX1_PKT_ADDR
+		|| ch_id == EDMA_WIFI_RX0_FILTER_DATA_CHN || ch_id == EDMA_WIFI_RX1_FILTER_DATA_CNH) {
+
+		reg_chn_dst_int.u32 = skw_pcie_read32(DMA_DST_INT(ch_id));
+		reg_chn_dst_int.dst_complete_int_clr = 1;
+		reg_chn_dst_int.dst_complete_int_en = 0;
+		skw_pcie_write32(DMA_DST_INT(ch_id), reg_chn_dst_int.u32);
+		skw_pcie_read32(DMA_DST_INT_DSCR_HIGH(ch_id));
+	}
+
+	if(edma_chp->chn_cfg.complete_callback)
+		edma_chp->chn_cfg.complete_callback(edma_chp->chn_cfg.context, 0, 0, 0);
+
+	spin_unlock_irqrestore(priv->spin_lock, flags);
+
+	return 0;
+}
+
+int legacy_irq_wifi_takeover_handler(int ch_id)
+{
+	struct edma_chn_info *edma_chp;
+	DMA_DST_INT_S reg_chn_dst_int = {0};
+
+	edma_chp = get_edma_channel_info(ch_id);
+
+	if (ch_id == EDMA_WIFI_TX0_FREE_ADDR || ch_id == EDMA_WIFI_TX1_FREE_ADDR
+		|| ch_id == EDMA_WIFI_RX0_PKT_ADDR || ch_id == EDMA_WIFI_RX1_PKT_ADDR
+		|| ch_id == EDMA_WIFI_RX0_FILTER_DATA_CHN || ch_id == EDMA_WIFI_RX1_FILTER_DATA_CNH) {
+
+		reg_chn_dst_int.u32 = skw_pcie_read32(DMA_DST_INT(ch_id));
+		reg_chn_dst_int.dst_complete_int_clr = 1;
+		reg_chn_dst_int.dst_complete_int_en = 0;
+		skw_pcie_write32(DMA_DST_INT(ch_id), reg_chn_dst_int.u32);
+		skw_pcie_read32(DMA_DST_INT_DSCR_HIGH(ch_id));
+	}
+
+	if(edma_chp->chn_cfg.complete_callback)
+		edma_chp->chn_cfg.complete_callback(edma_chp->chn_cfg.context, 0, 0, 0);
+
+	return 0;
+}
+
+struct sv6160_platform_data wifi_pdata = {
+	.cmd_port =  14,
+	.data_port =  19,
+	.bus_type = PCIE_LINK|TX_ADMA|RX_ADMA,
+	.max_buffer_size = 0xFFFF,
+	.align_value = 4,
+	.hw_channel_init = edma_channel_init,
+	.hw_channel_deinit = close_edma_channel,
+	.hw_adma_tx = edma_adma_send,
+	.modem_assert = send_modem_assert_command,
+	.service_start = wifi_service_start,
+	.service_stop = wifi_service_stop,
+	.phyaddr_to_pcieaddr = edma_phyaddr_to_pcieaddr,
+	.pcieaddr_to_phyaddr = edma_pcieaddr_to_phyaddr,
+	.virtaddr_to_pcieaddr = edma_virtaddr_to_pcieaddr,
+	.pcieaddr_to_virtaddr = edma_pcieaddr_to_virtaddr,
+	.submit_list_to_edma_channel = submit_list_to_edma_channel,
+	.wifi_channel_map = 0x7FF,
+	.edma_mask_irq = edma_mask_channel,
+	.edma_unmask_irq = edma_unmask_channel,
+	.modem_register_notify = modem_register_notify,
+	.modem_unregister_notify = modem_unregister_notify,
+	.at_ops = {
+		  .port =EDMA_AT_PORT,
+		  .open = open_edma_port,
+		  .close = close_edma_port,
+		  .read = recv_data,
+		  .write = send_data,
+	},
+	.edma_get_node_tot_cnt = edma_get_node_tot_cnt,
+	.edma_clear_src_node_count = edma_clear_src_node_count,
+};
+
+struct sv6160_platform_data ucom_pdata = {
+	.data_port =  EDMA_BTACL_PORT,
+	.cmd_port =  EDMA_BTCMD_PORT,
+	.audio_port =  EDMA_BTAUDIO_PORT,
+	.bus_type = PCIE_LINK|TX_ADMA|RX_ADMA,
+	.max_buffer_size = 0x800,
+	.align_value = 4,
+	.hw_sdma_rx = recv_data,
+	.hw_sdma_tx = send_data,
+	.open_port = open_edma_port,
+	.close_port = close_edma_port,
+	.modem_assert = send_modem_assert_command,
+	.modem_register_notify = modem_register_notify,
+	.modem_unregister_notify = modem_unregister_notify,
+	.service_start = bt_service_start,
+	.service_stop = bt_service_stop,
+};
+
+#ifdef CONFIG_BT_SEEKWAVE
+void bt_rx_work(struct work_struct *work)
+{
+	int ch_id, i;
+	struct edma_port *port;
+	struct edma_chn_info *edma_chp;
+	struct wcn_pcie_info *priv = get_pcie_device_info();
+	struct device *dev = &(priv->dev->dev);
+
+	for (i = 0;i < 4;i++) {
+		port = get_edma_port_info(i);
+		ch_id = port->rx_ch;
+		edma_chp = get_edma_channel_info(ch_id);
+		PCIE_DBG("portno:%d,port->state:%d\n", i, port->state);
+		if (port->state == PORT_STATE_BUSY) {
+			port->rx_submit(i, port->rx_data, port->rx_size, (void *)port->rx_buf_addr);
+			//map payload
+			edma_chp->map_pld_addr = dma_map_single(dev, bt_rx_buffer[i], edma_chp->n_pld_sz, DMA_FROM_DEVICE);
+			if (dma_mapping_error(dev, edma_chp->map_pld_addr)) {
+				PCIE_ERR("dma_mapping_error, portno:%d\n", i);
+				BUG_ON(1);
+			}
+			port->state = PORT_STATE_OPEN;
+			edma_adma_send(ch_id, NULL, 1, 0);
+		}
+	}
+}
+
+int bt_rx_prepare(int portno)
+{
+	struct edma_port *port;
+	struct edma_chn_info *edma_chp;
+	EDMA_HDR_T *nodep;
+	u8 ch_id;
+	struct wcn_pcie_info *priv = get_pcie_device_info();
+	struct device *dev = &(priv->dev->dev);
+
+	port = get_edma_port_info(portno);
+	ch_id = port->rx_ch;
+	edma_chp = get_edma_channel_info(ch_id);
+	nodep = port->rx_node;
+	edma_chp->n_pld_sz = ucom_pdata.max_buffer_size;
+	bt_rx_buffer[portno] = kzalloc(edma_chp->n_pld_sz, GFP_DMA);
+	nodep->data_addr = edma_virtaddr_to_pcieaddr(bt_rx_buffer[portno]);
+	//map payload
+	edma_chp->map_pld_addr = dma_map_single(dev, bt_rx_buffer[portno], edma_chp->n_pld_sz, DMA_FROM_DEVICE);
+	if (dma_mapping_error(dev, edma_chp->map_pld_addr)) {
+			PCIE_ERR("dma_mapping_error\n");
+			return -1;
+	}
+	port->state = PORT_STATE_OPEN;
+	edma_adma_send(ch_id, NULL, 1, 0);
+
+	return 0;
+}
+#endif
+
+int skw_pcie_bind_platform_driver(struct pci_dev *pci_dev)
+{
+	struct platform_device *pdev;
+	char	pdev_name[32];
+	struct edma_port *port;
+	int ret = 0;
+	struct wcn_pcie_info *priv = get_pcie_device_info();
+
+	PCIE_INFO("\n");
+	memset(edma_ports, 0, sizeof(struct edma_port) * MAX_PORT_NUM);
+	sprintf(pdev_name, "skw_ucom");
+/*
+ *	creaete AT device
+ */
+	pdev = platform_device_alloc(pdev_name, PLATFORM_DEVID_AUTO);
+	if(!pdev)	
+		return -ENOMEM;
+	pdev->dev.parent = &pci_dev->dev;
+	pdev->dev.dma_mask = &port_dmamask;
+	pdev->dev.coherent_dma_mask = port_dmamask;
+	ucom_pdata.port_name = "ATC";
+	ucom_pdata.data_port = EDMA_AT_PORT;
+	memcpy(ucom_pdata.chipid, priv->chip_id, SKW_CHIP_ID_LENGTH);
+	ret = platform_device_add_data(pdev, &ucom_pdata, sizeof(ucom_pdata));
+	if(ret) {
+		dev_err(&pci_dev->dev, "failed to add platform data \n");
+		platform_device_put(pdev);
+		return ret;
+	}
+	ret = platform_device_add(pdev);
+	if(ret) {
+		dev_err(&pci_dev->dev, "failt to register platform device\n");
+		platform_device_put(pdev);
+		return ret;
+	}
+	port = &edma_ports[ucom_pdata.data_port];
+	port->pdev = pdev;
+	port->state = PORT_STATE_IDLE;
+/*
+ *	creaete log device
+ */
+	pdev = platform_device_alloc(pdev_name, PLATFORM_DEVID_AUTO);
+	if(!pdev)
+		return -ENOMEM;
+	pdev->dev.parent = &pci_dev->dev;
+	pdev->dev.dma_mask = &port_dmamask;
+	pdev->dev.coherent_dma_mask = port_dmamask;
+	ucom_pdata.port_name = "LOG";
+	ucom_pdata.data_port = EDMA_LOG_PORT;
+	ret = platform_device_add_data(pdev, &ucom_pdata, sizeof(ucom_pdata));
+	if(ret) {
+		dev_err(&pci_dev->dev, "failed to add %s device \n", ucom_pdata.port_name);
+		platform_device_put(pdev);
+		return ret;
+	}
+	ret = platform_device_add(pdev);
+	if(ret) {
+		dev_err(&pci_dev->dev, "failt to register platform device\n");
+		platform_device_put(pdev);
+		return ret;
+	}
+
+	port = &edma_ports[ucom_pdata.data_port];
+	port->pdev = pdev;
+	port->state = PORT_STATE_IDLE;
+
+/*
+ *	creaete LOOPCHECK device
+ */
+	pdev = platform_device_alloc(pdev_name, PLATFORM_DEVID_AUTO);
+	if(!pdev)
+		return -ENOMEM;
+	pdev->dev.parent = &pci_dev->dev;
+	pdev->dev.dma_mask = &port_dmamask;
+	pdev->dev.coherent_dma_mask = port_dmamask;
+	ucom_pdata.port_name = "LOOPCHECK";
+	ucom_pdata.data_port = EDMA_LOOPCHECK_PORT;
+	ret = platform_device_add_data(pdev, &ucom_pdata, sizeof(ucom_pdata));
+	if(ret) {
+		dev_err(&pci_dev->dev, "failed to add platform data \n");
+		platform_device_put(pdev);
+		return ret;
+	}
+	ret = platform_device_add(pdev);
+	if(ret) {
+		dev_err(&pci_dev->dev, "failt to register platform device\n");
+		platform_device_put(pdev);
+		return ret;
+	}
+
+	port = &edma_ports[ucom_pdata.data_port];
+	port->pdev = pdev;
+	port->state = PORT_STATE_IDLE;
+	return ret;
+}
+
+int skw_pcie_bind_wifi_driver(struct pci_dev *pci_dev)
+{
+	struct platform_device *pdev;
+	char	pdev_name[32];
+	int ret = 0;
+	struct wcn_pcie_info *priv = get_pcie_device_info();
+
+	PCIE_INFO("\n");
+	sprintf(pdev_name, "%s%d", SV6316_WIRELESS, 1);
+	pdev = platform_device_alloc(pdev_name, PLATFORM_DEVID_AUTO);
+	if(!pdev)
+		return -ENOMEM;
+	pdev->dev.parent = &pci_dev->dev;
+	pdev->dev.dma_mask = &port_dmamask;
+	pdev->dev.coherent_dma_mask = port_dmamask;
+	memcpy(wifi_pdata.chipid, priv->chip_id, SKW_CHIP_ID_LENGTH);
+	ret = platform_device_add_data(pdev, &wifi_pdata, sizeof(wifi_pdata));
+	if(ret) {
+		dev_err(&pci_dev->dev, "failed to add platform data\n");
+		platform_device_put(pdev);
+		return ret;
+	}
+
+	wifi_data_pdev = pdev;
+	ret = platform_device_add(pdev);
+	if(ret) {
+		dev_err(&pci_dev->dev, "failt to register platform device\n");
+		platform_device_put(pdev);
+	}
+	PCIE_DBG("add device successful\n");
+
+	return ret;
+}
+
+#ifdef CONFIG_BT_SEEKWAVE
+int skw_pcie_bind_bt_driver(struct pci_dev *pci_dev)
+{
+	struct platform_device *pdev;
+	char	pdev_name[32];
+	struct edma_port *port;
+	int ret = 0;
+	struct wcn_pcie_info *priv = get_pcie_device_info();
+
+	PCIE_INFO("[-]\n");
+	sprintf(pdev_name, "btseekwave");
+
+	/*creaete BT DATA device*/
+	pdev = platform_device_alloc(pdev_name, PLATFORM_DEVID_AUTO);
+	if(!pdev)
+		return -ENOMEM;
+	pdev->dev.parent = &pci_dev->dev;
+	pdev->dev.dma_mask = &port_dmamask;
+	pdev->dev.coherent_dma_mask = port_dmamask;
+	memcpy(ucom_pdata.chipid, priv->chip_id, SKW_CHIP_ID_LENGTH);
+	ucom_pdata.data_port = EDMA_BTACL_PORT;
+	ucom_pdata.cmd_port = EDMA_BTCMD_PORT;
+	ucom_pdata.audio_port = EDMA_BTAUDIO_PORT;
+	ret = platform_device_add_data(pdev, &ucom_pdata, sizeof(ucom_pdata));
+	if(ret) {
+		dev_err(&pci_dev->dev, "failed to add platform data \n");
+		platform_device_put(pdev);
+		return ret;
+	}
+	ret = platform_device_add(pdev);
+	if(ret) {
+		dev_err(&pci_dev->dev, "failt to register platform device\n");
+		platform_device_put(pdev);
+		return ret;
+	}
+
+	port = get_edma_port_info(ucom_pdata.data_port);
+	port->pdev = pdev;
+	port->state = PORT_STATE_IDLE;
+
+	port = get_edma_port_info(ucom_pdata.cmd_port);
+	port->pdev = pdev;
+	port->state = PORT_STATE_IDLE;
+
+	port = get_edma_port_info(ucom_pdata.audio_port);
+	port->pdev = pdev;
+	port->state = PORT_STATE_IDLE;
+
+	return ret;
+}
+
+#else
+int skw_pcie_bind_bt_driver(struct pci_dev *pci_dev)
+{
+	struct platform_device *pdev;
+	char	pdev_name[32];
+	struct edma_port *port;
+	int ret = 0;
+	struct wcn_pcie_info *priv = get_pcie_device_info();
+
+	PCIE_INFO("[-]\n");
+	sprintf(pdev_name, "skw_ucom");
+/*
+ *	creaete BT DATA device
+ */
+	pdev = platform_device_alloc(pdev_name, PLATFORM_DEVID_AUTO);
+	if(!pdev)
+		return -ENOMEM;
+	pdev->dev.parent = &pci_dev->dev;
+	pdev->dev.dma_mask = &port_dmamask;
+	pdev->dev.coherent_dma_mask = port_dmamask;
+	ucom_pdata.port_name = "BTDATA";
+	ucom_pdata.data_port = EDMA_BTACL_PORT;
+	memcpy(ucom_pdata.chipid, priv->chip_id, SKW_CHIP_ID_LENGTH);
+	ret = platform_device_add_data(pdev, &ucom_pdata, sizeof(ucom_pdata));
+	if(ret) {
+		dev_err(&pci_dev->dev, "failed to add platform data \n");
+		platform_device_put(pdev);
+		return ret;
+	}
+	ret = platform_device_add(pdev);
+	if(ret) {
+		dev_err(&pci_dev->dev, "failt to register platform device\n");
+		platform_device_put(pdev);
+		return ret;
+	}
+	port = &edma_ports[ucom_pdata.data_port];
+	port->pdev = pdev;
+	port->state = PORT_STATE_IDLE;
+
+/*
+ *	creaete BT COMMAND device
+ */
+	pdev = platform_device_alloc(pdev_name, PLATFORM_DEVID_AUTO);
+	if(!pdev)
+		return -ENOMEM;
+	pdev->dev.parent = &pci_dev->dev;
+	pdev->dev.dma_mask = &port_dmamask;
+	pdev->dev.coherent_dma_mask = port_dmamask;
+	ucom_pdata.port_name = "BTCMD";
+	ucom_pdata.data_port = EDMA_BTCMD_PORT;
+	ret = platform_device_add_data(pdev, &ucom_pdata, sizeof(ucom_pdata));
+	if(ret) {
+		dev_err(&pci_dev->dev, "failed to add %s device \n", ucom_pdata.port_name);
+		platform_device_put(pdev);
+		return ret;
+	}
+	ret = platform_device_add(pdev);
+	if(ret) {
+		dev_err(&pci_dev->dev, "failt to register platform device\n");
+		platform_device_put(pdev);
+		return ret;
+	}
+
+	port = &edma_ports[ucom_pdata.data_port];
+	port->pdev = pdev;
+	port->state = PORT_STATE_IDLE;
+
+/*
+ *	creaete BT audio device
+ */
+	pdev = platform_device_alloc(pdev_name, PLATFORM_DEVID_AUTO);
+	if(!pdev)
+		return -ENOMEM;
+	pdev->dev.parent = &pci_dev->dev;
+	pdev->dev.dma_mask = &port_dmamask;
+	pdev->dev.coherent_dma_mask = port_dmamask;
+	ucom_pdata.port_name = "BTAUDIO";
+	ucom_pdata.data_port = EDMA_BTAUDIO_PORT;
+	ret = platform_device_add_data(pdev, &ucom_pdata, sizeof(ucom_pdata));
+	if(ret) {
+		dev_err(&pci_dev->dev, "failed to add platform data \n");
+		platform_device_put(pdev);
+		return ret;
+	}
+	ret = platform_device_add(pdev);
+	if(ret) {
+		dev_err(&pci_dev->dev, "failt to register platform device\n");
+		platform_device_put(pdev);
+		return ret;
+	}
+
+	port = &edma_ports[ucom_pdata.data_port];
+	port->pdev = pdev;
+	port->state = PORT_STATE_IDLE;
+
+/*
+ *	creaete BT isoc  device
+ */
+	pdev = platform_device_alloc(pdev_name, PLATFORM_DEVID_AUTO);
+	if(!pdev)
+		return -ENOMEM;
+	pdev->dev.parent = &pci_dev->dev;
+	pdev->dev.dma_mask = &port_dmamask;
+	pdev->dev.coherent_dma_mask = port_dmamask;
+	ucom_pdata.port_name = "BTISOC";
+	ucom_pdata.data_port = EDMA_ISOC_PORT;
+	ret = platform_device_add_data(pdev, &ucom_pdata, sizeof(ucom_pdata));
+	if(ret) {
+		dev_err(&pci_dev->dev, "failed to add platform data \n");
+		platform_device_put(pdev);
+		return ret;
+	}
+	ret = platform_device_add(pdev);
+	if(ret) {
+		dev_err(&pci_dev->dev, "failt to register platform device\n");
+		platform_device_put(pdev);
+		return ret;
+	}
+
+	port = &edma_ports[ucom_pdata.data_port];
+	port->pdev = pdev;
+	port->state = PORT_STATE_IDLE;
+
+/*
+ *	creaete BT LOG  device
+ */
+	pdev = platform_device_alloc(pdev_name, PLATFORM_DEVID_AUTO);
+	if(!pdev)
+		return -ENOMEM;
+	pdev->dev.parent = &pci_dev->dev;
+	pdev->dev.dma_mask = &port_dmamask;
+	pdev->dev.coherent_dma_mask = port_dmamask;
+	ucom_pdata.port_name = "BTLOG";
+	ucom_pdata.data_port = EDMA_BTLOG_PORT;
+	ret = platform_device_add_data(pdev, &ucom_pdata, sizeof(ucom_pdata));
+	if(ret) {
+		dev_err(&pci_dev->dev, "failed to add platform data \n");
+		platform_device_put(pdev);
+		return ret;
+	}
+	ret = platform_device_add(pdev);
+	if(ret) {
+		dev_err(&pci_dev->dev, "failt to register platform device\n");
+		platform_device_put(pdev);
+		return ret;
+	}
+
+	port = &edma_ports[ucom_pdata.data_port];
+	port->pdev = pdev;
+	port->state = PORT_STATE_IDLE;
+	return ret;
+}
+#endif
+
+int skw_pcie_unbind_wifi_driver(struct pci_dev *dev)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+int skw_pcie_unbind_bt_driver(struct pci_dev *dev)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+int  skw_edma_init(void)
+{
+	int i;
+	struct wcn_pcie_info *priv;
+#ifdef CONFIG_SKW_MSI_AS_LEGACY
+	int val;
+#endif
+	priv = get_pcie_device_info();
+	if (priv->msix_en)
+		skw_pcie_write32(DMA_INT_TYPE_CFG, 0x2);
+	else if (priv->msi_en)
+		skw_pcie_write32(DMA_INT_TYPE_CFG, 0x0);
+	else if (priv->legacy_en)
+		skw_pcie_write32(DMA_INT_TYPE_CFG, 0x1);
+	else
+		skw_pcie_write32(DMA_INT_TYPE_CFG, 0x2);
+
+	skw_pcie_write32(DMA_DST_RING_NODE_NUM, 0x3ff);
+	skw_pcie_write32(DMA_SRC_RING_NODE_NUM, 0x3ff);
+
+	memset(&edma_chns_info[0], 0, sizeof(edma_chns_info));
+	for (i = 0;i < MAX_EDMA_COUNT;i++) {
+		edma_chns_info[i].chn_id = i;
+#ifdef CONFIG_SKW_MSI_AS_LEGACY
+		val = skw_pcie_read32(DMA_CFG(i));
+		val &= ~0xf8000000;
+		skw_pcie_write32(DMA_CFG(i), val);
+#endif
+	}
+	edma_spin_lock_init(priv);
+	skw_edma_wakeup_source_init();
+#ifdef CONFIG_BT_SEEKWAVE
+	INIT_WORK(&priv->bt_rx_work, bt_rx_work);
+#endif
+
+	at_buffer = (char *)kzalloc(EDMA_PORT_BUFFER_SIZE, GFP_KERNEL);
+
+	return 0;
+}
+
+int skw_edma_pause(void)
+{
+	struct wcn_pcie_info *priv = get_pcie_device_info();
+	int status, ret;
+
+	skw_pcie_write32(DMA_PAUSE, 0xffffffff);
+	ret = readl_poll_timeout(priv->pcimem + (DMA_PAUSE_DONE - 0x40000000),
+				 status, (status == 0xffffffff), 5, 100);
+	if (ret) {
+		PCIE_ERR("Failed to pause,done:0x%08x,rawint:0x%08x\n", status, skw_pcie_read32(DMA_INT_MASK_STS-4));
+		return -EBUSY;
+	}
+
+	ret = readl_poll_timeout(priv->pcimem + (DMA_REQ_STS - 0x40000000),
+				 status, (status == 0), 5, 100);
+	if (ret) {
+		PCIE_ERR("EDMA is busy\n");
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+void skw_edma_restore(void)
+{
+	skw_pcie_write32(DMA_PAUSE, 0);
+}
+
+void recovery_close_all_ports(void)
+{
+	int i = 0;
+	struct edma_port *port;
+
+	PCIE_INFO("[+]\n");
+	for(i=0; i<MAX_PORT_NUM;i++) {
+		PCIE_DBG("portno=%d\n", i);
+		port = get_edma_port_info(i);
+		if(port->pdev)
+			close_edma_port(i);
+		PCIE_DBG("portno=%d\n", i);
+	}
+	PCIE_INFO("[-]\n");
+}
+
+int skw_pcie_unbind_port_driver(void)
+{
+	int i = 0;
+	struct edma_port *port;
+	struct wcn_pcie_info *priv = get_pcie_device_info();
+
+	PCIE_INFO("[+]\n");
+	platform_device_unregister(wifi_data_pdev);
+	PCIE_DBG("\n");
+	for(i=0; i<MAX_PORT_NUM;i++) {
+		PCIE_DBG("portno=%d\n", i);
+		port = get_edma_port_info(i);
+		if(port->pdev) {
+			if (priv->cp_state == 0) //not recovery
+				close_edma_port(i);
+			platform_device_unregister(port->pdev);
+		}
+		PCIE_DBG("portno=%d\n", i);
+	}
+	PCIE_INFO("[-]\n");
+	return 0;
+ }
+
+void skw_edma_deinit(void)
+{
+	struct wcn_pcie_info *priv = get_pcie_device_info();
+
+	PCIE_DBG("[+]\n");
+	kfree(at_buffer);
+	kfree(priv->spin_lock);
+	skw_edma_wakeup_source_destroy();
+	skw_pcie_unbind_port_driver();
+	PCIE_DBG("[-]\n");
+}
diff --git a/drivers/misc/seekwaveplatform_v20/pcie/skw_edma_drv.h b/drivers/misc/seekwaveplatform_v20/pcie/skw_edma_drv.h
new file mode 100755
index 000000000000..cce5bbbf0aff
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/pcie/skw_edma_drv.h
@@ -0,0 +1,141 @@
+#ifndef __SKW_EDMA_DRV_H_
+#define __SKW_EDMA_DRV_H_
+#include "skw_pcie_drv.h"
+#define EDMA_TX	0
+#define EDMA_RX	1
+
+#define EDMA_STD_MODE 0
+#define EDMA_LINKLIST_MODE 1
+
+#define	MAX_EDMA_COUNT 32
+
+#define MAX_PORT_NUM	8
+#define EDMA_BTCMD_PORT	0
+#define EDMA_BTACL_PORT	1
+#define EDMA_BTAUDIO_PORT	2
+#define EDMA_ISOC_PORT	3
+#define EDMA_BTLOG_PORT 4
+
+#define EDMA_LOOPCHECK_PORT	5
+#define EDMA_AT_PORT	6
+#define EDMA_LOG_PORT	7
+
+#define EDMA_WIFI_RX0_FILTER_DATA_CHN 17
+#define EDMA_WIFI_RX1_FILTER_DATA_CNH 18
+#define EDMA_WIFI_TX0_PACKET_ADDR 19
+#define EDMA_WIFI_TX1_PACKET_ADDR 20
+#define EDMA_WIFI_TX0_FREE_ADDR 21
+#define EDMA_WIFI_TX1_FREE_ADDR 22
+#define EDMA_WIFI_RX0_PKT_ADDR 25
+#define EDMA_WIFI_RX1_PKT_ADDR 26
+
+#define BASE_EDMA_CH		0
+#define BASE_EDMA_CH_EXT	27
+
+#define PORT_TO_EDMA_TX_CHANNEL(x)     (x>=EDMA_LOG_PORT? ((x-EDMA_LOG_PORT)*2+27):BASE_EDMA_CH + x * 2)
+#define PORT_TO_EDMA_RX_CHANNEL(x)     (x>=EDMA_LOG_PORT? ((x-EDMA_LOG_PORT)*2+28): BASE_EDMA_CH + x * 2 + 1)
+#define EDMACH2PORTNO(x)               ((x>=BASE_EDMA_CH_EXT)?(((x-BASE_EDMA_CH_EXT)>>1)+EDMA_LOG_PORT):(x - BASE_EDMA_CH)>> 1)
+
+#define EDMA_PORT_BUFFER_SIZE 512
+
+#define PORT_STATE_IDLE	0
+#define PORT_STATE_OPEN	1
+#define PORT_STATE_CLSE	2
+#define PORT_STATE_ASST	3
+#define PORT_STATE_BUSY	4
+
+struct EDMA_HDR {
+	u64 data_addr:40;
+	u64 rsv0:16;
+	u64 tx_int:1;
+	u64 rsv1:6;
+	u64 done:1;
+
+	u64 next_hdr:40;
+	u64 rsv2:8;
+	u64 data_len:16;
+} __attribute__((packed));
+typedef struct EDMA_HDR EDMA_HDR_T;
+
+typedef union  EDMA_ADDR_U {
+	struct{
+		u64 addr_l32 : 32;
+		u64 addr_h8 : 8;
+		u64 Reserved_24   : 24;
+	};
+	u64 u64;
+} EDMA_ADDR_T;
+
+struct edma_chn_info {
+	struct skw_channel_cfg chn_cfg;
+	u32 n_pld_sz;
+	u32 chn_id;
+	void *p_link_hdr;
+	dma_addr_t dma_hdr_handle;
+	void *rcv_header_cpu_addr;
+	void *rcv_tail_cpu_addr;
+	dma_addr_t map_hdr_addr;
+	dma_addr_t map_pld_addr;
+	dma_addr_t map_skb_addr;
+};
+
+struct edma_port {
+	struct platform_device *pdev;
+	u8 portno;
+	u16 tx_index;
+	u16 rx_rp;
+	u16 rx_wp;
+	struct skw_channel_cfg *rx_line;
+	struct skw_channel_cfg *tx_line;
+	EDMA_HDR_T *rx_node;
+	EDMA_HDR_T *tx_node;
+	u8 rx_ch;
+	u8 tx_ch;
+	u16 rx_size;
+	u16 tx_size;
+	char *rx_buf_addr;
+	rx_submit_fn rx_submit;
+	void *rx_data;
+	int	state;
+	struct completion rx_done;
+	struct completion tx_done;
+	struct mutex rx_mutex;
+};
+
+extern void edma_init(void);
+extern void EDMA_IRQPolling(void);
+void skw_get_port_statistic(char *buffer, int size);
+int  skw_edma_init(void);
+void skw_edma_deinit(void);
+int msi_edma_channel_irq_handler(int irq_num);
+int legacy_edma_irq_handle(void);
+int msi_irq_wifi_takeover_handler(int irq_num);
+int skw_pcie_bind_wifi_driver(struct pci_dev *pci_dev);
+int skw_pcie_bind_platform_driver(struct pci_dev *pci_dev);
+int skw_pcie_bind_bt_driver(struct pci_dev *dev);
+int skw_pcie_unbind_wifi_driver(struct pci_dev *dev);
+int skw_pcie_unbind_bt_driver(struct pci_dev *dev);
+int edma_channel_init(int ch_id, void *channel_config, void *data);
+int edma_adma_send(int ch_id, struct scatterlist *sg, int node_cnt, int size);
+int submit_list_to_edma_channel(int ch_id, u64 header, int count);
+struct edma_chn_info *get_edma_channel_info(int id);
+struct edma_port *get_edma_port_info(int portno);
+int skw_recovery_mode(void);
+int recv_data(int portno, char *buffer, int size);
+int send_data(int portno, char *buffer, int size);
+int open_edma_port(int portno, void *callback, void *data);
+int close_edma_port(int portno);
+int skw_pcie_create_loopcheck_thread(int portno);
+void modem_unregister_notify(struct notifier_block *nb);
+void modem_register_notify(struct notifier_block *nb);
+int skw_pcie_remove_loopcheck_thread(int portno);
+void skw_edma_lock_event(void);
+int skw_edma_pause(void);
+void skw_edma_restore(void);
+void recovery_close_all_ports(void);
+int legacy_irq_wifi_takeover_handler(int ch_id);
+void check_dumpdone_work(struct work_struct *work);
+#ifdef CONFIG_BT_SEEKWAVE
+int bt_rx_prepare(int portno);
+#endif
+#endif /* __EDMA_DRV_H_ */
diff --git a/drivers/misc/seekwaveplatform_v20/pcie/skw_edma_reg.h b/drivers/misc/seekwaveplatform_v20/pcie/skw_edma_reg.h
new file mode 100755
index 000000000000..118e8af99132
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/pcie/skw_edma_reg.h
@@ -0,0 +1,191 @@
+#ifndef _SKW_DMA_REG_H_
+#define _SKW_DMA_REG_H_
+
+#define SKW_DMA_BASE 0x40188000
+
+#define DMA_INT_MASK_STS                ( SKW_DMA_BASE + 0x0004 )
+#define DMA_REQ_STS                     ( SKW_DMA_BASE + 0x0008 )
+#define DMA_PAUSE                       ( SKW_DMA_BASE + 0x0010 )
+#define DMA_AXI_OST_NUM                 ( SKW_DMA_BASE + 0x0034 )
+#define DMA_PAUSE_DONE                  ( SKW_DMA_BASE + 0x0038 )
+#define DMA_DST_RING_NODE_NUM           ( SKW_DMA_BASE + 0x003C )
+#define DMA_SRC_RING_NODE_NUM           ( SKW_DMA_BASE + 0x0040 )
+#define DMA_INT_TYPE_CFG                ( SKW_DMA_BASE + 0x004C )
+
+#define DMA_SRC_REQ(x)			  ( SKW_DMA_BASE + x*0x80 + 0x0080 + 0x0000 )
+#define DMA_SRC_NODE(x)			  ( SKW_DMA_BASE + x*0x80 + 0x0080 + 0x0004 )
+#define DMA_DST_REQ(x)			  ( SKW_DMA_BASE + x*0x80 + 0x0080 + 0x0008 )
+#define DMA_DST_NODE(x)			  ( SKW_DMA_BASE + x*0x80 + 0x0080 + 0x000C )
+#define DMA_SRC_DSCR_PTR_HIGH(x)		  ( SKW_DMA_BASE + x*0x80 + 0x0080 + 0x0010 )
+#define DMA_SRC_DSCT_PTR_LOW(x)		  ( SKW_DMA_BASE + x*0x80 + 0x0080 + 0x0014 )
+#define DMA_DST_DSCR_PTR_HIGH(x)		  ( SKW_DMA_BASE + x*0x80 + 0x0080 + 0x0018 )
+#define DMA_DST_DSCR_PTR_LOW(x)		  ( SKW_DMA_BASE + x*0x80 + 0x0080 + 0x001C )
+#define DMA_SRC_INT(x)			  ( SKW_DMA_BASE + x*0x80 + 0x0080 + 0x0020 )
+#define DMA_DST_INT(x)			  ( SKW_DMA_BASE + x*0x80 + 0x0080 + 0x0024 )
+#define DMA_DST_INT_DSCR_HEAD_LOW(x)	  ( SKW_DMA_BASE + x*0x80 + 0x0080 + 0x0030 )
+#define DMA_DST_INT_DSCR_TAIL_LOW(x)	  ( SKW_DMA_BASE + x*0x80 + 0x0080 + 0x0034 )
+#define DMA_DST_INT_DSCR_HIGH(x)		  ( SKW_DMA_BASE + x*0x80 + 0x0080 + 0x0038 )
+#define DMA_SRC_INT_DSCR_HEAD_LOW(x)	  ( SKW_DMA_BASE + x*0x80 + 0x0080 + 0x0040 )
+#define DMA_SRC_INT_DSCR_TAIL_LOW(x)	  ( SKW_DMA_BASE + x*0x80 + 0x0080 + 0x0044 )
+#define DMA_SRC_INT_DSCR_HIGH(x)		  ( SKW_DMA_BASE + x*0x80 + 0x0080 + 0x0048 )
+#define DMA_NODE_TOT_CNT(x)			  ( SKW_DMA_BASE + x*0x80 + 0x0080 + 0x004C )
+#define DMA_CFG(x)				  ( SKW_DMA_BASE + x*0x80 + 0x0080 + 0x0050 )
+#define DMA_LEN_CFG(x)			  ( SKW_DMA_BASE + x*0x80 + 0x0080 + 0x0054 )
+
+#define NODE_NUM_OFFSET 16
+#define TRANS_LEN_OFFSET 16
+#define EDMA_REQ BIT(0)
+
+typedef union {
+	unsigned int u32;
+	struct {
+    u32 src_data_split_en    : 1;
+    u32 src_ring_buf_en      : 1;
+    u32 Reserved_2                  :20;
+    u32 node_num_thr     : 9;
+    u32 node_num_thr_en  : 1;
+	};
+} DMA_SRC_NODE_S;
+
+typedef union {
+	unsigned int u32;
+	struct {
+    u32 dst_data_split_en    : 1;
+    u32 dst_ring_buf_en      : 1;
+    u32 Reserved_5                  :20;
+    u32 dst_node_num_thr     : 9;
+    u32 dst_node_num_thr_en  : 1;
+	};
+} DMA_DST_NODE_S;
+
+ typedef union {
+	unsigned int u32;
+	struct {
+    u32 src_next_dscr_ptr_high  : 8;
+    u32 Reserved_6                     :24;
+	};
+} DMA_SRC_DSCR_PTR_HIGH_S;
+
+typedef union {
+	unsigned int u32;
+	struct {
+    u32 src_next_dscr_ptr_low  :32;
+	};
+} DMA_SRC_DSCT_PTR_LOW_S;
+
+typedef union {
+	unsigned int u32;
+	struct {
+    u32 Reserved_8                     : 8;
+    u32 dst_next_dscr_ptr_high  : 8;
+    u32 Reserved_7                     :16;
+	};
+} DMA_DST_DSCR_PTR_HIGH_S;
+
+typedef union {
+	unsigned int u32;
+	struct {
+    u32 dst_next_dscr_ptr_low  :32;
+	};
+} DMA_DST_DSCR_PTR_LOW_S;
+
+typedef union {
+	unsigned int u32;
+	struct {
+    u32 src_complete_int_en            : 1;
+    u32 src_list_empty_int_en          : 1;
+    u32 src_cfg_err_int_en             : 1;
+    u32 Reserved_13                    : 1;
+    u32 src_cmplt_en_wi_dst_node_done  : 1;
+    u32 Reserved_12                    : 3;
+    u32 Rsvd_0           : 1;
+    u32 Rsvd_2         : 1;
+    u32 Rsvd_3            : 1;
+    u32 Reserved_11                    : 5;
+    u32 src_complete_mask_sts          : 1;
+    u32 src_list_empty_mask_sts        : 1;
+    u32 Rsvd_4           : 1;
+    u32 Reserved_10                    : 5;
+    u32 src_complete_int_clr           : 1;
+    u32 src_list_empty_int_clr         : 1;
+    u32 Rsvd_5            : 1;
+    u32 Reserved_9                     : 5;
+	};
+} DMA_SRC_INT_S;
+
+
+typedef union {
+	unsigned int u32;
+	struct {
+    u32 dst_complete_int_en            : 1;
+    u32 dst_list_empty_int_en          : 1;
+    u32 dst_cfg_err_int_en             : 1;
+    u32 Reserved_18                           : 1;
+    u32 Rsvd_6  : 1;
+    u32 Reserved_17                           : 3;
+    u32 Rsvd_7           : 1;
+    u32 Rsvd_8         : 1;
+    u32 Rsvd_9            : 1;
+    u32 Reserved_16                           : 5;
+    u32 dst_complete_mask_sts          : 1;
+    u32 dst_list_empty_mask_sts        : 1;
+    u32 Rsvd_10           : 1;
+    u32 Reserved_15                           : 5;
+    u32 dst_complete_int_clr           : 1;
+    u32 dst_list_empty_int_clr         : 1;
+    u32 Rsvd_11            : 1;
+    u32 Reserved_14                           : 5;
+	};
+} DMA_DST_INT_S;
+
+typedef union {
+	unsigned int u32;
+	struct {
+    u32 dst_int_dscr_tail_high  : 8;
+    u32 dst_int_dscr_head_high  : 8;
+    u32 Reserved_23                    : 6;
+    u32 dst_node_done_num       :10;
+	};
+} DMA_DST_INT_DSCR_HIGH_S;
+
+typedef union {
+	unsigned int u32;
+	struct {
+    u32 src_int_dscr_tail_high  : 8;
+    u32 src_int_dscr_head_high  : 8;
+    u32 Reserved_24                    : 6;
+    u32 src_node_done_num       :10;
+	};
+} DMA_SRC_INT_DSCR_HIGH_S;
+
+typedef union {
+	unsigned int u32;
+	struct {
+    u32 src_tot_node_num      :10;
+    u32 Reserved_26                  : 6;
+    u32 dst_tot_node_num      :10;
+    u32 Reserved_25                  : 5;
+    u32 Rsvd_12  : 1;
+	};
+} DMA_NODE_TOT_CNT_S;
+
+typedef union {
+	unsigned int u32;
+	struct {
+    u32 Rsvd_18               : 1;
+    u32 Rsvd_13        : 3;
+    u32 Rsvd_14  : 1;
+    u32 Reserved_28             : 2;
+    u32 dir              : 1;
+    u32 endian_mode      : 2;
+    u32 priority         : 2;
+    u32 Rsvd_15  : 1;
+    u32 req_mode         : 1;
+    u32 Rsvd_16      : 1;
+    u32 Reserved_27             :12;
+    u32 Rsvd_17      : 5;
+	};
+} DMA_CFG_S;
+
+#endif // _SKW_DMA_REG_H_
+
diff --git a/drivers/misc/seekwaveplatform_v20/pcie/skw_pcie_boot.c b/drivers/misc/seekwaveplatform_v20/pcie/skw_pcie_boot.c
new file mode 100755
index 000000000000..e2c815102b4c
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/pcie/skw_pcie_boot.c
@@ -0,0 +1,594 @@
+/*
+ * Copyright (C) 2022 Seekwave Tech Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/platform_device.h>
+#include <uapi/linux/sched/types.h>
+#include <linux/scatterlist.h>
+#include <linux/dma-mapping.h>
+#include <linux/version.h>
+#include <linux/semaphore.h>
+#include <linux/pm_runtime.h>
+#include <linux/kthread.h>
+#include <linux/module.h>
+#include <linux/list.h>
+#include <linux/err.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/firmware.h>
+#include "skw_edma_drv.h"
+#include "skw_pcie_drv.h"
+#include "skw_pcie_log.h"
+#include "skw_edma_reg.h"
+
+
+extern u32 last_sent_wifi_cmd[3];
+extern u64 last_sent_time;
+
+volatile u32 int_cnt = 0;
+static u32 dl_req_cnt = 0, std_complete_cnt = 0;
+static int cp_log_status = 0;
+extern int send_modem_assert_command(void);
+static int skw_check_cp_ready(void);
+int skw_pcie_elbi_writeb(unsigned int address, unsigned char value);
+int skw_pcie_elbi_writed(unsigned int address, u32 value);
+int skw_pcie_cp_reset(void);
+int skw_pcie_slp_feature_en(unsigned int address, unsigned int slp_en);
+int skw_pcie_boot_cp(int boot_mode);
+
+int skw_pcie_elbi_writeb(unsigned int address, unsigned char value)
+{
+	int ret;
+	struct wcn_pcie_info *priv = get_pcie_device_info();
+	ret=pci_write_config_byte(priv->dev,address, value);
+	PCIE_DBG("line:%d (address,value)-(0x%x,0x%x)\n",__LINE__,address, value);
+	return ret;
+}
+
+int skw_pcie_elbi_writed(unsigned int address, u32 value)
+{
+	struct wcn_pcie_info *priv = get_pcie_device_info();
+	pci_write_config_dword(priv->dev,address, value);
+	PCIE_DBG("line:%d (address,value)-(0x%x,0x%x)\n",__LINE__,address, value);
+	return value;
+}
+
+/*
+ *svc_op:0-wifi start, 1-wifi stop, 2-bt start, 3-bt stop
+ */
+static int send_modem_service_command(u16 service, u16 command)
+{
+	int ret = 0;
+	u16 cmd;
+	struct wcn_pcie_info *priv = get_pcie_device_info();
+	PCIE_DBG("line:%d (ser,cmd)-(%d,%d)\n",__LINE__, service, command);
+	if(command)
+		priv->service_state_map&= ~(1<<service);
+	//command = 1;
+	cmd = (service<<1)|command;
+	cmd = 1 << cmd;
+
+	if(priv->cp_state){
+		PCIE_DBG("the cp_state = %d ---line:%d",priv->cp_state, __LINE__);
+		return ret;
+	}
+	if(cmd>>8)
+		ret = skw_pcie_elbi_writeb(SKW_AP2CP_IRQ_REG, cmd & 0xff);
+	if(ret || !(cmd&0xff))
+		return ret;
+	PCIE_INFO("line:%d (ser,cmd)-(%d,0x%x)\n",__LINE__, service, cmd);
+	return skw_pcie_elbi_writeb(SKW_AP2CP_IRQ_REG, cmd & 0xff);
+}
+
+
+int download_fw_complete_cb(void *context, u64 header, u64 tailed, int node_count)
+{
+	u32 val;
+	u32 i;
+	struct edma_chn_info *edma_chp = get_edma_channel_info(0);
+	struct wcn_pcie_info *priv= get_pcie_device_info();
+
+	std_complete_cnt += 1;
+	PCIE_DBG("1. dl_req_cnt=%d, std_complete_cnt=%d\n", dl_req_cnt, std_complete_cnt);
+	if (dl_req_cnt == std_complete_cnt) {
+		std_complete_cnt = 0;
+		dl_req_cnt = 0;
+		int_cnt = 0;
+		 PCIE_DBG("2. dl_req_cnt=%d, std_complete_cnt=%d\n", dl_req_cnt, std_complete_cnt);
+		//set crc value
+		for (i = 0;i < 7;i++) {
+			skw_pcie_write32(FW_DATA_CRC_BASE + i * 4, 0);
+		}
+		if (priv->iram_crc_en) {
+			skw_pcie_write32(FW_DATA_CRC_BASE +0x0, priv->iram_crc_offset);//iram crc offset
+			skw_pcie_write32(FW_DATA_CRC_BASE +0x4, priv->iram_dl_size);//iram crc size
+			skw_pcie_write32(FW_DATA_CRC_BASE +0x8, priv->iram_crc);//iram crc
+			val = 3;//iram crc en
+		}
+		if (priv->dram_crc_en) {
+			skw_pcie_write32(FW_DATA_CRC_BASE +0xc, priv->dram_crc_offset);//dram crc offset
+			skw_pcie_write32(FW_DATA_CRC_BASE +0x10, priv->dram_dl_size);//dram crc size
+			skw_pcie_write32(FW_DATA_CRC_BASE +0x14, priv->dram_crc);//dram crc
+			val |= (3<<2);//dram crc en
+		}
+		if (priv->iram_crc_en || priv->dram_crc_en)
+			skw_pcie_write32(FW_DATA_CRC_BASE +0x18, val);
+
+		//set boot addr
+		skw_pcie_write32(FW_BOOT_REG_BASE, 0x100000);
+
+		//disable boot chn0 eb
+		val = skw_pcie_read32(DMA_CFG(0));
+		val &= ~0x1;
+		skw_pcie_write32(DMA_CFG(0), val);
+
+		//set dl done
+		val = skw_pcie_read32(FW_DL_DONE_REG_BASE);
+		val |= 0x3;
+		skw_pcie_write32(FW_DL_DONE_REG_BASE, val);
+		dma_unmap_single(&priv->dev->dev, edma_chp->map_pld_addr, priv->iram_dl_size, DMA_TO_DEVICE);
+		dma_unmap_single(&priv->dev->dev, edma_chp->map_skb_addr, priv->dram_dl_size, DMA_TO_DEVICE);
+	}
+
+	complete(&priv->edma_blk_dl_done);
+	return 0;
+}
+
+static int pcie_download_fw(u32 dst_addr, void *buf, u32 len)
+{
+	struct edma_chn_info *edma_chp = get_edma_channel_info(0);
+	struct wcn_pcie_info *priv= get_pcie_device_info();
+	DMA_DST_DSCR_PTR_HIGH_S dst_addr_h8 = {0};
+	DMA_DST_DSCR_PTR_LOW_S dst_addr_l32 = {0};
+	int i;
+
+
+	mutex_lock(&priv->dl_lock);
+	edma_chp->chn_cfg.direction = EDMA_TX;
+	edma_chp->chn_cfg.req_mode = EDMA_STD_MODE;
+	edma_chp->chn_cfg.complete_callback = download_fw_complete_cb;
+	edma_chp->chn_cfg.trsc_len = 0xffff;
+
+	for (i = 0; i < len / 0xffff; i++) {
+		reinit_completion(&priv->edma_blk_dl_done);
+		//src addr
+		edma_chp->chn_cfg.header = edma_virtaddr_to_pcieaddr((char *)buf + i * 0xFFFF);
+		edma_channel_init(0, &edma_chp->chn_cfg, NULL);
+
+		//dst addr
+		dst_addr_l32.dst_next_dscr_ptr_low = (dst_addr + i * 0xFFFF) & 0xffffffff;
+		skw_pcie_write32(DMA_DST_DSCR_PTR_LOW(0), dst_addr_l32.u32);
+		dst_addr_h8.dst_next_dscr_ptr_high = 0;
+		skw_pcie_write32(DMA_DST_DSCR_PTR_HIGH(0), dst_addr_h8.u32);
+
+		int_cnt++;
+		//PCIE_DBG("2. %d: std_complete_cnt=%d, int_cnt=%d\n", __LINE__, std_complete_cnt, int_cnt);
+		edma_adma_send(0, NULL, 0, 0);
+		//dst req
+		skw_pcie_setbit(DMA_DST_REQ(0), BIT(0));
+		wait_for_completion(&priv->edma_blk_dl_done);
+	}
+	if (len % 0xffff) {
+		reinit_completion(&priv->edma_blk_dl_done);
+		edma_chp->chn_cfg.trsc_len = len % 0xffff;
+		//src addr
+		edma_chp->chn_cfg.header = edma_virtaddr_to_pcieaddr((char *)buf + i * 0xFFFF);
+		//edma_chp->chn_cfg.header = edma_phyaddr_to_pcieaddr((dma_addr_t)buf + i * 0xFFFF);
+		edma_channel_init(0, &edma_chp->chn_cfg, NULL);
+
+		//dst addr
+		dst_addr_l32.dst_next_dscr_ptr_low = (dst_addr + i * 0xFFFF) & 0xffffffff;
+		skw_pcie_write32(DMA_DST_DSCR_PTR_LOW(0), dst_addr_l32.u32);
+		dst_addr_h8.dst_next_dscr_ptr_high = 0;
+		skw_pcie_write32(DMA_DST_DSCR_PTR_HIGH(0), dst_addr_h8.u32);
+		int_cnt++;
+		//PCIE_DBG("4. %d: std_complete_cnt=%d, int_cnt=%d\n", __LINE__, std_complete_cnt, int_cnt);
+		edma_adma_send(0, NULL, 0, 0);
+		//dst req
+		skw_pcie_setbit(DMA_DST_REQ(0), BIT(0));
+		wait_for_completion(&priv->edma_blk_dl_done);
+	}
+	mutex_unlock(&priv->dl_lock);
+	return 0;
+}
+
+int skw_WIFI_service_start(void)
+{
+	int count=90;
+	int ret =0;
+	struct wcn_pcie_info *priv= get_pcie_device_info();
+	PCIE_INFO("Enter STARTWIFI %d\n",priv->cp_state);
+	if (priv->cp_state) {
+		while(priv->cp_state&&count--)
+			msleep(10);
+	}
+	if (priv->service_state_map & (1<<WIFI_SERVICE))
+		return 0;
+
+#ifdef CONFIG_SEEKWAVE_PLD_RELEASE
+	//release version close the cP log
+	skw_pcie_cp_log(1);
+#endif
+
+	skw_reinit_completion(priv->download_done);
+	ret= send_modem_service_command(WIFI_SERVICE, SERVICE_START);
+	if(!ret)
+		ret = skw_check_cp_ready();
+
+	return ret;
+
+}
+
+int skw_WIFI_service_stop(void)
+{
+	int count=50;
+	struct wcn_pcie_info *priv= get_pcie_device_info();
+	PCIE_DBG("Enter,STOPWIFI  cp_state:%d",priv->cp_state);
+	if (priv->cp_state) {
+		priv->service_state_map &= ~(1<<WIFI_SERVICE);
+		while(priv->cp_state&& count--)
+			msleep(10);
+		return 0;
+	}
+	if (priv->service_state_map & (1<<WIFI_SERVICE))
+		return send_modem_service_command(WIFI_SERVICE, SERVICE_STOP);
+	return 0;
+
+}
+
+int skw_BT_service_start(void)
+{
+	int count=90;
+	int ret;
+	struct wcn_pcie_info *priv= get_pcie_device_info();
+	PCIE_INFO("Enter STARTBT %d\n",priv->cp_state);
+	if (priv->cp_state) {
+		while(priv->cp_state&&count--)
+			msleep(10);
+	}
+	if (priv->service_state_map & (1<<BT_SERVICE))
+		return 0;
+
+#ifdef CONFIG_SEEKWAVE_PLD_RELEASE
+	//release version close the cP log
+	skw_pcie_cp_log(1);
+#endif
+
+	skw_reinit_completion(priv->download_done);
+	ret = send_modem_service_command(BT_SERVICE, SERVICE_START);
+	if(!ret)
+		ret = skw_check_cp_ready();
+
+	return ret;
+}
+
+int skw_BT_service_stop(void)
+{
+	int count=50;
+	struct wcn_pcie_info *priv= get_pcie_device_info();
+	PCIE_INFO("Enter,STOPBT  cp_state:%d",priv->cp_state);
+	if (priv->cp_state) {
+		priv->service_state_map &= ~(1<<BT_SERVICE);
+		while(priv->cp_state&& count--)
+			msleep(10);
+		return 0;
+	}
+	if (priv->service_state_map & (1<<BT_SERVICE)) {
+		skw_reinit_completion(priv->download_done);
+		send_modem_service_command(BT_SERVICE, SERVICE_STOP);
+		wait_for_completion_interruptible_timeout(&priv->download_done, msecs_to_jiffies(100));
+	}
+	return 0;
+}
+
+int skw_pcie_cp_log(int disable)
+{
+	int ret =0;
+	struct wcn_pcie_info *priv = get_pcie_device_info();
+	PCIE_DBG("-----CP LOG--SWITCH-----!!!\n");
+	cp_log_status = disable;
+	if(priv->cp_state)
+		return ret;
+	ret =skw_pcie_elbi_writeb(SKWPCIE_AP2CP_SIG1, disable);
+	if(ret <0){
+		PCIE_ERR("switch the log signal send fail ret=%d\n", ret);
+		return ret;
+	}
+	skw_pcie_elbi_writeb(SKW_AP2CP_IRQ_REG, 0x20);
+	return ret;
+}
+int skw_pcie_cp_log_status(void)
+{
+	return cp_log_status;
+}
+
+int skw_pcie_recovery_disable(int disable)
+{
+	 struct wcn_pcie_info *priv= get_pcie_device_info();
+	 priv->recovery_dis_state = disable;
+	 PCIE_DBG("The recovery dis state = %d \n", disable);
+	 return 0;
+}
+
+int skw_pcie_recovery_debug_status(void)
+{
+	 struct wcn_pcie_info *priv= get_pcie_device_info();
+	 return priv->recovery_dis_state;
+}
+
+int skw_recovery_mode(void)
+{
+	 int ret;
+	 struct wcn_pcie_info *priv= get_pcie_device_info();
+
+	 ret=skw_pcie_cp_reset();
+	 if(ret!=0){
+		 PCIE_ERR("CP RESET fail \n");
+		 return -1;
+	 }
+	 //skw_pcie_bind_bt_driver(priv->dev);
+	 ret = skw_pcie_boot_cp(RECOVERY_BOOT);
+	 if(ret!=0){
+		 PCIE_ERR("CP RESET fail \n");
+		 return -1;
+	 }
+	 skw_pcie_bind_wifi_driver(priv->dev);
+	 PCIE_INFO("Recovery ok\n");
+	 return 0;
+}
+
+int skw_pcie_cp_reset(void)
+{
+	int ret=0;
+
+	skw_pcie_rescan_bus();
+	if (ret < 0) {
+		PCIE_ERR("enable func1 err!!! ret is %d\n", ret);
+		return -1;
+	}
+	PCIE_DBG("CP RESET OK!\n");
+	return 0;
+}
+
+int skw_pcie_slp_feature_en(unsigned int address, unsigned int slp_en)
+{
+	int ret =0;
+	//ret = skw_pcie_elbi_writeb()
+	if(ret !=0)
+	{
+		PCIE_ERR("support en write fail ret=%d\n",ret);
+		return -1;
+	}
+	PCIE_INFO("nslp support enable:%d\n", slp_en);
+	return 0;
+}
+/****************************************************************
+*Description:
+*Func:used the ap boot cp interface;
+*Output:the dloader the bin to cp
+*Return0:pass; other : fail
+*Author:JUNWEI.JIANG
+*Date:2023-06-07
+****************************************************************/
+int skw_pcie_boot_cp(int boot_mode)
+{
+	int ret =0;
+	struct wcn_pcie_info *priv= get_pcie_device_info();
+	struct edma_chn_info *edma_chp = get_edma_channel_info(0);
+	skw_pcie_slp_feature_en(priv->boot_data->slp_disable_addr,
+			priv->boot_data->slp_disable);
+
+	dl_req_cnt = (priv->boot_data->iram_dl_size / 0xffff) + ((!!(priv->boot_data->iram_dl_size % 0xffff)) ? 1 : 0);
+	dl_req_cnt += (priv->boot_data->dram_dl_size / 0xffff) + ((!!(priv->boot_data->dram_dl_size % 0xffff)) ? 1 : 0);
+	//PCIE_DBG("dl_req_cnt=%d \n", dl_req_cnt);
+	//print_hex_dump(KERN_ERR, "PACKET ERR:", 0, 16, 1, boot_data->iram_img_data, 0x100, 1);
+
+	PCIE_INFO("1. PCIe BOOT.DEUBG..LINE %d \n", __LINE__);
+	edma_chp->map_skb_addr = dma_map_single(&priv->dev->dev, (void *)priv->boot_data->dram_img_data,
+			priv->boot_data->dram_dl_size, DMA_TO_DEVICE);
+	//PCIE_DBG("2. PCIe FIRST BOOT... \n");
+
+	edma_chp->map_pld_addr = dma_map_single(&priv->dev->dev, (void *)priv->boot_data->iram_img_data,
+			priv->boot_data->iram_dl_size, DMA_TO_DEVICE);
+	//PCIE_DBG("3. PCIe FIRST BOOT... \n");
+
+	skw_pcie_host_irq_init(priv->boot_data->gpio_in);
+	skw_reinit_completion(priv->download_done);
+	ret |= pcie_download_fw(priv->boot_data->iram_dl_addr, priv->boot_data->iram_img_data, priv->boot_data->iram_dl_size);
+	ret |= pcie_download_fw(priv->boot_data->dram_dl_addr, priv->boot_data->dram_img_data, priv->boot_data->dram_dl_size);
+	ret |=skw_check_cp_ready();
+	PCIE_INFO("1. PCIe BOOT.DEUBG..LINE %d \n", __LINE__);
+	if(ret !=0)
+		goto FAIL;
+	return 0;
+FAIL:
+	PCIE_ERR("line:%d  fail ret=%d\n",__LINE__, ret);
+	return ret;
+}
+
+int skw_pcie_cp_service_ops(int service_ops)
+{
+	int ret =0;
+	switch(service_ops)
+	{
+		case SKW_WIFI_START:
+			ret=skw_WIFI_service_start();
+			skw_pcie_dbg("-----WIFI SERIVCE START\n");
+		break;
+		case SKW_WIFI_STOP:
+			ret =skw_WIFI_service_stop();
+			skw_pcie_dbg("----WIFI SERVICE---STOP\n");
+		break;
+		case SKW_BT_START:
+		{
+			ret=skw_BT_service_start();
+			skw_pcie_dbg("-----BT SERIVCE --START\n");
+		}
+		break;
+		case SKW_BT_STOP:
+			ret =skw_BT_service_stop();
+			skw_pcie_dbg("-----BT SERVICE --STOP\n");
+		break;
+		default:
+			skw_pcie_err("service not support %d !\n", service_ops);
+		break;
+	}
+	return ret;
+}
+
+int skw_boot_loader(struct seekwave_device *boot_data)
+{
+	int ret =0;
+	struct wcn_pcie_info *priv= get_pcie_device_info();
+	struct edma_chn_info *edma_chp = get_edma_channel_info(0);
+	priv->boot_data= boot_data;
+	if(boot_data->dl_module == RECOVERY_BOOT&&boot_data->first_dl_flag){
+		schedule_delayed_work(&priv->skw_pcie_recovery_work , msecs_to_jiffies(2000));
+		//skw_recovery_mode();
+	}
+	PCIE_DBG("iram_size=0x%x, iram_addr:0x%x, dram_size=0x%x, dram_addr=0x%x\n",
+		boot_data->iram_dl_size,
+		boot_data->iram_dl_addr,
+		boot_data->dram_dl_size,
+		boot_data->dram_dl_addr);
+
+	PCIE_DBG("iram_img_data=0x%p, dram_img_data:0x%p\n",
+		boot_data->iram_img_data,
+		boot_data->dram_img_data);
+
+	priv->chip_en = boot_data->chip_en;
+	if (!boot_data->first_dl_flag && boot_data->iram_dl_size && boot_data->dram_dl_size) {
+
+		if (boot_data->chip_en > 0){
+			gpio_set_value(boot_data->chip_en, 1);
+			priv->chip_en = boot_data->chip_en;
+		}
+		PCIE_INFO("PCIe FIRST BOOT... \n");
+		priv->iram_dl_size = boot_data->iram_dl_size;
+		priv->dram_dl_size = boot_data->dram_dl_size;
+		priv->iram_crc_offset = boot_data->iram_crc_offset;
+		priv->dram_crc_offset = boot_data->dram_crc_offset;
+		priv->iram_crc = boot_data->iram_crc_val;
+		priv->dram_crc = boot_data->dram_crc_val;
+		priv->iram_crc_en = 0;//boot_data->iram_crc_en;
+		priv->dram_crc_en = 0;//boot_data->dram_crc_en;
+		skw_pcie_host_irq_init(boot_data->gpio_in);
+		dl_req_cnt = (boot_data->iram_dl_size / 0xffff) + ((!!(boot_data->iram_dl_size % 0xffff)) ? 1 : 0);
+		dl_req_cnt += (boot_data->dram_dl_size / 0xffff) + ((!!(boot_data->dram_dl_size % 0xffff)) ? 1 : 0);
+		//PCIE_DBG("dl_req_cnt=%d \n", dl_req_cnt);
+		//print_hex_dump(KERN_ERR, "PACKET ERR:", 0, 16, 1, boot_data->iram_img_data, 0x100, 1);
+
+		//PCIE_DBG("1. PCIe FIRST BOOT... \n");
+		edma_chp->map_skb_addr = dma_map_single(&priv->dev->dev, (void *)boot_data->dram_img_data,
+				boot_data->dram_dl_size, DMA_TO_DEVICE);
+		//PCIE_DBG("2. PCIe FIRST BOOT... \n");
+
+		edma_chp->map_pld_addr = dma_map_single(&priv->dev->dev, (void *)boot_data->iram_img_data,
+				boot_data->iram_dl_size, DMA_TO_DEVICE);
+		//PCIE_DBG("3. PCIe FIRST BOOT... \n");
+		ret |= pcie_download_fw(boot_data->iram_dl_addr, boot_data->iram_img_data, boot_data->iram_dl_size);
+		ret |= pcie_download_fw(boot_data->dram_dl_addr, boot_data->dram_img_data, boot_data->dram_dl_size);
+		ret |=skw_check_cp_ready();
+	} else {
+		PCIE_INFO("The FW BOOT From CP!!!!\n");
+	}
+
+	if (!boot_data->first_dl_flag && !ret) {
+		skw_pcie_bind_wifi_driver(priv->dev);
+		skw_pcie_bind_bt_driver(priv->dev);
+	}
+	ret = skw_pcie_cp_service_ops(boot_data->service_ops);
+	if(ret < 0)
+		return -1;
+	else
+		return 0;
+}
+
+void reboot_to_change_bt_uart1(char *mode)
+{
+	struct wcn_pcie_info *priv= get_pcie_device_info();
+	struct seekwave_device *boot_data = priv->boot_data;
+	u32 *data = (u32 *) &boot_data->iram_img_data[boot_data->head_addr-4];
+
+	if(data[0] & 0x80000000)
+		data[0] |=  0x0000008;
+	else
+		data[0] = 0x80000008;
+	//skw_recovery_mode();
+	send_modem_assert_command();
+
+}
+
+int skw_reset_bus_dev(void)
+{
+	return 0;
+}
+void get_bt_antenna_mode(char *mode)
+{
+	struct wcn_pcie_info *priv= get_pcie_device_info();
+	struct seekwave_device *boot_data = priv->boot_data;
+	u32 bt_antenna = boot_data->bt_antenna;
+
+	if(bt_antenna==0)
+		return;
+	bt_antenna--;
+	if(!mode)
+		return;
+	if (bt_antenna)
+		sprintf(mode,"bt_antenna : alone\n");
+	else
+		sprintf(mode,"bt_antenna : share\n");
+}
+
+void reboot_to_change_bt_antenna_mode(char *mode)
+{
+	struct wcn_pcie_info *priv= get_pcie_device_info();
+	struct seekwave_device *boot_data = priv->boot_data;
+	u32 *data = (u32 *) &boot_data->iram_img_data[boot_data->head_addr-4];
+	u32 bt_antenna;
+
+	if(boot_data->bt_antenna == 0)
+		return;
+	bt_antenna = boot_data->bt_antenna - 1;
+		bt_antenna = 1 - bt_antenna;
+	data[0] = (bt_antenna) | 0x80000000;
+	if(!mode)
+		return;
+	if (bt_antenna==1) {
+		boot_data->bt_antenna = 2;
+		sprintf(mode,"bt_antenna : alone\n");
+	} else {
+		boot_data->bt_antenna = 1;
+		sprintf(mode,"bt_antenna : share\n");
+	}
+	send_modem_assert_command();
+}
+void *skw_get_bus_dev(void)
+{
+	struct wcn_pcie_info *priv = get_pcie_device_info();
+	return &priv->dev->dev;
+}
+
+static int skw_check_cp_ready(void)
+{
+	struct wcn_pcie_info *priv = get_pcie_device_info();
+
+	//skw_reinit_completion(priv->download_done);
+	PCIE_INFO("check CP-ready Enter!!\n");
+	if (wait_for_completion_timeout(&priv->download_done,
+		msecs_to_jiffies(3000)) == 0) {
+		 PCIE_ERR("check CP-ready time out\n");
+		 return -ETIME;
+	}
+	return 0;
+}
+
diff --git a/drivers/misc/seekwaveplatform_v20/pcie/skw_pcie_debugfs.c b/drivers/misc/seekwaveplatform_v20/pcie/skw_pcie_debugfs.c
new file mode 100755
index 000000000000..68f3e6f3bcbc
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/pcie/skw_pcie_debugfs.c
@@ -0,0 +1,60 @@
+/*****************************************************************************
+ * Copyright(c) 2020-2030  Seekwave Corporation.
+ * SEEKWAVE TECH LTD..CO
+ *Seekwave Platform the pcie log debug fs
+ *FILENAME:skw_pcie_debugfs.c
+ *DATE:2022-04-11
+ *MODIFY:
+ *
+ **************************************************************************/
+
+#include "skw_pcie_debugfs.h"
+#include "skw_pcie_log.h"
+#include "skw_pcie_drv.h"
+
+static struct dentry *skw_pcie_root_dir;
+
+static ssize_t skw_pcie_default_read(struct file *fp, char __user *buf, size_t len,
+				loff_t *offset)
+{
+	return 0;
+}
+
+static ssize_t skw_pcie_state_write(struct file *fp, const char __user *buffer,
+				size_t len, loff_t *offset)
+{
+	return len;
+}
+
+static const struct file_operations skw_pcie_state_fops = {
+	.open = skw_pcie_default_open,
+	.read = skw_pcie_default_read,
+	.write = skw_pcie_state_write,
+};
+
+struct dentry *skw_pcie_add_debugfs(const char *name, umode_t mode, void *data,
+				   const struct file_operations *fops)
+{
+	skw_pcie_dbg("%s:name: %s\n",__func__,name);
+
+	return debugfs_create_file(name, mode, skw_pcie_root_dir, data, fops);
+}
+
+int skw_pcie_debugfs_init(void)
+{
+	skw_pcie_root_dir = debugfs_create_dir("skwpcie", NULL);
+	if (IS_ERR(skw_pcie_root_dir))
+		return PTR_ERR(skw_pcie_root_dir);
+
+	// skw_pcie_add_debugfs("state", 0666, wiphy, &skw_pcie_state_fops);
+	// skw_pcie_add_debugfs("log_level", 0444, wiphy, &skw_pcie_log_fops);
+
+	return 0;
+}
+
+void skw_pcie_debugfs_deinit(void)
+{
+	skw_pcie_dbg("%s :traced\n", __func__);
+
+	debugfs_remove_recursive(skw_pcie_root_dir);
+}
diff --git a/drivers/misc/seekwaveplatform_v20/pcie/skw_pcie_debugfs.h b/drivers/misc/seekwaveplatform_v20/pcie/skw_pcie_debugfs.h
new file mode 100755
index 000000000000..d1e58c976a3a
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/pcie/skw_pcie_debugfs.h
@@ -0,0 +1,29 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2020-2030  Seekwave Corporation.
+ *
+ *****************************************************************************/
+#ifndef __SKW_PCIE_DEBUGFS_H__
+#define __SKW_PCIE_DEBUGFS_H__
+
+#include <linux/fs.h>
+#include <linux/debugfs.h>
+
+static inline int skw_pcie_default_open(struct inode *node, struct file *fp)
+{
+	fp->private_data = node->i_private;
+	return 0;
+}
+
+static inline void  skw_pcie_remove_debugfs(struct dentry *dentry)
+{
+	debugfs_remove(dentry);
+}
+
+struct dentry *skw_pcie_add_debugfs(const char *name, umode_t mode, void *data,
+				   const struct file_operations *fops);
+
+int skw_pcie_debugfs_init(void);
+void skw_pcie_debugfs_deinit(void);
+
+#endif
diff --git a/drivers/misc/seekwaveplatform_v20/pcie/skw_pcie_drv.c b/drivers/misc/seekwaveplatform_v20/pcie/skw_pcie_drv.c
new file mode 100755
index 000000000000..0866848e50c5
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/pcie/skw_pcie_drv.c
@@ -0,0 +1,887 @@
+/*
+ * Copyright (C) 2022 Seekwave Tech Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/platform_device.h>
+#include <uapi/linux/sched/types.h>
+#include <linux/scatterlist.h>
+#include <linux/dma-mapping.h>
+#include <linux/version.h>
+#include <linux/semaphore.h>
+#include <linux/pm_runtime.h>
+#include <linux/kthread.h>
+#include <linux/module.h>
+#include <linux/list.h>
+#include <linux/err.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <linux/iopoll.h>
+#include <linux/dma-mapping.h>
+#include <linux/firmware.h>
+#include "skw_edma_drv.h"
+#include "skw_pcie_drv.h"
+#include "skw_pcie_log.h"
+#include "skw_edma_reg.h"
+#include "skw_pcie_debugfs.h"
+
+#define SWT6652_V2
+//#define SBDRSM_DEBUG
+
+static struct wcn_pcie_info *g_pcie_dev;
+
+static int pcie_int = 1;
+module_param(pcie_int, int, S_IRUGO);
+MODULE_PARM_DESC(pcie_int, "1-msi, 2-legacy, 3-msix, if no param, msi default");
+
+
+extern void skw_pcie_exception_work(struct work_struct *work);
+
+struct wcn_pcie_info *get_pcie_device_info(void)
+{
+	return g_pcie_dev;
+}
+
+static int inline is_msi_irq_wifi_takeover(struct wcn_pcie_info *priv, int irq)
+{
+	int ch_id;
+
+	if (priv->msix_en == 1) {
+		ch_id = irq/2;
+	} else
+		ch_id = irq;
+
+	if (ch_id == EDMA_WIFI_TX0_FREE_ADDR || ch_id == EDMA_WIFI_TX1_FREE_ADDR
+		|| ch_id == EDMA_WIFI_RX0_PKT_ADDR || ch_id == EDMA_WIFI_RX1_PKT_ADDR
+		|| ch_id == EDMA_WIFI_RX0_FILTER_DATA_CHN || ch_id == EDMA_WIFI_RX1_FILTER_DATA_CNH
+		|| ch_id == EDMA_WIFI_TX0_PACKET_ADDR || ch_id == EDMA_WIFI_TX1_PACKET_ADDR)
+
+		return 1;
+	else
+		return 0;
+}
+
+static int skw_pcie_msi_irq(int irq, void *arg)
+{
+	struct wcn_pcie_info *priv = get_pcie_device_info();
+
+	//PCIE_DBG("vector=%d\n", irq);
+	irq = *(u16 *)arg;
+	PCIE_DBG("irq_num=%d\n", irq);
+	//skw_edma_lock_event();
+	if (is_msi_irq_wifi_takeover(priv, irq))
+		msi_irq_wifi_takeover_handler(irq);
+	else
+		msi_edma_channel_irq_handler(irq);
+
+	return IRQ_HANDLED;
+}
+
+static int legacy_pcie_irq_handle(struct wcn_pcie_info *priv)
+{
+	u32 val;
+
+	val = (skw_pcie_read32(0x40190050) & 0xff00) >> 8;
+	PCIE_DBG("pcie legacy int sts=0x%x\n", val);
+	skw_pcie_write32(0x4019004c, val);
+	return IRQ_HANDLED;
+}
+
+static int pcie_legacy_irq(int irq, void *arg)
+{
+	struct wcn_pcie_info *priv = arg;
+
+	PCIE_DBG("irq_num=%d\n", irq);
+	if (skw_pcie_read32(0x40188004))
+		legacy_edma_irq_handle();
+	else if (skw_pcie_read32(0x40190050) & 0xff00)
+		legacy_pcie_irq_handle(priv);
+
+	return IRQ_HANDLED;
+}
+
+static int ep_address_mapping(struct wcn_pcie_info *priv)
+{
+	u64 val;
+	//ib: map 2M(0x2000000) (0x40000000-0x401fffff)
+	val = priv->mem_pciaddr;
+	writel_relaxed((val & 0xffff0000) | 20, priv->pciaux + IBREG0_OFFSET_ADDR + 4);
+	writel_relaxed((val >> 32) & 0xffffffff, priv->pciaux + IBREG0_OFFSET_ADDR + 8);
+	writel_relaxed(0x40000000, priv->pciaux + IBREG0_OFFSET_ADDR + 0xc);
+	writel_relaxed(1, priv->pciaux + IBREG0_OFFSET_ADDR + 0);
+
+#ifdef SWT6652_V2
+	//ob0
+	writel_relaxed(31, priv->pciaux + OBREG0_OFFSET_ADDR + 4);
+	writel_relaxed(0x00000080, priv->pciaux + OBREG0_OFFSET_ADDR + 8);
+	writel_relaxed(0x00000000, priv->pciaux + OBREG0_OFFSET_ADDR + 0xc);
+	writel_relaxed(0x00000000, priv->pciaux + OBREG0_OFFSET_ADDR + 0x10);
+	writel_relaxed(0xff, priv->pciaux + OBREG0_OFFSET_ADDR + 0x18);
+	writel_relaxed(1, priv->pciaux + OBREG0_OFFSET_ADDR + 0);
+#else
+	//ob0
+	writel_relaxed(31, priv->pciaux + OBREG0_OFFSET_ADDR + 4);
+	writel_relaxed(0x00000080, priv->pciaux + OBREG0_OFFSET_ADDR + 8);
+	writel_relaxed(0x00000000, priv->pciaux + OBREG0_OFFSET_ADDR + 0xc);
+	writel_relaxed(0x00000000, priv->pciaux + OBREG0_OFFSET_ADDR + 0x10);
+	writel_relaxed(1, priv->pciaux + OBREG0_OFFSET_ADDR + 0);
+
+	//ob1
+	writel_relaxed(31, priv->pciaux + OBREG1_OFFSET_ADDR + 4);
+	writel_relaxed(0x00000081, priv->pciaux + OBREG1_OFFSET_ADDR + 8);
+	writel_relaxed(0x00000000, priv->pciaux + OBREG1_OFFSET_ADDR + 0xc);
+	writel_relaxed(0x00000001, priv->pciaux + OBREG1_OFFSET_ADDR + 0x10);
+	writel_relaxed(1, priv->pciaux + OBREG1_OFFSET_ADDR + 0);
+#endif
+	return 0;
+}
+
+
+u32 skw_pcie_read32(u32 reg_addr)
+{
+	struct wcn_pcie_info *priv = get_pcie_device_info();
+	char *address = priv->pcimem;
+
+	reg_addr -= 0x40000000;
+	address += reg_addr;
+	rmb();
+	return readl_relaxed(address);
+}
+
+void skw_pcie_write32(u32 reg_addr, u32 value)
+{
+	struct wcn_pcie_info *priv = get_pcie_device_info();
+	char *address = priv->pcimem;
+
+	reg_addr -= 0x40000000;
+	address += reg_addr;
+	writel_relaxed(value, address);
+	wmb();
+}
+
+void skw_pcie_setbit(u32 reg_addr, u32 bits)
+{
+	int val;
+	struct wcn_pcie_info *priv = get_pcie_device_info();
+	char *address = priv->pcimem;
+
+	reg_addr -= 0x40000000;
+	address += reg_addr;
+	val = readl_relaxed(address);
+	val |= bits;
+	writel_relaxed(val, address);
+}
+
+void skw_pcie_clrbit(u32 reg_addr, u32 bits)
+{
+	int val;
+	struct wcn_pcie_info *priv = get_pcie_device_info();
+	char *address = priv->pcimem;
+
+	reg_addr -= 0x40000000;
+	address += reg_addr;
+	val = readl_relaxed(address);
+	val &= ~bits;
+	writel_relaxed(val, address);
+}
+
+u64 edma_phyaddr_to_pcieaddr(u64 phy_addr)
+{
+	u64 val;
+
+	val = 0x8000000000 + phy_addr;
+	return val;
+}
+
+u64 edma_virtaddr_to_pcieaddr(void *virt_addr)
+{
+	u64 val;
+	u64 phy_addr;
+
+	phy_addr = virt_to_phys(virt_addr);
+	val = 0x8000000000 + phy_addr;
+	return val;
+}
+
+u64 edma_pcieaddr_to_phyaddr(u64 phy_addr)
+{
+	u64 val;
+
+	val = phy_addr - 0x8000000000;
+	return val;
+}
+
+u64 edma_pcieaddr_to_virtaddr(u64 phy_addr)
+{
+	u64 val;
+	u64 virt_addr;
+
+	val = phy_addr - 0x8000000000;
+	virt_addr = (u64)phys_to_virt(val);
+	return virt_addr;
+}
+
+static void skw_pcie_remove(struct pci_dev *pdev)
+{
+	int i;
+	struct wcn_pcie_info *priv;
+
+	PCIE_DBG("[+]\n");
+	priv = (struct wcn_pcie_info *) pci_get_drvdata(pdev);
+
+	skw_edma_deinit();
+
+	if (priv->legacy_en == 1) {
+		PCIE_INFO("free INTx int");
+		free_irq(priv->irq, (void *)priv);
+	}
+	if (priv->msi_en == 1) {
+		PCIE_INFO("free MSI");
+#ifndef CONFIG_SKW_MSI_AS_LEGACY
+		for (i = 0; i < priv->irq_num; i++)
+			free_irq(priv->irq + i, &priv->msix_vec_idx[i]);
+#else
+		free_irq(priv->irq, (void *)priv);
+#endif
+		pci_disable_msi(pdev);
+	}
+	if (priv->msix_en == 1) {
+		PCIE_INFO("free MSI-X");
+		for (i = 0; i < priv->irq_num; i++)
+			free_irq(priv->msix[i].vector, &priv->msix[i].entry);
+
+		pci_disable_msix(pdev);
+		kfree(priv->msix);
+	}
+
+	free_irq(priv->gpio_irq_num, NULL);
+	disable_irq_wake(priv->gpio_irq_num);
+
+	iounmap(priv->pcimem);
+	iounmap(priv->pciaux);
+	pci_release_regions(pdev);
+	pci_set_drvdata(pdev, NULL);
+	pci_disable_device(pdev);
+	skw_pcie_remove_loopcheck_thread(5);
+	PCIE_DBG("[-]\n");
+}
+
+int get_service_busy_sts(void)
+{
+	int ret;
+	u32 status;
+	struct wcn_pcie_info *priv = get_pcie_device_info();
+
+	ret = readl_poll_timeout(priv->pcimem + 0x108160,
+				 status, ((status & WIFI_DO_SUSPEND_MASK) == 0), 10, 2000);
+	if (ret) {
+		PCIE_ERR("Service doesn't allow suspend!!!\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+int skw_notify_ep_enter_l2(void)
+{
+	u32 val, status;
+	int ret;
+	struct wcn_pcie_info *priv = get_pcie_device_info();
+
+	val = skw_pcie_read32(SKW_CP_PMU_SW_REG);
+	val &= ~L2_SHAKE_MASK;
+	val |= 0xd2;
+	skw_pcie_write32(SKW_CP_PMU_SW_REG, val);
+	ret = readl_poll_timeout(priv->pcimem + 0x108160,
+				 status, ((status & L2_SHAKE_MASK) == 0xd2), 5, 100);
+	if (ret) {
+		PCIE_ERR("Failed to read SKW_CP_PMU_SW_REG\n");
+		return -1;
+	}
+	/* for cp no edma req */
+	mdelay(1);
+	return 0;
+}
+
+void skw_notify_ep_exit_l2(void)
+{
+	u32 val;
+
+	val = skw_pcie_read32(SKW_CP_PMU_SW_REG);
+	val &= ~L2_SHAKE_MASK;
+	skw_pcie_write32(SKW_CP_PMU_SW_REG, val);
+}
+
+static int skw_ep_suspend(struct device *dev)
+{
+	int ret;
+#ifndef SWT6652_V2
+	int i;
+	int pba_entries_num;
+	u32 pba_table_offset;
+	u8 pba_bir;
+	u32 val;
+#endif
+
+	struct pci_dev *pdev = to_pci_dev(dev);
+	struct wcn_pcie_info *priv = pci_get_drvdata(pdev);
+
+	if (!pdev)
+		return -ENODEV;
+
+	PCIE_INFO("[+]\n");
+
+	ret = get_service_busy_sts();
+	if (ret)
+		return -EBUSY;
+
+	/* notify CP enter L2 */
+	ret = skw_notify_ep_enter_l2();
+	if (ret)
+		goto busy;
+
+	/* pause edma */
+	ret = skw_edma_pause();
+	if (ret) {
+		skw_edma_restore();
+		goto busy;
+	}
+#ifndef SWT6652_V2
+	/* close L1sub */
+		/* disable L1SS */
+	pci_read_config_dword(pdev, pdev->l1ss + PCI_L1SS_CTL1, &val);
+	val &= ~PCI_L1SS_CTL1_L1SS_MASK;
+	pci_write_config_dword(pdev, pdev->l1ss + PCI_L1SS_CTL1, val);
+		/* disable L1 Entry & CLKREQ */
+	pcie_capability_clear_and_set_word(pdev, PCI_EXP_LNKCTL,
+					PCI_EXP_LNKCTL_ASPMC | PCI_EXP_LNKCTL_CLKREQ_EN, 0);
+
+	/* clear PBA */
+	pci_read_config_dword(pdev, pdev->msix_cap + PCI_MSIX_PBA,
+			      &pba_table_offset);
+	PCIE_INFO("pdev->msix_cap=0x%x\n", pdev->msix_cap);
+	PCIE_INFO("pba_table_offset=0x%x\n", pba_table_offset);
+	pba_bir = (u8)(pba_table_offset & PCI_MSIX_PBA_BIR);
+
+	pba_entries_num = (priv->irq_num % 64)?(priv->irq_num/64 + 1):(priv->irq_num/64);
+	PCIE_INFO("pba_entries_num=0x%x\n", pba_entries_num);
+	PCIE_INFO("priv->irq_num=0x%x\n", priv->irq_num);
+
+	for (i=0;i<pba_entries_num*2;i++) {
+		PCIE_INFO("1. pba[%d]=0x%08x\n", i, readl_relaxed(priv->pciaux+ pba_table_offset + i*4));
+		writel_relaxed(0, priv->pciaux + pba_table_offset + i*4);
+		PCIE_INFO("2. pba[%d]=0x%08x\n", i, readl_relaxed(priv->pciaux+ pba_table_offset + i*4));
+	}
+#endif
+	pci_save_state(to_pci_dev(dev));
+	priv->saved_state = pci_store_saved_state(to_pci_dev(dev));
+	ret = pci_enable_wake(pdev, PCI_D3hot, 1);
+	PCIE_INFO("pci_enable_wake(PCI_D3hot) ret %d\n", ret);
+	ret = pci_set_power_state(pdev, PCI_D3hot);
+	PCIE_INFO("pci_set_power_state(PCI_D3hot) ret %d\n", ret);
+
+#ifdef SBDRSM_DEBUG
+	pci_read_config_dword(pdev, pdev->l1ss + PCI_L1SS_CTL1, &val);
+	PCIE_INFO("[PCI_L1SS_CTL1]=0x%x\n", val);
+	pcie_capability_read_dword(pdev, PCI_EXP_LNKCTL, &val);
+	PCIE_INFO("[PCI_EXP_LNKCTL]=0x%x\n", val);
+#endif
+	PCIE_INFO("[-]\n");
+	return 0;
+busy:
+	skw_notify_ep_exit_l2();
+	return -EBUSY;
+}
+
+static int skw_ep_resume(struct device *dev)
+{
+	int ret;
+#ifndef SWT6652_V2
+	int i;
+	u32 val;
+	u32 pba_table_offset;
+	int pba_entries_num;
+	u8 pba_bir;
+#endif
+	struct pci_dev *pdev = to_pci_dev(dev);
+	struct wcn_pcie_info *priv = pci_get_drvdata(pdev);
+
+	PCIE_INFO("[+]\n");
+
+	if (!pdev) {
+		return -ENODEV;
+	}
+
+#ifndef SWT6652_V2
+	pci_read_config_dword(pdev, pdev->msix_cap + PCI_MSIX_PBA,
+			      &pba_table_offset);
+	PCIE_INFO("pdev->msix_cap=0x%x\n", pdev->msix_cap);
+	PCIE_INFO("pba_table_offset=0x%x\n", pba_table_offset);
+	pba_bir = (u8)(pba_table_offset & PCI_MSIX_PBA_BIR);
+	pba_entries_num = (priv->irq_num % 64)?(priv->irq_num/64 + 1):(priv->irq_num/64);
+	for (i=0;i<pba_entries_num*2;i++) {
+		//writel_relaxed(0,priv->pciaux + pba_table_offset + i*4);
+		PCIE_INFO("pba[%d]=0x%08x\n", i, readl_relaxed(priv->pciaux + pba_table_offset + i*4));
+	}
+#endif
+	pci_load_and_free_saved_state(to_pci_dev(dev), &priv->saved_state);
+#ifdef SBDRSM_DEBUG
+	pci_read_config_dword(pdev, pdev->l1ss + PCI_L1SS_CTL1, &val);
+	PCIE_INFO("[PCI_L1SS_CTL1]=0x%x\n", val);
+	pcie_capability_read_dword(pdev, PCI_EXP_LNKCTL, &val);
+	PCIE_INFO("[PCI_EXP_LNKCTL]=0x%x\n", val);
+#endif
+	pci_restore_state(to_pci_dev(dev));
+#ifdef SBDRSM_DEBUG
+	pci_read_config_dword(pdev, pdev->l1ss + PCI_L1SS_CTL1, &val);
+	PCIE_INFO("[PCI_L1SS_CTL1]=0x%x\n", val);
+	pcie_capability_read_dword(pdev, PCI_EXP_LNKCTL, &val);
+	PCIE_INFO("[PCI_EXP_LNKCTL]=0x%x\n", val);
+#endif
+	ret = pci_set_power_state(pdev, PCI_D0);
+#ifdef SBDRSM_DEBUG
+	pci_read_config_dword(pdev, pdev->l1ss + PCI_L1SS_CTL1, &val);
+	PCIE_INFO("[PCI_L1SS_CTL1]=0x%x\n", val);
+	pcie_capability_read_dword(pdev, PCI_EXP_LNKCTL, &val);
+	PCIE_INFO("[PCI_EXP_LNKCTL]=0x%x\n", val);
+#endif
+	PCIE_INFO("pci_set_power_state(PCI_D0) ret %d\n", ret);
+	ret = pci_enable_wake(pdev, PCI_D0, 0);
+#ifdef SBDRSM_DEBUG
+	pci_read_config_dword(pdev, pdev->l1ss + PCI_L1SS_CTL1, &val);
+	PCIE_INFO("[PCI_L1SS_CTL1]=0x%x\n", val);
+	pcie_capability_read_dword(pdev, PCI_EXP_LNKCTL, &val);
+	PCIE_INFO("[PCI_EXP_LNKCTL]=0x%x\n", val);
+#endif
+	PCIE_INFO("pci_enable_wake(PCI_D0) ret %d\n", ret);
+
+	ep_address_mapping(priv);
+
+#ifdef SBDRSM_DEBUG
+	pci_read_config_dword(pdev, pdev->l1ss + PCI_L1SS_CTL1, &val);
+	PCIE_INFO("[PCI_L1SS_CTL1]=0x%x\n", val);
+	pcie_capability_read_dword(pdev, PCI_EXP_LNKCTL, &val);
+	PCIE_INFO("[PCI_EXP_LNKCTL]=0x%x\n", val);
+#endif
+	skw_edma_restore();
+	skw_notify_ep_exit_l2();
+
+#ifndef SWT6652_V2
+	/* enable L1sub */
+	//enable L1SS
+	pci_read_config_dword(pdev, pdev->l1ss + PCI_L1SS_CTL1, &val);
+	val |= PCI_L1SS_CTL1_L1SS_MASK;
+	pci_write_config_dword(pdev, pdev->l1ss + PCI_L1SS_CTL1, val);
+
+	//enable L1 Entry & CLKREQ
+	pcie_capability_clear_and_set_word(pdev, PCI_EXP_LNKCTL,
+					0,
+					PCI_EXP_LNKCTL_ASPMC | PCI_EXP_LNKCTL_CLKREQ_EN);
+#endif
+#ifdef SBDRSM_DEBUG
+	pci_read_config_dword(pdev, pdev->l1ss + PCI_L1SS_CTL1, &val);
+	PCIE_INFO("[PCI_L1SS_CTL1]=0x%x\n", val);
+	pcie_capability_read_dword(pdev, PCI_EXP_LNKCTL, &val);
+	PCIE_INFO("[PCI_EXP_LNKCTL]=0x%x\n", val);
+#endif
+	PCIE_INFO("[-]\n");
+	return 0;
+}
+
+irqreturn_t skw_gpio_irq_handler(int irq, void *dev_id) //interrupt
+{
+	return IRQ_HANDLED;
+}
+
+int skw_pcie_host_irq_init(unsigned int irq_gpio_num)
+{
+	struct wcn_pcie_info *priv = get_pcie_device_info();
+	int ret = 0;
+
+	PCIE_INFO("gpio_pewake:%d\n", irq_gpio_num);
+	if (irq_gpio_num < 0)
+		return -EINVAL;
+
+	priv->gpio_irq_num = gpio_to_irq(irq_gpio_num);
+	priv->irq_trigger_type = IRQF_TRIGGER_FALLING;
+	if (priv->gpio_irq_num) {
+		ret = request_irq(priv->gpio_irq_num, skw_gpio_irq_handler,
+				priv->irq_trigger_type | IRQF_ONESHOT, "skw-pewake", NULL);
+		if (ret != 0) {
+			free_irq(priv->gpio_irq_num, NULL);
+			PCIE_ERR("request gpio irq fail ret=%d\n", ret);
+			return -1;
+		} else {
+			PCIE_DBG("gpio request_irq=%d!\n", priv->gpio_irq_num);
+		}
+	}
+	enable_irq_wake(priv->gpio_irq_num);
+	return ret;
+}
+
+void skw_pcie_rescan_bus(void)
+{
+	struct wcn_pcie_info *priv = get_pcie_device_info();
+
+	PCIE_INFO("[+]\n");
+	pci_stop_and_remove_bus_device_locked(priv->dev);
+	PCIE_INFO("\n");
+	pci_lock_rescan_remove();
+	PCIE_INFO("\n");
+	pci_rescan_bus(priv->dev->bus);
+	PCIE_INFO("\n");
+	pci_unlock_rescan_remove();
+	PCIE_INFO("\n");
+	PCIE_INFO("[-]\n");
+}
+
+void skw_pcie_recovery_work(struct work_struct *work)
+{
+	int ret;
+	struct wcn_pcie_info *priv = get_pcie_device_info();
+
+	skw_pcie_rescan_bus();
+
+	ret = skw_pcie_boot_cp(RECOVERY_BOOT);
+	if(ret!=0){
+		PCIE_ERR("CP RESET fail \n");
+		return;
+	}
+	skw_pcie_bind_wifi_driver(priv->dev);
+	PCIE_INFO("SKW PCIe Recovery ok\n");
+}
+
+int check_chipid(void)
+{
+	int ret=0;
+	unsigned int tmp_chipid0;
+	unsigned int tmp_chipid1;
+	unsigned int tmp_chipid2;
+	unsigned int tmp_chipid3;
+	struct wcn_pcie_info *priv = get_pcie_device_info();
+
+	tmp_chipid0 =  skw_pcie_read32(SKW_CHIP_ID0);
+	tmp_chipid1 =  skw_pcie_read32(SKW_CHIP_ID1);
+	tmp_chipid2 =  skw_pcie_read32(SKW_CHIP_ID2);
+	tmp_chipid3 =  skw_pcie_read32(SKW_CHIP_ID3);
+	if (tmp_chipid0 ==0x33365653 && tmp_chipid1==0x3631) {
+		//sprintf((char *)priv->chip_id, "%s", "SV6316");
+		memcpy(&priv->chip_id, &tmp_chipid0,4);
+		memcpy(&priv->chip_id[1], &tmp_chipid1,4);
+		memcpy(&priv->chip_id[2], &tmp_chipid2,4);
+		memcpy(&priv->chip_id[3], &tmp_chipid3,4);
+		print_hex_dump(KERN_ERR, "CHIP ID: ", 0, 16, 1,priv->chip_id, 32, 1);
+	} else {
+		PCIE_ERR("Wrong Chip ID:%s,%s\n",(char *)&tmp_chipid0,(char *)&tmp_chipid1);
+		return -1;
+	}
+
+	if (ret<0) {
+		skw_pcie_err("Get Chip ID fail!\n");
+		return ret;
+	}
+    if (!strncmp((char *)priv->chip_id, "SV6316", 6)){
+            PCIE_INFO("Chip ID:%s\n", (char *)priv->chip_id);
+    }
+
+	PCIE_INFO("Chip ID:%s\n", (char *)priv->chip_id);
+	return 0;
+}
+
+static int skw_pcie_legacy_int_init(struct pci_dev *pdev)
+{
+	int ret = 0;
+	struct wcn_pcie_info *priv = get_pcie_device_info();
+
+	ret = request_irq(priv->irq,
+			(irq_handler_t) (&pcie_legacy_irq),
+			IRQF_SHARED,
+			DRV_NAME, (void *)priv);
+	if (ret) {
+		PCIE_ERR("request_irq(%d), error %d\n", priv->irq, ret);
+		return -1;
+	}
+	PCIE_DBG("request_irq(%d) ok\n", priv->irq);
+
+	return ret;
+}
+
+static int skw_pcie_msi_int_init(struct pci_dev *pdev)
+{
+	int ret = 0;
+	struct wcn_pcie_info *priv = get_pcie_device_info();
+#ifndef CONFIG_SKW_MSI_AS_LEGACY
+	int i;
+
+	priv->irq_num = pci_msi_vec_count(pdev);
+	PCIE_DBG("pci_msix_vec_count ret %d\n", priv->irq_num);
+
+	ret = pci_alloc_irq_vectors(pdev, 1, priv->irq_num, PCI_IRQ_MSI);
+#else
+	ret = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_MSI);
+#endif
+	if (ret < 0) {
+		PCIE_ERR("pci_enable_msi_range err=%d\n", ret);
+		goto err_out;
+	}
+#ifndef CONFIG_SKW_MSI_AS_LEGACY
+	priv->irq = pdev->irq;
+	for (i = 0; i < priv->irq_num; i++) {
+		priv->msix_vec_idx[i] = i;
+		ret = request_irq(priv->irq + i,
+				(irq_handler_t) (&skw_pcie_msi_irq),
+				IRQF_SHARED, DRV_NAME, &priv->msix_vec_idx[i]);
+		if (ret) {
+			PCIE_ERR("request_irq(%d), error %d\n",
+				priv->irq + i, ret);
+			break;
+		}
+		PCIE_DBG("request_irq(%d) ok\n", priv->irq + i);
+	}
+#else /* CONFIG_SKW_MSI_AS_LEGACY */
+#if defined(IRQF_SHARED)
+	priv->irq = pdev->irq;
+	ret = request_irq(pdev->irq, (irq_handler_t) (&pcie_legacy_irq), IRQF_SHARED, DRV_NAME, priv);
+#else /* IRQF_SHARED */
+	ret = request_irq(pdev->irq, (irq_handler_t) (&pcie_legacy_irq), SA_SHIRQ, DRV_NAME, priv);
+#endif /* IRQF_SHARED */
+#endif /* CONFIG_SKW_MSI_AS_LEGACY */
+
+err_out:
+	return ret;
+}
+
+static int skw_pcie_msix_int_init(struct pci_dev *pdev)
+{
+	int ret = 0, i;
+	int vectors;
+	struct wcn_pcie_info *priv = get_pcie_device_info();
+
+	vectors = pci_msix_vec_count(pdev);
+	PCIE_DBG("vectors=0x%x\n", vectors);
+	priv->msix = kzalloc((sizeof(struct msix_entry) * vectors), GFP_KERNEL);
+	if (!priv->msix) {
+		ret = -ENOMEM;
+		goto err_out;
+	}
+	for (i = 0; i < vectors; i++)
+		priv->msix[i].entry = i;
+	priv->irq_num = pci_enable_msix_range(pdev, priv->msix, 1, vectors);
+	if (priv->irq_num < 0) {
+		PCIE_ERR("pci_enable_msix_range %d err\n", priv->irq_num);
+		kfree(priv->msix);
+		goto err_out;
+	}
+	priv->irq = priv->msix[0].vector;
+
+	for (i = 0; i < priv->irq_num; i++) {
+		PCIE_DBG("priv->irq=0x%x\n", priv->irq);
+		PCIE_DBG("priv->irq_num=0x%x\n", priv->irq_num);
+		PCIE_DBG("priv->msix[i].vector=0x%x\n", priv->msix[i].vector);
+		ret = request_irq(priv->msix[i].vector,
+				(irq_handler_t) (&skw_pcie_msi_irq),
+				IRQF_SHARED, DRV_NAME, &priv->msix[i].entry);
+		if (ret) {
+			PCIE_ERR("request_irq(%d), error %d\n",
+				priv->msix[i].vector, ret);
+			break;
+		}
+		PCIE_DBG("request_irq(%d) ok\n", priv->msix[i].vector);
+	}
+err_out:
+	return ret;
+}
+
+static int skw_pcie_probe(struct pci_dev *pdev, const struct pci_device_id *pci_id)
+{
+	struct wcn_pcie_info *priv = get_pcie_device_info();
+	unsigned long mem_len, aux_len;
+	int ret = -ENODEV;
+	int val;
+
+	PCIE_INFO("[+]\n");
+	priv->dev = pdev;
+	pci_set_drvdata(pdev, priv);
+
+	if (pci_enable_device(pdev)) {
+		PCIE_ERR("cannot enable device:%s\n", pci_name(pdev));
+		goto err_out;
+	}
+	pci_set_master(pdev);
+	ret = pci_request_regions(pdev, DRV_NAME);
+	if (ret) {
+		goto err_out;
+	}
+
+	priv->mem_start = pci_resource_start(pdev, 2);
+	mem_len = pci_resource_len(pdev, 2);
+	priv->aux_start = pci_resource_start(pdev, 0);
+	aux_len = pci_resource_len(pdev, 0);
+	pci_read_config_dword(pdev, PCI_BASE_ADDRESS_2, (u32 *)&priv->mem_barl);
+	pci_read_config_dword(pdev, PCI_BASE_ADDRESS_3, (u32 *)&priv->mem_barh);
+	priv->mem_pciaddr = ((priv->mem_barh << 32) | priv->mem_barl) & ~0xf;
+	PCIE_INFO("mem_pciaddr:0x%llx\n", priv->mem_pciaddr);
+
+	priv->pcimem = ioremap(priv->mem_start, mem_len);
+	if (!priv->pcimem) {
+		PCIE_ERR("%s:Couldn't map region %x[%x]",
+			pci_name(pdev), (int)priv->mem_start, (int)mem_len);
+		ret = -1;
+		goto free_region;
+	}
+
+	priv->pciaux = ioremap(priv->aux_start, aux_len);
+	if (!priv->pciaux) {
+		PCIE_ERR("%s:Couldn't map region %x[%x]",
+			pci_name(pdev), (int)priv->aux_start, (int)aux_len);
+		ret = -1;
+		goto free_memmap1;
+	}
+	PCIE_INFO("BAR(0)(auxmem) (0x%llx 0x%lx)\n", priv->aux_start, aux_len);
+	PCIE_INFO("BAR(2)(mem)   [0x%llx 0x%lx)\n", priv->mem_start, mem_len);
+
+	priv->irq = pdev->irq;
+	if (pcie_int == 1)
+		priv->msi_en = 1;
+	else if (pcie_int == 2)
+		priv->legacy_en = 1;
+	else if (pcie_int == 3)
+		priv->msix_en = 1;
+	else
+		priv->msi_en = 1;
+
+	PCIE_DBG("dev->irq %d\n", pdev->irq);
+	PCIE_INFO("legacy %d msi_en %d, msix_en %d\n",
+		priv->legacy_en, priv->msi_en, priv->msix_en);
+
+	if (priv->legacy_en == 1) {
+		ret = skw_pcie_legacy_int_init(pdev);
+		if (ret)
+			goto free_memmap2;
+	} else if (priv->msi_en == 1) {
+		ret = skw_pcie_msi_int_init(pdev);
+		if (ret)
+			goto free_memmap2;
+	} else if (priv->msix_en == 1) {
+		ret = skw_pcie_msix_int_init(pdev);
+		if (ret)
+			goto free_memmap2;
+	}
+
+	device_wakeup_enable(&(pdev->dev));
+	ep_address_mapping(priv);
+	skw_edma_init();
+	init_completion(&priv->download_done);
+	check_chipid();
+	init_completion(&priv->edma_blk_dl_done);
+	skw_pcie_bind_platform_driver(pdev);
+	skw_pcie_create_loopcheck_thread(5);
+	if(priv->cp_state)
+		skw_pcie_bind_bt_driver(priv->dev);
+
+	priv->service_state_map = 0;
+	PCIE_INFO("ok\n");
+	/* fix debug boot issue */
+	val = skw_pcie_read32(0x40100030);
+	val &= ~0xff00;
+	val |= 0x5a00;
+	skw_pcie_write32(0x40100030, val);
+	return 0;
+
+
+free_memmap2:
+	iounmap(priv->pciaux);
+free_memmap1:
+	iounmap(priv->pcimem);
+free_region:
+	pci_release_regions(pdev);
+err_out:
+	kfree(priv);
+
+	return ret;
+}
+
+const struct dev_pm_ops skw_ep_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(skw_ep_suspend, skw_ep_resume)
+};
+
+
+static struct pci_device_id skw_pcie_tbl[] = {
+	{PCI_DEVICE(0x0043, 0x834d)},
+	{PCI_DEVICE(0x1FFE, 0x6316)},
+	{}
+};
+MODULE_DEVICE_TABLE(pci, skw_pcie_tbl);
+
+static struct pci_driver skw_pcie_driver = {
+	.name = "skw_pcie",
+	.id_table = skw_pcie_tbl,
+	.probe = skw_pcie_probe,
+	.remove = skw_pcie_remove,
+	.driver = {
+		.pm = &skw_ep_pm_ops,
+	},
+};
+
+static int __init skw_pcie_init(void)
+{
+	int ret = 0;
+	struct wcn_pcie_info *priv;
+	skw_pcie_debugfs_init();
+	skw_pcie_log_level_init();
+	PCIE_INFO("[+]\n");
+	priv = kzalloc(sizeof(struct wcn_pcie_info), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	g_pcie_dev = priv;
+
+	priv->recovery_dis_state =0;
+	INIT_DELAYED_WORK(&priv->skw_pcie_recovery_work, skw_pcie_recovery_work);
+	INIT_DELAYED_WORK(&priv->skw_except_work, skw_pcie_exception_work);
+	INIT_DELAYED_WORK(&priv->check_dumpdone_work, check_dumpdone_work);
+	ret = pci_register_driver(&skw_pcie_driver);
+	if(!ret)
+		seekwave_boot_init();
+	else
+		PCIE_ERR("pci_register_driver fail %d\n", ret);
+	mutex_init(&priv->except_mutex);
+	mutex_init(&priv->dl_lock);
+	PCIE_INFO("[-]\n");
+
+	return ret;
+}
+
+static void __exit skw_pcie_exit(void)
+{
+	struct wcn_pcie_info *priv = get_pcie_device_info();
+
+	PCIE_INFO("[+]\n");
+	seekwave_boot_exit();
+	mutex_destroy(&priv->except_mutex);
+	mutex_destroy(&priv->dl_lock);
+	pci_unregister_driver(&skw_pcie_driver);
+	cancel_delayed_work_sync(&priv->skw_except_work);
+	cancel_delayed_work_sync(&priv->skw_pcie_recovery_work);
+	cancel_delayed_work_sync(&priv->check_dumpdone_work);
+	gpio_set_value(priv->chip_en,0);
+	msleep(20);
+	gpio_set_value(priv->chip_en, 1);
+	msleep(100);
+	skw_pcie_rescan_bus();
+	kfree(priv);
+	skw_pcie_debugfs_deinit();
+	PCIE_INFO("[-]\n");
+}
+
+module_init(skw_pcie_init);
+module_exit(skw_pcie_exit);
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("seekwave pcie/edma drv");
diff --git a/drivers/misc/seekwaveplatform_v20/pcie/skw_pcie_drv.h b/drivers/misc/seekwaveplatform_v20/pcie/skw_pcie_drv.h
new file mode 100755
index 000000000000..8b03e63e6524
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/pcie/skw_pcie_drv.h
@@ -0,0 +1,159 @@
+/*
+ * Copyright (C) 2022 Seekwave Tech Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __SKW_PCIE_DRV_H__
+#define __SKW_PCIE_DRV_H__
+
+#include <linux/pci.h>
+#include <linux/platform_device.h>
+#include "../skwutil/skw_boot.h"
+#include "skw_pcie_log.h"
+
+
+#define PCIE_INFO	skw_pcie_info
+#define PCIE_ERR	skw_pcie_err
+#define PCIE_DBG	skw_pcie_dbg
+
+#define DRV_NAME	"skw_pcie"
+#define	WIFI_SERVICE	0
+#define	BT_SERVICE	1
+
+#define SERVICE_START	0
+#define SERVICE_STOP	1
+
+#define SKW_AP2CP_IRQ_REG (0xF80+0x34)
+
+#define SKWPCIE_AP2CP_SIG0	(0xF80+0x10)
+#define SKWPCIE_AP2CP_SIG1	(0xF80+0x14)
+#define SKWPCIE_AP2CP_SIG2	(0xF80+0x18)
+
+#define SKWPCIE_CP2AP_SIG0	(0xF80+0x1C)
+
+#define SKW_CHIP_ID0	0x40000000	//SV6160 chip id0
+#define SKW_CHIP_ID1	0x40000004	//SV6160 chip id1
+#define SKW_CHIP_ID2	0x40000008	//SV6160 chip id2
+#define SKW_CHIP_ID3	0x4000000C	//SV6160 chip id3
+#define SKW_CHIP_ID_LENGTH	16	//SV6360 chip id lenght
+
+#define SKW_CP_PMU_SW_REG	0x40108160
+#define L2_SHAKE_MASK	0xff
+#define WIFI_DO_SUSPEND_MASK 0xf00
+#define SKW_CP_AON_SW_REG	0x40100030
+#define TRACE_SUPPORT_MASK	0xff
+#define PCIE_CP_BOOT_WAR_MASK	0xff00
+
+#define IBREG0_OFFSET_ADDR	(0x1000 + (0 * 0x20))
+#define IBREG1_OFFSET_ADDR	(0x1000 + (1 * 0x20))
+#define IBREG2_OFFSET_ADDR	(0x1000 + (2 * 0x20))
+#define IBREG3_OFFSET_ADDR	(0x1000 + (3 * 0x20))
+#define OBREG0_OFFSET_ADDR	(0x1000 + (4 * 0x20))
+#define OBREG1_OFFSET_ADDR	(0x1000 + (5 * 0x20))
+
+#define FW_DATA_CRC_BASE	0x401EFFE4
+#define FW_BOOT_REG_BASE	0x40000144
+#define FW_DL_DONE_REG_BASE	0x40000140
+#define FW_BOOT_ADDR	0x100000
+
+struct bar_info {
+	resource_size_t mmio_start;
+	resource_size_t mmio_end;
+	resource_size_t mmio_len;
+	unsigned long mmio_flags;
+	unsigned char *mem;
+	unsigned char *vmem;
+};
+
+struct dma_buf {
+	unsigned long vir;
+	unsigned long phy;
+	int size;
+};
+
+struct wcn_pcie_info {
+	struct platform_device *rc_pd;
+	struct pci_dev *dev;
+	struct pci_saved_state *saved_state;
+	u64 mem_pciaddr;
+	int legacy_en;
+	int msi_en;
+	int msix_en;
+	u16 msix_vec_idx[32];
+	int irq;
+	int irq_num;
+	int gpio_irq_num;
+	int bar_num;
+	u8 __iomem *pcimem;
+	u8 __iomem *pciaux;
+	u64 mem_start;
+	u64 aux_start;
+	u64 mem_barl;
+	u64 mem_barh;
+	struct msix_entry *msix;
+	spinlock_t *spin_lock;
+	struct mutex except_mutex;
+	struct mutex dl_lock;
+	u32 iram_dl_size;
+	u32 dram_dl_size;
+	u32 iram_crc_offset;
+	u32 dram_crc_offset;
+	u16 iram_crc;
+	u16 dram_crc;
+	u32 iram_crc_en;
+	u32 dram_crc_en;
+	unsigned int irq_trigger_type;
+	atomic_t irq_cnt;
+	struct completion download_done;
+	struct completion edma_blk_dl_done;
+	int cp_state;
+	int chip_en;
+	int recovery_dis_state;
+	unsigned int chip_id[SKW_CHIP_ID_LENGTH];
+	struct seekwave_device *boot_data;
+	unsigned int service_state_map;
+	struct delayed_work skw_except_work;
+	struct delayed_work skw_pcie_recovery_work;
+	struct delayed_work check_dumpdone_work;
+#ifdef CONFIG_BT_SEEKWAVE
+	struct work_struct bt_rx_work;
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)
+	struct wakeup_source *ws;
+	struct wakeup_source *ws_event;
+#else
+	struct wake_lock wake_lock;
+	struct wake_lock wake_lockevent;
+#endif
+};
+
+struct wcn_pcie_info *get_pcie_device_info(void);
+//char *pcie_bar_vmem(struct wcn_pcie_info *priv, int bar);
+int pcie_config_read(struct wcn_pcie_info *priv, int offset, char *buf, int len);
+struct wcn_pcie_info *get_wcn_device_info(void);
+void skw_pcie_write32(u32 reg_addr, u32 value);
+u32 skw_pcie_read32(u32 reg_addr);
+void skw_pcie_setbit(u32 reg_addr, u32 bits);
+void skw_pcie_clrbit(u32 reg_addr, u32 bits);
+u64 edma_phyaddr_to_pcieaddr(u64 addr);
+u64 edma_pcieaddr_to_phyaddr(u64 addr);
+u64 edma_pcieaddr_to_phyaddr(u64 phy_addr);
+u64 edma_pcieaddr_to_virtaddr(u64 phy_addr);
+u64 edma_virtaddr_to_pcieaddr(void *virt_addr);
+void skw_pcie_rescan_bus(void);
+int skw_pcie_boot_cp(int boot_mode);
+void reboot_to_change_bt_antenna_mode(char *mode);
+void get_bt_antenna_mode(char *mode);
+int skw_pcie_recovery_debug_status(void);
+int skw_pcie_recovery_disable(int disable);
+void reboot_to_change_bt_uart1(char *mode);
+int skw_pcie_host_irq_init(unsigned int irq_gpio_num);
+#endif
diff --git a/drivers/misc/seekwaveplatform_v20/pcie/skw_pcie_log.c b/drivers/misc/seekwaveplatform_v20/pcie/skw_pcie_log.c
new file mode 100755
index 000000000000..c333cf7c7971
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/pcie/skw_pcie_log.c
@@ -0,0 +1,392 @@
+/**************************************************************************
+ * Copyright(c) 2020-2030  Seekwave Corporation.
+ * SEEKWAVE TECH LTD..CO
+ *
+ *Seekwave Platform the pcie log debug fs
+ *FILENAME:skw_pcie_log.c
+ *DATE:2022-04-11
+ *MODIFY:
+ *Author:Jones.Jiang
+ **************************************************************************/
+#include <linux/uaccess.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include "skw_pcie_drv.h"
+#include "skw_edma_drv.h"
+#include "skw_pcie_log.h"
+#include "skw_pcie_debugfs.h"
+
+extern char firmware_version[];
+
+static unsigned long skw_pcie_dbg_level;
+
+unsigned long skw_pcie_log_level(void)
+{
+	return skw_pcie_dbg_level;
+}
+
+static void skw_pcie_set_log_level(int level)
+{
+	unsigned long dbg_level;
+
+	dbg_level = skw_pcie_log_level() & 0xffff0000;
+	dbg_level |= ((level << 1) - 1);
+
+	xchg(&skw_pcie_dbg_level, dbg_level);
+}
+
+static void skw_pcie_enable_func_log(int func, bool enable)
+{
+	unsigned long dbg_level = skw_pcie_log_level();
+
+	if (enable)
+		dbg_level |= func;
+	else
+		dbg_level &= (~func);
+
+	xchg(&skw_pcie_dbg_level, dbg_level);
+}
+
+static int skw_pcie_log_show(struct seq_file *seq, void *data)
+{
+#define SKW_PCIE_LOG_STATUS(s) (level & (s) ? "enable" : "disable")
+
+	int i;
+	u32 level = skw_pcie_log_level();
+	u8 *log_name[] = {"NONE", "ERROR", "WARNNING", "INFO", "DEBUG"};
+
+	for (i = 0; i < 5; i++) {
+		if (!(level & BIT(i)))
+			break;
+	}
+
+	seq_printf(seq, "\nlog   level: %s\n", log_name[i]);
+
+	seq_puts(seq, "\n");
+	seq_printf(seq, "port0 log: %s\n", SKW_PCIE_LOG_STATUS(SKW_PCIE_PORT0));
+	seq_printf(seq, "port1 log: %s\n", SKW_PCIE_LOG_STATUS(SKW_PCIE_PORT1));
+	seq_printf(seq, "port2 log: %s\n", SKW_PCIE_LOG_STATUS(SKW_PCIE_PORT2));
+	seq_printf(seq, "port3 log: %s\n", SKW_PCIE_LOG_STATUS(SKW_PCIE_PORT3));
+	seq_printf(seq, "port4 log: %s\n", SKW_PCIE_LOG_STATUS(SKW_PCIE_PORT4));
+	seq_printf(seq, "port5 log: %s\n", SKW_PCIE_LOG_STATUS(SKW_PCIE_PORT5));
+	seq_printf(seq, "port6 log: %s\n", SKW_PCIE_LOG_STATUS(SKW_PCIE_PORT6));
+	seq_printf(seq, "port7 log: %s\n", SKW_PCIE_LOG_STATUS(SKW_PCIE_PORT7));
+	seq_printf(seq, "savelog  : %s\n", SKW_PCIE_LOG_STATUS(SKW_PCIE_SAVELOG));
+	seq_printf(seq, "dump  log: %s\n", SKW_PCIE_LOG_STATUS(SKW_PCIE_DUMP));
+
+	return 0;
+}
+
+static int skw_pcie_log_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, &skw_pcie_log_show, inode->i_private);
+}
+
+static int skw_pcie_log_control(const char *cmd, bool enable)
+{
+	if (!strcmp("dump", cmd))
+		skw_pcie_enable_func_log(SKW_PCIE_DUMP, enable);
+	else if (!strcmp("port0", cmd))
+		skw_pcie_enable_func_log(SKW_PCIE_PORT0, enable);
+	else if (!strcmp("port1", cmd))
+		skw_pcie_enable_func_log(SKW_PCIE_PORT1, enable);
+	else if (!strcmp("port2", cmd))
+		skw_pcie_enable_func_log(SKW_PCIE_PORT2, enable);
+	else if (!strcmp("port3", cmd))
+		skw_pcie_enable_func_log(SKW_PCIE_PORT3, enable);
+	else if (!strcmp("port4", cmd))
+		skw_pcie_enable_func_log(SKW_PCIE_PORT4, enable);
+	else if (!strcmp("port5", cmd))
+		skw_pcie_enable_func_log(SKW_PCIE_PORT5, enable);
+	else if (!strcmp("port6", cmd))
+		skw_pcie_enable_func_log(SKW_PCIE_PORT6, enable);
+	else if (!strcmp("port7", cmd))
+		skw_pcie_enable_func_log(SKW_PCIE_PORT7, enable);
+	else if (!strcmp("savelog", cmd))
+		skw_pcie_enable_func_log(SKW_PCIE_SAVELOG, enable);
+	else if (!strcmp("debug", cmd))
+		skw_pcie_set_log_level(SKW_PCIE_DEBUG);
+	else if (!strcmp("info", cmd))
+		skw_pcie_set_log_level(SKW_PCIE_INFO);
+	else if (!strcmp("warn", cmd))
+		skw_pcie_set_log_level(SKW_PCIE_WARNING);
+	else if (!strcmp("error", cmd))
+		skw_pcie_set_log_level(SKW_PCIE_ERROR);
+	else
+		return -EINVAL;
+
+	return 0;
+}
+
+static ssize_t skw_pcie_log_write(struct file *fp, const char __user *buffer,
+				size_t len, loff_t *offset)
+{
+	int i, idx;
+	char cmd[32];
+	bool enable = false;
+
+	for (idx = 0, i = 0; i < len; i++) {
+		char c;
+
+		if (get_user(c, buffer))
+			return -EFAULT;
+
+		switch (c) {
+		case ' ':
+			break;
+
+		case ':':
+			cmd[idx] = 0;
+			if (!strcmp("enable", cmd))
+				enable = true;
+			else
+				enable = false;
+
+			idx = 0;
+			break;
+
+		case '|':
+		case '\0':
+		case '\n':
+			cmd[idx] = 0;
+			skw_pcie_log_control(cmd, enable);
+			idx = 0;
+			break;
+
+		default:
+			cmd[idx++] = c;
+			idx %= 32;
+
+			break;
+		}
+
+		buffer++;
+	}
+
+	return len;
+}
+
+static const struct file_operations skw_pcie_log_fops = {
+	.owner = THIS_MODULE,
+	.open = skw_pcie_log_open,
+	.read = seq_read,
+	.release = single_release,
+	.write = skw_pcie_log_write,
+};
+static int skw_version_show(struct seq_file *seq, void *data)
+{
+	seq_printf(seq, "firmware info: %s\n", firmware_version );
+	return 0;
+}
+static int skw_version_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, &skw_version_show, inode->i_private);
+}
+
+
+static const struct file_operations skw_version_fops = {
+	.owner = THIS_MODULE,
+	.open = skw_version_open,
+	.read = seq_read,
+	.release = single_release,
+};
+
+static int skw_port_statistic_show(struct seq_file *seq, void *data)
+{
+		char *statistic = kzalloc(2048, GFP_KERNEL);
+
+		skw_get_port_statistic(statistic, 2048);
+		seq_printf(seq, "Statistic:\n %s", statistic );
+		kfree(statistic);
+		return 0;
+}
+static int skw_port_statistic_open(struct inode *inode, struct file *file)
+{
+		return single_open(file, &skw_port_statistic_show, inode->i_private);
+}
+
+
+static const struct file_operations skw_port_statistic_fops = {
+		.owner = THIS_MODULE,
+		.open = skw_port_statistic_open,
+		.read = seq_read,
+		.release = single_release,
+};
+
+static int skw_cp_log_show(struct seq_file *seq, void *data)
+{
+	if (!skw_pcie_cp_log_status())
+		seq_printf(seq, "Enabled");
+	else
+		seq_printf(seq, "Disabled");
+
+	return 0;
+}
+static int skw_cp_log_open(struct inode *inode, struct file *file)
+{
+		return single_open(file, &skw_cp_log_show, inode->i_private);
+}
+
+
+static ssize_t skw_cp_log_write(struct file *fp, const char __user *buffer,
+				size_t len, loff_t *offset)
+{
+	char cmd[16]={0};
+
+	if (len >= sizeof(cmd))
+		return -EINVAL;
+	if (copy_from_user(cmd, buffer, len))
+		return -EFAULT;
+
+	if (!strncmp("enable", cmd, 6)){
+		skw_pcie_cp_log(0);
+	}else if (!strncmp("disable", cmd, 7)){
+		skw_pcie_cp_log(1);
+	}
+	return len;
+}
+
+static const struct file_operations skw_cp_log_fops = {
+	.owner = THIS_MODULE,
+	.open = skw_cp_log_open,
+	.read = seq_read,
+	.release = single_release,
+	.write = skw_cp_log_write,
+};
+
+static int skw_pcie_recovery_debug_show(struct seq_file *seq, void *data)
+{
+	if (!skw_pcie_recovery_debug_status())
+		seq_printf(seq, "Enabled");
+	else
+		seq_printf(seq, "Disabled");
+
+	return 0;
+}
+static int skw_pcie_recovery_debug_open(struct inode *inode, struct file *file)
+{
+		return single_open(file, &skw_pcie_recovery_debug_show, inode->i_private);
+}
+
+
+static ssize_t skw_pcie_recovery_debug_write(struct file *fp, const char __user *buffer,
+				size_t len, loff_t *offset)
+{
+	char cmd[16]={0};
+
+	if (len >= sizeof(cmd))
+		return -EINVAL;
+	if (copy_from_user(cmd, buffer, len))
+		return -EFAULT;
+
+	if (!strncmp("enable", cmd, 6)){
+		skw_pcie_recovery_disable(0);
+	}else if (!strncmp("disable", cmd, 7)){
+		skw_pcie_recovery_disable(1);
+	}
+	return len;
+}
+
+static const struct file_operations skw_pcie_recovery_fops = {
+	.owner = THIS_MODULE,
+	.open = skw_pcie_recovery_debug_open,
+	.read = seq_read,
+	.release = single_release,
+	.write = skw_pcie_recovery_debug_write,
+};
+
+static int skw_bluetooth_UART1_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, NULL, inode->i_private);
+}
+
+
+static ssize_t skw_bluetooth_UART1_write(struct file *fp, const char __user *buffer,
+				size_t len, loff_t *offset)
+{
+	char cmd[32]={0};
+
+	if (len >= sizeof(cmd))
+		return -EINVAL;
+	if (copy_from_user(cmd, buffer, len))
+		return -EFAULT;
+	if (!strncmp("enable", cmd, 6)) {
+		memset(cmd, 0, sizeof(cmd));
+		reboot_to_change_bt_uart1(cmd);
+		printk("%s UART-HCI\n", cmd);
+	}
+	return len;
+}
+
+static const struct file_operations skw_bluetooth_UART1_fops = {
+	.owner = THIS_MODULE,
+	.open = skw_bluetooth_UART1_open,
+	.release = single_release,
+	.write = skw_bluetooth_UART1_write,
+};
+
+static int skw_bluetooth_antenna_show(struct seq_file *seq, void *data)
+{
+	char result[32];
+
+	memset(result, 0, sizeof(result));
+	get_bt_antenna_mode(result);
+	if(strlen(result))
+		seq_printf(seq, result);
+
+	return 0;
+}
+
+static int skw_bluetooth_antenna_open(struct inode *inode, struct file *file)
+{
+		return single_open(file, &skw_bluetooth_antenna_show, inode->i_private);
+}
+
+
+static ssize_t skw_bluetooth_antenna_write(struct file *fp, const char __user *buffer,
+				size_t len, loff_t *offset)
+{
+	char cmd[32]={0};
+
+	if (len >= sizeof(cmd))
+		return -EINVAL;
+	if (copy_from_user(cmd, buffer, len))
+		return -EFAULT;
+	if (!strncmp("switch", cmd, 6)) {
+		memset(cmd, 0, sizeof(cmd));
+		reboot_to_change_bt_antenna_mode(cmd);
+		printk("%s\n", cmd);
+	}
+	return len;
+}
+
+static const struct file_operations skw_bluetooth_antenna_fops = {
+	.owner = THIS_MODULE,
+	.open = skw_bluetooth_antenna_open,
+	.read = seq_read,
+	.release = single_release,
+	.write = skw_bluetooth_antenna_write,
+};
+
+void skw_pcie_log_level_init(void)
+{
+	skw_pcie_set_log_level(SKW_PCIE_INFO);
+
+	skw_pcie_enable_func_log(SKW_PCIE_DUMP, false);
+	skw_pcie_enable_func_log(SKW_PCIE_PORT0, false);
+	skw_pcie_enable_func_log(SKW_PCIE_PORT1, false);
+	skw_pcie_enable_func_log(SKW_PCIE_PORT2, false);
+	skw_pcie_enable_func_log(SKW_PCIE_PORT3, false);
+	skw_pcie_enable_func_log(SKW_PCIE_PORT4, false);
+	skw_pcie_enable_func_log(SKW_PCIE_PORT5, false);
+	skw_pcie_enable_func_log(SKW_PCIE_PORT6, false);
+	skw_pcie_enable_func_log(SKW_PCIE_SAVELOG, false);
+	skw_pcie_enable_func_log(SKW_PCIE_PORT7, false);
+	skw_pcie_add_debugfs("log_level", 0666, NULL, &skw_pcie_log_fops);
+	skw_pcie_add_debugfs("recovery", 0666, NULL, &skw_pcie_recovery_fops);
+	skw_pcie_add_debugfs("Version", 0666, NULL, &skw_version_fops);
+	skw_pcie_add_debugfs("Statistic", 0666, NULL, &skw_port_statistic_fops);
+	skw_pcie_add_debugfs("CPLog", 0666, NULL, &skw_cp_log_fops);
+	skw_pcie_add_debugfs("BT_ANT", 0666, NULL, &skw_bluetooth_antenna_fops);
+	skw_pcie_add_debugfs("BT_UART1", 0666, NULL, &skw_bluetooth_UART1_fops);
+}
diff --git a/drivers/misc/seekwaveplatform_v20/pcie/skw_pcie_log.h b/drivers/misc/seekwaveplatform_v20/pcie/skw_pcie_log.h
new file mode 100755
index 000000000000..951072a7da89
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/pcie/skw_pcie_log.h
@@ -0,0 +1,81 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2020-2030  Seekwave Corporation.
+ *
+ *****************************************************************************/
+#ifndef __SKW_PCIE_LOG_H__
+#define __SKW_PCIE_LOG_H__
+
+#define SKW_PCIE_ERROR	BIT(0)
+#define SKW_PCIE_WARNING  BIT(1)
+#define SKW_PCIE_INFO	 BIT(2)
+#define SKW_PCIE_DEBUG	BIT(3)
+
+#define SKW_PCIE_CMD	  BIT(16)
+#define SKW_PCIE_EVENT	BIT(17)
+#define SKW_PCIE_SCAN	 BIT(18)
+#define SKW_PCIE_TIMER	BIT(19)
+#define SKW_PCIE_STATE	BIT(20)
+
+#define SKW_PCIE_PORT0	 BIT(21)
+#define SKW_PCIE_PORT1	 BIT(22)
+#define SKW_PCIE_PORT2	 BIT(23)
+#define SKW_PCIE_PORT3	 BIT(24)
+#define SKW_PCIE_PORT4	 BIT(25)
+#define SKW_PCIE_PORT5	 BIT(26)
+#define SKW_PCIE_PORT6	 BIT(27)
+#define SKW_PCIE_PORT7	 BIT(28)
+#define SKW_PCIE_SAVELOG	 BIT(29)
+#define SKW_PCIE_DUMP	 BIT(31)
+
+unsigned long skw_pcie_log_level(void);
+
+#define skw_pcie_log(level, fmt, ...) \
+	do { \
+		if (skw_pcie_log_level() & level) \
+			pr_err(fmt,  ##__VA_ARGS__); \
+	} while (0)
+
+#define skw_pcie_port_log(port_num, fmt, ...) \
+	do { \
+		if (skw_pcie_log_level() &(SKW_PCIE_PORT0<<port_num)) \
+			pr_err(fmt,  ##__VA_ARGS__); \
+	} while (0)
+
+#define skw_port_log(port_num,fmt, ...) \
+	skw_pcie_log((SKW_PCIE_PORT0<<port_num), "[PORT_LOG] %s: "fmt, __func__, ##__VA_ARGS__)
+
+#define skw_pcie_err(fmt, ...) \
+	skw_pcie_log(SKW_PCIE_ERROR, "[SKWPCIE ERROR] %s %d: "fmt, __func__, __LINE__, ##__VA_ARGS__)
+
+#define skw_pcie_warn(fmt, ...) \
+	skw_pcie_log(SKW_PCIE_WARNING, "[SKWPCIE WARN] %s: "fmt, __func__, ##__VA_ARGS__)
+
+#define skw_pcie_info(fmt, ...) \
+	skw_pcie_log(SKW_PCIE_INFO, "[SKWPCIE INFO] %s %d: "fmt, __func__, __LINE__, ##__VA_ARGS__)
+
+#define skw_pcie_dbg(fmt, ...) \
+	skw_pcie_log(SKW_PCIE_DEBUG, "[SKWPCIE DBG] %s %d: "fmt, __func__, __LINE__, ##__VA_ARGS__)
+
+#define skw_pcie_hex_dump(prefix, buf, len) \
+	do { \
+		if (skw_pcie_log_level() & SKW_PCIE_DUMP) { \
+			u8 str[32] = {0};  \
+			snprintf(str, sizeof(str), "[SKWPCIE DUMP] %s", prefix); \
+			print_hex_dump(KERN_ERR, str, \
+				DUMP_PREFIX_OFFSET, 16, 1, buf, len, true); \
+		} \
+	} while (0)
+#if 0
+#define skw_pcie_port_log(port_num, fmt, ...) \
+	do { \
+		if (skw_pcie_log_level() &(SKW_PCIE_PORT0<<port_num)) \
+			pr_err("[PORT_LOG] %s:"fmt,__func__,  ##__VA_ARGS__); \
+	} while (0)
+
+#endif
+int skw_pcie_cp_log_status(void);
+void skw_pcie_log_level_init(void);
+int skw_pcie_cp_log(int disable);
+#endif
+
diff --git a/drivers/misc/seekwaveplatform_v20/pcie/skw_pcie_loopcheck.c b/drivers/misc/seekwaveplatform_v20/pcie/skw_pcie_loopcheck.c
new file mode 100755
index 000000000000..43a5595066b4
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/pcie/skw_pcie_loopcheck.c
@@ -0,0 +1,297 @@
+/*
+ * Copyright (C) 2022 Seekwave Tech Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/platform_device.h>
+#include <linux/scatterlist.h>
+#include <linux/dma-mapping.h>
+#include <linux/version.h>
+#include <linux/notifier.h>
+#include <linux/semaphore.h>
+#include <linux/gpio.h>
+#include <linux/pm_runtime.h>
+#include <linux/kthread.h>
+#include <linux/module.h>
+#include <linux/list.h>
+#include <linux/err.h>
+#include <linux/wait.h>
+#include <linux/delay.h>
+#include <linux/semaphore.h>
+#include "skw_pcie_drv.h"
+#include "skw_edma_drv.h"
+
+#define MODEM_OFF  0
+#define MODEM_ON	1
+#define MODEM_HALT 2
+
+extern struct edma_port edma_ports[MAX_PORT_NUM];
+int modem_status;
+static struct task_struct *loop_thread;
+static int loop_state;
+static struct semaphore loop_sem;
+static char firmware_version[128];
+static int loop_portno;
+int send_modem_assert_command(void);
+extern u32 last_sent_wifi_cmd[3];
+int skw_pcie_elbi_writeb(unsigned int address, unsigned char value);
+int skw_pcie_elbi_writed(unsigned int address, u32 value);
+static BLOCKING_NOTIFIER_HEAD(modem_notifier_list);
+static u8 port_assert_idx[5] = {
+	EDMA_AT_PORT,
+	EDMA_LOG_PORT,
+	EDMA_BTCMD_PORT,
+	EDMA_BTAUDIO_PORT,
+	EDMA_BTACL_PORT
+};
+
+void skw_pcie_setup_service_devices(void)
+{
+}
+void modem_register_notify(struct notifier_block *nb)
+{
+	blocking_notifier_chain_register(&modem_notifier_list, nb);
+}
+void modem_unregister_notify(struct notifier_block *nb)
+{
+	blocking_notifier_chain_unregister(&modem_notifier_list, nb);
+}
+static void modem_notify_event(int event)
+{
+	blocking_notifier_call_chain(&modem_notifier_list, event, NULL);
+}
+
+void skw_pcie_exception_work(struct work_struct *work)
+{
+	int i=0;
+	struct wcn_pcie_info *priv = get_pcie_device_info();
+	PCIE_INFO(" ENTER...\n");
+	mutex_lock(&priv->except_mutex);
+	if(priv->cp_state !=0)
+	{
+		PCIE_INFO("the assert coming!!\n");
+		mutex_unlock(&priv->except_mutex);
+		return;
+	}
+	priv->cp_state = DEVICE_BLOCKED_EVENT;
+	mutex_unlock(&priv->except_mutex);
+	modem_notify_event(DEVICE_BLOCKED_EVENT);
+	for (i=0; i<5; i++)
+	{
+		if(!edma_ports[port_assert_idx[i]].state || edma_ports[port_assert_idx[i]].state==PORT_STATE_CLSE)
+			continue;
+
+		edma_ports[i].state = PORT_STATE_ASST;
+	}
+	recovery_close_all_ports();
+	gpio_set_value(priv->chip_en, 0);
+	PCIE_INFO("recv:---- ----chipen=%d\n", gpio_get_value(priv->chip_en));
+	msleep(1000);
+	gpio_set_value(priv->chip_en, 1);
+	PCIE_INFO("recv:---- ----chipen=%d\n", gpio_get_value(priv->chip_en));
+	priv->service_state_map=0;
+	skw_recovery_mode();
+}
+
+/*skw_ap2cp_irq_reg bit4 modem assert*/
+int send_modem_assert_command(void)
+{
+	int ret =0;
+	u32 *cmd = last_sent_wifi_cmd;
+	struct wcn_pcie_info *priv = get_pcie_device_info();
+
+	PCIE_DBG(" ENTER !!!\n");
+	if(priv->cp_state)
+		return ret;
+
+	//priv->cp_state=1;/*cp except set value*/
+	ret =skw_pcie_elbi_writeb(SKW_AP2CP_IRQ_REG, 0x10);
+	PCIE_ERR("%s ret=%d cmd: 0x%x 0x%x 0x%x\n", __func__,
+			 ret, cmd[0], cmd[1], cmd[2]);
+#ifdef CONFIG_SEEKWAVE_PLD_RELEASE
+	schedule_delayed_work(&priv->skw_except_work , msecs_to_jiffies(2000));
+#else
+	if(!priv->recovery_dis_state)
+		schedule_delayed_work(&priv->skw_except_work , msecs_to_jiffies(6000));
+#endif
+	return ret;
+}
+
+void check_dumpdone_work(struct work_struct *work)
+{
+	struct edma_port *port = get_edma_port_info(EDMA_LOOPCHECK_PORT);
+
+	if (!completion_done(&port->rx_done)) {
+		complete(&port->rx_done);
+		PCIE_INFO("force complete the loopcheck rx_done\n");
+	}
+}
+
+int skw_pcie_loopcheck_entry(void *para)
+{
+	struct wcn_pcie_info *skw_pcie;
+	int portno = *(int *)para;
+	char *buffer;
+	int read, size;
+	int count= 0, timeout=100;
+	int i;
+
+	PCIE_DBG("\n");
+	size = 512;
+	buffer = kzalloc(size, GFP_KERNEL);
+	skw_pcie = get_pcie_device_info();
+	while(loop_state && buffer){
+		read = 0;
+		memset(buffer,0,size);
+		do {
+			if(loop_state==0)
+				break;
+			read = recv_data(portno, buffer, 256);
+		} while(!read);
+
+		if(read < 0 || !loop_state) {
+			PCIE_DBG("bulkin read_len=%d\n",read);
+			break;
+		}
+
+		PCIE_INFO("recv(%d): %s\n", read, buffer);
+#if 0
+		if(strncmp(buffer, "BSPREADY", read))
+			PCIE_INFO("recv(%d): %s\n", read, buffer);
+#endif
+		memcpy(buffer+256, "LOOPCHECK", 9);
+		if (read==8 && !strncmp(buffer, "BSPREADY", read)) {
+			PCIE_INFO("BSP READY!!!\n");
+			;//send_data(portno, buffer+256, 9);
+		} else if (read==9 && !strncmp(buffer, "WIFIREADY", read)) {
+			skw_pcie->service_state_map |=1;
+			complete(&skw_pcie->download_done);
+			timeout=500;
+			PCIE_DBG("SEND THE LOOPCHECK CMD !!!\n");
+			send_data(portno, buffer+256, 9);
+		} else if (read==6 && !strncmp(buffer, "BTEXIT", read)) {
+			complete(&skw_pcie->download_done);
+		} else if (read==7 && !strncmp(buffer, "BTREADY", read)) {
+			skw_pcie->service_state_map |=2;
+			complete(&skw_pcie->download_done);
+			send_data(portno, buffer+256, 9);
+		} else if (!strncmp(buffer, "BSPASSERT", 9)) {
+			if(skw_pcie->cp_state==1)
+				cancel_delayed_work_sync(&skw_pcie->skw_except_work);
+
+			mutex_lock(&skw_pcie->except_mutex);
+			if(skw_pcie->cp_state == DEVICE_BLOCKED_EVENT){
+				mutex_unlock(&skw_pcie->except_mutex);
+				break;
+			}
+			skw_pcie->cp_state = 1;//TODO
+			mutex_unlock(&skw_pcie->except_mutex);
+
+			memset(buffer, 0, read);
+			modem_status = MODEM_HALT;
+			//show_assert_context();
+			modem_notify_event(DEVICE_ASSERT_EVENT);
+#ifndef CONFIG_SEEKWAVE_PLD_RELEASE
+			if(edma_ports[EDMA_LOG_PORT].state == PORT_STATE_OPEN) {
+				schedule_delayed_work(&skw_pcie->check_dumpdone_work , msecs_to_jiffies(5000));
+				read = recv_data(portno, buffer, 256);
+				cancel_delayed_work_sync(&skw_pcie->check_dumpdone_work);
+				PCIE_INFO(" bspassert after recv(%d): %s\n", read, buffer);
+				msleep(5000);//wait for CP to dump assert log
+			}
+#endif
+			modem_notify_event(DEVICE_DUMPDONE_EVENT);
+
+			for (i=0; i<5; i++) {
+				if((edma_ports[port_assert_idx[i]].state == PORT_STATE_IDLE) ||
+							(edma_ports[port_assert_idx[i]].state==PORT_STATE_CLSE))
+					continue;
+				edma_ports[port_assert_idx[i]].state = PORT_STATE_ASST;
+			}
+
+			if(skw_pcie->recovery_dis_state)
+				break;
+
+			recovery_close_all_ports();
+			PCIE_INFO("recv(%d):---- %s----chipen=%d\n", read, buffer, skw_pcie->chip_en);
+			gpio_set_value(skw_pcie->chip_en, 0);
+			PCIE_INFO("recv:---- ----chipen=%d\n", gpio_get_value(skw_pcie->chip_en));
+			msleep(1000);
+			gpio_set_value(skw_pcie->chip_en, 1);
+			PCIE_INFO("recv:---- ----chipen=%d\n", gpio_get_value(skw_pcie->chip_en));
+			schedule_delayed_work(&skw_pcie->skw_pcie_recovery_work , msecs_to_jiffies(2000));
+			//skw_recovery_mode();
+			//PCIE rescan bus
+			break;
+		} else if (!strncmp("trunk_W", buffer, 7)) {
+			//if(!skw_pcie->cp_state)
+			complete(&skw_pcie->download_done);
+
+			//assert_info_print = 0;
+			skw_pcie->cp_state = 0;
+			modem_status = MODEM_ON;
+			memset(firmware_version, 0 , sizeof(firmware_version));
+			strncpy(firmware_version, buffer, read);
+			PCIE_DBG("---debug---,@@Line:%d, Func:%s@@\n", __LINE__, __func__);
+			modem_notify_event(DEVICE_BSPREADY_EVENT);
+			PCIE_DBG("---debug---,@@Line:%d, Func:%s@@\n", __LINE__, __func__);
+
+			count = 0;
+			skw_pcie_setup_service_devices();
+		}
+		msleep(timeout);
+	}
+	PCIE_INFO("loopcheck thread is exit\n");
+
+	kfree(buffer);
+	up(&loop_sem);
+	return 0;
+}
+
+int skw_pcie_create_loopcheck_thread(int portno)
+{
+	int ret;
+
+	loop_thread = NULL;
+	modem_status = MODEM_OFF;
+	loop_state = 0;
+	ret = open_edma_port(portno, NULL, NULL);
+	if (ret==0) {
+		loop_portno = portno;
+		loop_thread = kthread_create(skw_pcie_loopcheck_entry, &loop_portno, "LOOP");
+	}
+	if(loop_thread) {
+		loop_state = 1;
+		sema_init(&loop_sem, 0);
+		wake_up_process(loop_thread);
+	}
+	return 0;
+}
+
+/************************************************************************
+ *Decription:
+ *Author:jiayong.yang
+ *Date:2021-05-27
+ *Modfiy:
+ *
+ ********************************************************************* */
+int skw_pcie_remove_loopcheck_thread(int portno)
+{
+	int ret;
+
+	if (loop_state && loop_thread) {
+		loop_state = 0;
+		//close_edma_port(portno);
+		ret = down_interruptible(&loop_sem);
+		if (ret==0)
+			loop_thread = NULL;
+	}
+	return 0;
+}
diff --git a/drivers/misc/seekwaveplatform_v20/pcie/trace.c b/drivers/misc/seekwaveplatform_v20/pcie/trace.c
new file mode 100755
index 000000000000..93c9fb6b41c0
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/pcie/trace.c
@@ -0,0 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0
+#include <linux/module.h>
+
+#ifndef __CHECKER__
+#define CREATE_TRACE_POINTS
+
+#include "trace.h"
+
+#endif
diff --git a/drivers/misc/seekwaveplatform_v20/pcie/trace.h b/drivers/misc/seekwaveplatform_v20/pcie/trace.h
new file mode 100755
index 000000000000..d9f46a5747e3
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/pcie/trace.h
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2022 Seekwave Tech Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM skwpcie
+
+#if !defined(__SKWPCIE_TRACE_H__) || defined(TRACE_HEADER_MULTI_READ)
+#define __SKWPCIE_TRACE_H__
+
+#include <linux/tracepoint.h>
+
+/*
+TRACE_EVENT(skw_edma_channel_irq_handler,
+	    TP_PROTO(int line, char *str, u64 val),
+	    TP_ARGS(line, str, val),
+
+	    TP_STRUCT__entry(
+		__field(int, line)
+		__field(char *, str)
+		__field(u64, val)
+	    ),
+
+	    TP_fast_assign(
+		__entry->line = line;
+		__entry->str = str;
+		__entry->val = val;
+	    ),
+
+	    TP_printk("line: %d, %s=0x%llx",
+		__entry->line, __entry->str, __entry->val)
+);
+*/
+TRACE_EVENT(skw_edma_channel_irq_handler,
+	    TP_PROTO(int line, char *str, u64 val, u64 val1, u64 val2),
+	    TP_ARGS(line, str, val, val1, val2),
+
+	    TP_STRUCT__entry(
+		__field(int, line)
+		__field(char *, str)
+		__field(u64, val)
+		__field(u64, val1)
+		__field(u64, val2)
+	    ),
+
+	    TP_fast_assign(
+		__entry->line = line;
+		__entry->str = str;
+		__entry->val = val;
+		__entry->val1 = val1;
+		__entry->val2 = val2;
+	    ),
+
+	    TP_printk("line: %d, %s, 0x%llx, %lld, %lld",
+		__entry->line, __entry->str, __entry->val,__entry->val1, __entry->val2)
+);
+
+#endif /* !_SKWPCIE_TRACE_H */
+
+#undef TRACE_INCLUDE_PATH
+#define TRACE_INCLUDE_PATH .
+
+#undef TRACE_INCLUDE_FILE
+#define TRACE_INCLUDE_FILE trace
+
+#include <trace/define_trace.h>
diff --git a/drivers/misc/seekwaveplatform_v20/sdio/Kconfig b/drivers/misc/seekwaveplatform_v20/sdio/Kconfig
new file mode 100755
index 000000000000..8d21a0197034
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/sdio/Kconfig
@@ -0,0 +1,9 @@
+config SKW_SDIOHAL
+	tristate "Seekwave Platform  SDIO Driver Support"
+	depends on SEEKWAVE_BSP_DRIVERS_V20 
+	default n
+	help
+	  Enable this module for seekwave
+	  chip sdio interface bus Support.
+	  Please insmod this module before any other
+	  seekwave subsystem. Thanks.
diff --git a/drivers/misc/seekwaveplatform_v20/sdio/README.md b/drivers/misc/seekwaveplatform_v20/sdio/README.md
new file mode 100755
index 000000000000..3d41bf502d07
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/sdio/README.md
@@ -0,0 +1,2 @@
+#seekwave tech sdio readme
+#seekwave platform driver code
diff --git a/drivers/misc/seekwaveplatform_v20/sdio/skw_sdio.h b/drivers/misc/seekwaveplatform_v20/sdio/skw_sdio.h
new file mode 100755
index 000000000000..60cd487859f4
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/sdio/skw_sdio.h
@@ -0,0 +1,271 @@
+#ifndef __SKW_SDIO_H__
+#define __SKW_SDIO_H__
+
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/scatterlist.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+
+#include "../skwutil/skw_boot.h"
+#include "skw_sdio_log.h"
+
+#define SKW_AP2CP_IRQ_REG 0x1B0
+
+#define	SKW_BUF_SIZE 	2048
+
+#define SKW_SDIO_SDMA	0
+#define SKW_SDIO_ADMA	1
+
+#define SKW_SDIO_INBAND_IRQ	0
+#define SKW_SDIO_EXTERNAL_IRQ	1
+
+#define SDIO_RX_TASK_PRIO 	90
+#define SDIO_UPDATE_TASK_PRIO 	91
+
+#define SKW_SDIO_BLK_SIZE 	skw_sdio_blk_size
+#define MAX_PAC_SIZE 		0x700
+#define MAX2_PAC_SIZE 		0x600
+#define MAX_PAC_COUNT		170
+
+#define SKW_SDIO_NSIZE_BUF_SIZE SKW_SDIO_BLK_SIZE
+
+#define SKW_SDIO_READ 		0
+#define SKW_SDIO_WRITE 		1
+
+#define SKW_SDIO_DATA_FIX 	0
+#define SKW_SDIO_DATA_INC 	1
+
+#define MAX_IO_RW_BLK 		511
+
+#define FUNC_0  		0
+#define FUNC_1  		1
+#define MAX_FUNC_NUM 		2
+
+#define SKW_SDIO_DT_MODE_ADDR	0x0f
+#define SKW_SDIO_PK_MODE_ADDR	0x20
+
+#define SKW_SDIO_RESET_MODE_ADDR	0x1C
+#define SKW_SDIO_CCCR_ABORT		0x06
+#define SDIO_INT_EXT			0x16
+#define SDIO_ABORT_TRANS		0x01
+
+#define SKW_SDIO_FBR_REG		0x15C
+
+#define SKW_CHIP_ID0		0x40000000  	//SV6160 chip id0
+#define SKW_CHIP_ID1		0x40000004  	//SV6160 chip id1
+#define SKW_CHIP_ID2		0x40000008  	//SV6160 chip id2
+#define SKW_CHIP_ID3		0x4000000C  	//SV6160 chip id3
+#define SKW_CHIP_ID_LENGTH	16  		//SV6160 chip id lenght
+
+#define SKW_SDIO_ALIGN_4BYTE(a)  (((a)+3)&(~3))
+#define SKW_SDIO_ALIGN_BLK(a) (((a)%SKW_SDIO_BLK_SIZE) ? \
+	(((a)/SKW_SDIO_BLK_SIZE + 1)*SKW_SDIO_BLK_SIZE) : (a))
+
+#define SDIO_VER_CCCR	(0)
+
+
+#define SKW_SDIO_CARD_OFFLINE 0x8000
+#define SKW_CARD_ONLINE(skw_sdio) \
+	(atomic_read(&skw_sdio->online) < SKW_SDIO_CARD_OFFLINE)
+
+#define SKW_SDIO_RESET_CARD_VAL 0x08
+#define SKW_SDIO_RESET_CP 	0x20
+
+#define	WIFI_SERVICE	0
+#define	BT_SERVICE	1
+
+#define	SERVICE_START	0
+#define	SERVICE_STOP	1
+
+#define	SKW_SDIO_V10 0
+#define	SKW_SDIO_V20 1
+
+
+#define	WIFI_CMD_PORT	5
+#define	WIFI_DATA_PORT	6
+#define	LOOPCHECK_PORT	7
+#define	MAX_CH_NUM	8
+
+#define	SDIO2_BSP_ATC_PORT	0
+#define	SDIO2_BT_ISOC_PORT	4
+#define	SDIO2_WIFI_CMD_PORT	6
+#define	SDIO2_WIFI_DATA_PORT	7
+#define	SDIO2_WIFI_DATA1_PORT	8
+#define	SDIO2_BSP_LOG_PORT	9
+#define	SDIO2_BT_LOG_PORT	10
+#define	SDIO2_BSP_UPDATE_PORT	11
+#define	SDIO2_LOOPCHECK_PORT	1
+#define	SDIO2_MAX_CH_NUM	12
+
+struct skw_sdio_data_t {
+	struct task_struct *rx_thread;
+	struct completion rx_completed;
+	struct task_struct *update_thread;
+	struct completion update_completed;
+#ifdef  CONFIG_WAKELOCK
+	struct wake_lock rx_wl;
+#else
+	struct wakeup_source *rx_ws;
+#endif
+	atomic_t rx_wakelocked;
+	struct mutex transfer_mutex;
+	struct mutex except_mutex;
+	atomic_t resume_flag;
+	atomic_t online;
+	bool threads_exit;
+	bool adma_rx_enable;
+	bool pwrseq;
+	bool blk_size;
+	/* EXTERNAL_IRQ 0, INBAND_IRQ 1. */
+	unsigned char irq_type;
+
+	atomic_t suspending;
+	int gpio_out;
+	int gpio_in;
+	unsigned int irq_num;
+	unsigned int irq_trigger_type;
+	struct sdio_func *sdio_func[MAX_FUNC_NUM];
+	struct mmc_host *sdio_dev_host;
+	unsigned char *eof_buf;
+
+	unsigned int next_size;
+	unsigned int remain_packet;
+	unsigned long long rx_packer_cnt;
+	char *next_size_buf;
+
+	struct completion scan_done;
+	struct completion remove_done;
+	struct completion download_done;
+	int host_active;
+	int host_state;
+	int device_active;
+	struct completion device_wakeup;
+	char tx_req_map;
+	int resume_com;
+	int cp_state;
+	int chip_en;
+	unsigned int chip_id[SKW_CHIP_ID_LENGTH];
+	struct seekwave_device *boot_data;
+	unsigned int service_state_map;
+	struct delayed_work skw_except_work;
+	int power_off;
+	int cp_detect_sleep_mode;
+	unsigned int sdio_exti_gpio_state;
+	int suspend_wake_unlock_enable;
+	wait_queue_head_t wq;
+	int bt_suspend_flags;
+	#define BT_SUSPEND_SUPPORT 1
+};
+
+struct debug_vars {
+       u16 cmd_timeout_cnt;
+       u32 rx_inband_irq_cnt;
+       u32 rx_gpio_irq_cnt;
+       u32 rx_read_cnt;
+       u32 last_sent_wifi_cmd[3];
+       u64 last_sent_time;
+       u64 last_rx_submit_time;
+       u64 host_assert_cp_time;
+       u64 cp_assert_time;
+       u64 last_irq_time;
+       u32 chn_irq_cnt[SDIO2_MAX_CH_NUM];
+#define CHN_IRQ_RECORD_NUM 3
+	u64 chn_last_irq_time[SDIO2_MAX_CH_NUM][CHN_IRQ_RECORD_NUM];
+	u64 last_irq_times[CHN_IRQ_RECORD_NUM];
+	u64 last_clear_irq_times[CHN_IRQ_RECORD_NUM];
+	u64 last_rx_read_times[CHN_IRQ_RECORD_NUM];
+};
+struct sdio_port {
+	struct platform_device *pdev;
+	struct scatterlist *sg_rx;
+	int	 sg_index;
+	int	 total;
+	int	sent_packet;
+	unsigned int type;
+	unsigned int channel;
+	rx_submit_fn rx_submit;
+	void *rx_data;
+	int	state;
+	char *read_buffer;
+	int rx_rp;
+	int rx_wp;
+	char *write_buffer;
+	int  length;
+	struct completion rx_done;
+	struct completion tx_done;
+	struct mutex rx_mutex;
+	int	rx_packet;
+	int	rx_count;
+	int 	tx_flow_ctrl;
+	int	 rx_flow_ctrl;
+	u16	next_seqno;
+};
+
+void skw_resume_check(void);
+struct skw_sdio_data_t *skw_sdio_get_data(void);
+
+void skw_sdio_rx_up(struct skw_sdio_data_t *skw_sdio);
+int skw_sdio_rx_thread(void *p);
+
+int send_data_async(int portno, char *buffer, int size);
+void skw_sdio_unlock_rx_ws(struct skw_sdio_data_t *skw_sdio);
+int skw_recovery_mode(void);
+int skw_sdio_sdma_write(unsigned char *src, unsigned int len);
+int skw_sdio_sdma_read(unsigned char *src, unsigned int len);
+int skw_sdio_adma_write(int portno, struct scatterlist *sgs, int sg_count, int total);
+int skw_sdio_adma_read(struct skw_sdio_data_t *skw_sdio, struct scatterlist *sgs, int sg_count, int total);
+int skw_sdio_dt_read(unsigned int address, void *buf, unsigned int len);
+int skw_sdio_dt_write(unsigned int address, void *buf, unsigned int len);
+int skw_sdio_readb(unsigned int address, unsigned char *data);
+int skw_sdio_writeb(unsigned int address, unsigned char data);
+int skw_sdio_writel(unsigned int address, void *data);
+int skw_sdio_readl(unsigned int address, void *data);
+int send_modem_service_command(u16 service, u16 command);
+int send_modem_assert_command(void);
+int skw_sdio_bind_platform_driver(struct sdio_func * func);
+int skw_sdio_bind_WIFI_driver(struct sdio_func * func);
+#ifndef CONFIG_SKW_BT
+int skw_sdio_bind_BT_driver(struct sdio_func * func);
+#endif
+int skw_sdio_bind_btseekwave_driver(struct sdio_func * func);
+int skw_sdio_unbind_platform_driver(struct sdio_func *func);
+int skw_sdio_unbind_WIFI_driver(struct sdio_func * func);
+int skw_sdio_unbind_BT_driver(struct sdio_func * func);
+int skw_boot_loader(struct seekwave_device *boot_data);
+void send_host_suspend_indication(struct skw_sdio_data_t *skw_sdio);
+void send_host_resume_indication(struct skw_sdio_data_t *skw_sdio);
+int try_to_wakeup_modem(int portno);
+void host_gpio_in_routine(int value);
+void skw_sdio_inband_irq_handler(struct sdio_func *func);
+void modem_notify_event(int event);
+int loopcheck_send_data(char *buffer, int size);
+void skw_get_port_statistic(char *buffer, int size);
+void skw_get_channel_record(char *buffer, int size);
+int skw_sdio_cp_log(int disable);
+int skw_sdio_recovery_debug(int disable);
+int skw_sdio_dumpmem(int dump);
+int skw_sdio_cp_log_status(void);
+int skw_sdio_recovery_debug_status(void);
+void reboot_to_change_bt_antenna_mode(char *mode);
+void reboot_to_change_bt_uart1(char *mode);
+void get_bt_antenna_mode(char *mode);
+int skw_sdio_wifi_power_on(int power_on);
+int skw_sdio_wifi_status(void);
+int skw_sdio_gpio_irq_pre_ops(void);
+void skw_get_sdio_debug_info(char *buffer, int size);
+void skw_get_assert_print_info(char *buffer, int size);
+
+#define skwsdio_log(fmt, args...) \
+	pr_info("[SKWSDIO]:" fmt, ## args)
+
+#define skwsdio_err(fmt, args...) \
+	pr_err("[SKWSDIO_ERR]:" fmt, ## args)
+
+#define skwsdio_data_pr(level, prefix_str, prefix_type, rowsize,\
+		groupsize, buf, len, asscii)\
+		do{if(loglevel) \
+			print_hex_dump(level, prefix_str, prefix_type, rowsize,\
+					groupsize, buf, len, asscii);\
+		}while(0)
+#endif
diff --git a/drivers/misc/seekwaveplatform_v20/sdio/skw_sdio_debugfs.c b/drivers/misc/seekwaveplatform_v20/sdio/skw_sdio_debugfs.c
new file mode 100755
index 000000000000..cf3935b8a453
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/sdio/skw_sdio_debugfs.c
@@ -0,0 +1,214 @@
+/*****************************************************************************
+ * Copyright(c) 2020-2030  Seekwave Corporation.
+ * SEEKWAVE TECH LTD..CO
+ *Seekwave Platform the sdio log debug fs
+ *FILENAME:skw_sdio_debugfs.c
+ *DATE:2022-04-11
+ *MODIFY:
+ *
+ **************************************************************************/
+#include "skw_sdio_debugfs.h"
+#include "skw_sdio_log.h"
+#include "skw_sdio.h"
+#include <generated/utsrelease.h>
+#include <linux/version.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/ctype.h>
+static struct dentry *skw_sdio_root_dir;
+static struct dentry *skw_sdio_debugfs_root;
+static struct proc_dir_entry *skw_sdio_proc_root;
+
+static int skw_sdio_proc_show(struct seq_file *seq, void *v)
+{
+#define SKW_BSP_CONFIG_INT(conf)                                          \
+	do {                                                          \
+		seq_printf(seq, "%s=%d\n", #conf, conf);              \
+	} while (0)
+
+#define SKW_BSP_CONFIG_BOOL(conf)                                         \
+	do {                                                          \
+		if (IS_ENABLED(conf))                                 \
+			seq_printf(seq, "%s=y\n", #conf);             \
+		else                                                  \
+			seq_printf(seq, "# %s is not set\n", #conf);  \
+	} while (0)
+
+#define SKW_BSP_CONFIG_STRING(conf)                                       \
+	do {                                                          \
+		seq_printf(seq, "%s=\"%s\"\n", #conf, conf);          \
+	} while (0)
+
+	seq_puts(seq, "\n");
+#if 0
+	seq_printf(seq, "Kernel Version:  \t%s\n"
+			"Wi-Fi Driver:    \t%s\n"
+			"Wi-Fi Branch:    \t%s\n",
+			UTS_RELEASE,
+			SKW_BSP_VERSION,
+			SKW_BSP_BRANCH);
+#endif
+	seq_printf(seq, "Kernel Version:  \t%s\n",
+			UTS_RELEASE);
+	seq_puts(seq, "\n");
+
+	SKW_BSP_CONFIG_BOOL(CONFIG_SKW_PCIE);
+	SKW_BSP_CONFIG_BOOL(CONFIG_SEEKWAVE_BSP_DRIVERS);
+	SKW_BSP_CONFIG_BOOL(CONFIG_SKW_USB);
+	SKW_BSP_CONFIG_BOOL(CONFIG_SKW_SDIOHAL);
+	SKW_BSP_CONFIG_BOOL(CONFIG_SKW_BSP_UCOM);
+	SKW_BSP_CONFIG_BOOL(CONFIG_SKW_BSP_BOOT);
+	SKW_BSP_CONFIG_BOOL(CONFIG_SEEKWAVE_PLD_RELEASE);
+#ifdef CONFIG_SKW6316_RX_REORDER_TIMEOUT
+	SKW_BSP_CONFIG_INT(CONFIG_SKW6316_RX_REORDER_TIMEOUT);
+#endif
+#ifdef CONFIG_SKW6316_CHIP_ID
+	SKW_BSP_CONFIG_STRING(CONFIG_SKW6316_CHIP_ID);
+#endif
+	seq_puts(seq, "\n");
+
+	return 0;
+}
+
+static int skw_sdio_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, skw_sdio_proc_show, NULL);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0)
+static const struct proc_ops skw_sdio_proc_fops = {
+	.proc_open = skw_sdio_proc_open,
+	.proc_read = seq_read,
+	.proc_lseek = seq_lseek,
+	.proc_release = single_release,
+};
+#else
+static const struct file_operations skw_sdio_proc_fops = {
+	.open = skw_sdio_proc_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+#endif
+
+struct dentry *skw_sdio_debugfs_subdir(const char *name, struct dentry *parent)
+{
+	struct dentry *de, *pentry;
+
+	pentry = parent ? parent : skw_sdio_debugfs_root;
+	if (!pentry)
+		return NULL;
+
+	de = debugfs_create_dir(name, pentry);
+
+	return IS_ERR(de) ? NULL : de;
+}
+
+struct dentry *skw_sdio_debugfs_file(struct dentry *parent,
+				const char *name, umode_t mode,
+				const struct file_operations *fops, void *data)
+{
+	struct dentry *de, *pentry;
+
+	pentry = parent ? parent : skw_sdio_debugfs_root;
+	if (!pentry)
+		return NULL;
+
+	de = debugfs_create_file(name, mode, pentry, data, fops);
+
+	return IS_ERR(de) ? NULL : de;
+}
+
+struct proc_dir_entry *skw_sdio_procfs_subdir(const char *name,
+				struct proc_dir_entry *parent)
+{
+	struct proc_dir_entry *dentry = parent ? parent : skw_sdio_proc_root;
+
+	if (!dentry)
+		return NULL;
+
+	return proc_mkdir_data(name, 0, dentry, NULL);
+}
+
+struct proc_dir_entry *skw_sdio_procfs_file(struct proc_dir_entry *parent,
+				       const char *name, umode_t mode,
+				       const void *fops, void *data)
+{
+	struct proc_dir_entry *dentry = parent ? parent : skw_sdio_proc_root;
+
+	if (!dentry)
+		return NULL;
+
+	return proc_create_data(name, mode, dentry, fops, data);
+}
+
+int skw_sdio_proc_init(void)
+{
+	skw_sdio_proc_root = proc_mkdir("skwsdio", NULL);
+	if (!skw_sdio_proc_root)
+		pr_err("creat proc skwsdio failed\n");
+
+	skw_sdio_procfs_file(skw_sdio_proc_root, "profile", 0, &skw_sdio_proc_fops, NULL);
+#if 0
+	skw_sdio_debugfs_root = debugfs_create_dir("skwsdio_tmp", NULL);
+	if (IS_ERR(skw_sdio_debugfs_root)) {
+		pr_err("create skwsdio failed, ret: %ld\n",
+		       PTR_ERR(skw_sdio_debugfs_root));
+
+		skw_sdio_debugfs_root = NULL;
+	}
+#endif
+
+	return 0;
+}
+
+void skw_sdio_proc_deinit(void)
+{
+	//debugfs_remove_recursive(skw_sdio_debugfs_root);
+	proc_remove(skw_sdio_proc_root);
+}
+static ssize_t skw_sdio_default_read(struct file *fp, char __user *buf, size_t len,
+				loff_t *offset)
+{
+	return 0;
+}
+
+static ssize_t skw_sdio_state_write(struct file *fp, const char __user *buffer,
+				size_t len, loff_t *offset)
+{
+	return len;
+}
+
+static const struct file_operations skw_sdio_state_fops = {
+	.open = skw_sdio_default_open,
+	.read = skw_sdio_default_read,
+	.write = skw_sdio_state_write,
+};
+
+struct dentry *skw_sdio_add_debugfs(const char *name, umode_t mode, void *data,
+			       const struct file_operations *fops)
+{
+	skw_sdio_dbg("%s:name: %s\n",__func__,name);
+
+	return debugfs_create_file(name, mode, skw_sdio_root_dir, data, fops);
+}
+
+int skw_sdio_debugfs_init(void)
+{
+	skw_sdio_proc_init();
+	skw_sdio_root_dir = debugfs_create_dir("skwsdio", NULL);
+	if (IS_ERR(skw_sdio_root_dir))
+		return PTR_ERR(skw_sdio_root_dir);
+
+	// skw_sdio_add_debugfs("state", 0666, wiphy, &skw_sdio_state_fops);
+	// skw_sdio_add_debugfs("log_level", 0444, wiphy, &skw_sdio_log_fops);
+
+	return 0;
+}
+
+void skw_sdio_debugfs_deinit(void)
+{
+	skw_sdio_dbg("%s :traced\n", __func__);
+	skw_sdio_proc_deinit();
+	debugfs_remove_recursive(skw_sdio_root_dir);
+}
diff --git a/drivers/misc/seekwaveplatform_v20/sdio/skw_sdio_debugfs.h b/drivers/misc/seekwaveplatform_v20/sdio/skw_sdio_debugfs.h
new file mode 100755
index 000000000000..cf9b0724c7ed
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/sdio/skw_sdio_debugfs.h
@@ -0,0 +1,52 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+/******************************************************************************
+ *
+ * Copyright (C) 2020 SeekWave Technology Co.,Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ ******************************************************************************/
+#ifndef __SKW_SDIO_DEBUGFS_H__
+#define __SKW_SDIO_DEBUGFS_H__
+#include <linux/fs.h>
+#include <linux/debugfs.h>
+#include <linux/proc_fs.h>
+#include <linux/uaccess.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include "skw_sdio.h"
+static inline int skw_sdio_default_open(struct inode *node, struct file *fp)
+{
+	fp->private_data = node->i_private;
+	return 0;
+}
+static inline void  skw_sdio_remove_debugfs(struct dentry *dentry)
+{
+	debugfs_remove(dentry);
+}
+
+struct dentry *skw_sdio_add_debugfs(const char *name, umode_t mode, void *data,
+			       const struct file_operations *fops);
+
+struct dentry *skw_sdio_debugfs_subdir(const char *name, struct dentry *parent);
+struct dentry *skw_sdio_debugfs_file(struct dentry *parent,
+				const char *name, umode_t mode,
+				const struct file_operations *fops, void *data);
+
+struct proc_dir_entry *skw_sdio_procfs_subdir(const char *name,
+				struct proc_dir_entry *parent);
+struct proc_dir_entry *skw_sdio_procfs_file(struct proc_dir_entry *parent,
+				       const char *name, umode_t mode,
+				       const void *proc_fops, void *data);
+
+int skw_sdio_debugfs_init(void);
+void skw_sdio_debugfs_deinit(void);
+#endif
diff --git a/drivers/misc/seekwaveplatform_v20/sdio/skw_sdio_log.c b/drivers/misc/seekwaveplatform_v20/sdio/skw_sdio_log.c
new file mode 100755
index 000000000000..82ef835702e4
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/sdio/skw_sdio_log.c
@@ -0,0 +1,607 @@
+/**************************************************************************
+ * Copyright(c) 2020-2030  Seekwave Corporation.
+ * SEEKWAVE TECH LTD..CO
+ *
+ *Seekwave Platform the sdio log debug fs
+ *FILENAME:skw_sdio_log.c
+ *DATE:2022-04-11
+ *MODIFY:
+ *Author:Jones.Jiang
+ **************************************************************************/
+#include <linux/uaccess.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include "skw_sdio.h"
+#include "skw_sdio_log.h"
+#include "skw_sdio_debugfs.h"
+
+extern char firmware_version[];
+static unsigned long skw_sdio_dbg_level;
+static unsigned long skw_sdio_channel_record = 0;
+
+unsigned long skw_sdio_log_level(void)
+{
+	return skw_sdio_dbg_level;
+}
+
+static void skw_sdio_set_log_level(int level)
+{
+	unsigned long dbg_level;
+
+	dbg_level = skw_sdio_log_level() & 0xffff0000;
+	dbg_level |= ((level << 1) - 1);
+
+	xchg(&skw_sdio_dbg_level, dbg_level);
+}
+
+static void skw_sdio_enable_func_log(int func, bool enable)
+{
+	unsigned long dbg_level = skw_sdio_log_level();
+
+	if (enable)
+		dbg_level |= func;
+	else
+		dbg_level &= (~func);
+
+	xchg(&skw_sdio_dbg_level, dbg_level);
+}
+
+static int skw_sdio_log_show(struct seq_file *seq, void *data)
+{
+#define SKW_SDIO_LOG_STATUS(s) (level & (s) ? "enable" : "disable")
+
+	int i;
+	u32 level = skw_sdio_log_level();
+	u8 *log_name[] = {"NONE", "ERROR", "WARNNING", "INFO", "DEBUG"};
+
+	for (i = 0; i < 5; i++) {
+		if (!(level & BIT(i)))
+			break;
+	}
+
+	seq_printf(seq, "\nlog   level: %s\n", log_name[i]);
+
+	seq_puts(seq, "\n");
+	seq_printf(seq, "port0 log: %s\n", SKW_SDIO_LOG_STATUS(SKW_SDIO_PORT0));
+	seq_printf(seq, "port1 log: %s\n", SKW_SDIO_LOG_STATUS(SKW_SDIO_PORT1));
+	seq_printf(seq, "port2 log: %s\n", SKW_SDIO_LOG_STATUS(SKW_SDIO_PORT2));
+	seq_printf(seq, "port3 log: %s\n", SKW_SDIO_LOG_STATUS(SKW_SDIO_PORT3));
+	seq_printf(seq, "port4 log: %s\n", SKW_SDIO_LOG_STATUS(SKW_SDIO_PORT4));
+	seq_printf(seq, "port5 log: %s\n", SKW_SDIO_LOG_STATUS(SKW_SDIO_PORT5));
+	seq_printf(seq, "port6 log: %s\n", SKW_SDIO_LOG_STATUS(SKW_SDIO_PORT6));
+	seq_printf(seq, "port7 log: %s\n", SKW_SDIO_LOG_STATUS(SKW_SDIO_PORT7));
+	seq_printf(seq, "savelog  : %s\n", SKW_SDIO_LOG_STATUS(SKW_SDIO_SAVELOG));
+	seq_printf(seq, "dump  log: %s\n", SKW_SDIO_LOG_STATUS(SKW_SDIO_DUMP));
+
+	return 0;
+}
+
+static int skw_sdio_log_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, &skw_sdio_log_show, inode->i_private);
+}
+
+static int skw_sdio_log_control(const char *cmd, bool enable)
+{
+	if (!strcmp("dump", cmd))
+		skw_sdio_enable_func_log(SKW_SDIO_DUMP, enable);
+	else if (!strcmp("port0", cmd))
+		skw_sdio_enable_func_log(SKW_SDIO_PORT0, enable);
+	else if (!strcmp("port1", cmd))
+		skw_sdio_enable_func_log(SKW_SDIO_PORT1, enable);
+	else if (!strcmp("port2", cmd))
+		skw_sdio_enable_func_log(SKW_SDIO_PORT2, enable);
+	else if (!strcmp("port3", cmd))
+		skw_sdio_enable_func_log(SKW_SDIO_PORT3, enable);
+	else if (!strcmp("port4", cmd))
+		skw_sdio_enable_func_log(SKW_SDIO_PORT4, enable);
+	else if (!strcmp("port5", cmd))
+		skw_sdio_enable_func_log(SKW_SDIO_PORT5, enable);
+    else if (!strcmp("port6", cmd))
+		skw_sdio_enable_func_log(SKW_SDIO_PORT6, enable);
+	else if (!strcmp("port7", cmd))
+		skw_sdio_enable_func_log(SKW_SDIO_PORT7, enable);
+    else if (!strcmp("savelog", cmd))
+		skw_sdio_enable_func_log(SKW_SDIO_SAVELOG, enable);
+	else if (!strcmp("debug", cmd))
+		skw_sdio_set_log_level(SKW_SDIO_DEBUG);
+	else if (!strcmp("info", cmd))
+		skw_sdio_set_log_level(SKW_SDIO_INFO);
+	else if (!strcmp("warn", cmd))
+		skw_sdio_set_log_level(SKW_SDIO_WARNING);
+	else if (!strcmp("error", cmd))
+		skw_sdio_set_log_level(SKW_SDIO_ERROR);
+	else
+		return -EINVAL;
+
+	return 0;
+}
+
+static ssize_t skw_sdio_log_write(struct file *fp, const char __user *buffer,
+				size_t len, loff_t *offset)
+{
+	int i, idx;
+	char cmd[32];
+	bool enable = false;
+
+	for (idx = 0, i = 0; i < len; i++) {
+		char c;
+
+		if (get_user(c, buffer))
+			return -EFAULT;
+
+		switch (c) {
+		case ' ':
+			break;
+
+		case ':':
+			cmd[idx] = 0;
+			if (!strcmp("enable", cmd))
+				enable = true;
+			else
+				enable = false;
+
+			idx = 0;
+			break;
+
+		case '|':
+		case '\0':
+		case '\n':
+			cmd[idx] = 0;
+			skw_sdio_log_control(cmd, enable);
+			idx = 0;
+			break;
+
+		default:
+			cmd[idx++] = c;
+			idx %= 32;
+
+			break;
+		}
+
+		buffer++;
+	}
+
+	return len;
+}
+
+static const struct file_operations skw_sdio_log_fops = {
+	.owner = THIS_MODULE,
+	.open = skw_sdio_log_open,
+	.read = seq_read,
+	.release = single_release,
+	.write = skw_sdio_log_write,
+};
+
+static int skw_version_show(struct seq_file *seq, void *data)
+{
+	seq_printf(seq, "firmware info: %s\n", firmware_version );
+	return 0;
+}
+static int skw_version_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, &skw_version_show, inode->i_private);
+}
+
+
+static const struct file_operations skw_version_fops = {
+	.owner = THIS_MODULE,
+	.open = skw_version_open,
+	.read = seq_read,
+	.release = single_release,
+};
+
+static int skw_port_statistic_show(struct seq_file *seq, void *data)
+{
+        char *statistic = kzalloc(2048, GFP_KERNEL);
+
+        skw_get_port_statistic(statistic, 2048);
+	seq_printf(seq, "Statistic:\n %s\n", statistic);
+	skw_get_assert_print_info(statistic, 2048);
+	seq_printf(seq, "sdio last irqs information:\n%s", statistic);
+	skw_get_sdio_debug_info(statistic, 2048);
+	seq_printf(seq, "\nsdio debug information:\n%s", statistic);
+	kfree(statistic);
+        return 0;
+}
+static int skw_port_statistic_open(struct inode *inode, struct file *file)
+{
+        return single_open(file, &skw_port_statistic_show, inode->i_private);
+}
+
+
+static const struct file_operations skw_port_statistic_fops = {
+        .owner = THIS_MODULE,
+        .open = skw_port_statistic_open,
+        .read = seq_read,
+        .release = single_release,
+};
+
+static int skw_cp_log_show(struct seq_file *seq, void *data)
+{
+	if (!skw_sdio_cp_log_status())
+		seq_printf(seq, "Enabled ");
+	else
+		seq_printf(seq, "Disabled ");
+        return 0;
+}
+static int skw_cp_log_open(struct inode *inode, struct file *file)
+{
+        return single_open(file, &skw_cp_log_show, inode->i_private);
+}
+
+
+static ssize_t skw_cp_log_write(struct file *fp, const char __user *buffer,
+				size_t len, loff_t *offset)
+{
+	char cmd[16]={0};
+
+	if (len >= sizeof(cmd))
+		return -EINVAL;
+	if (copy_from_user(cmd, buffer, len))
+		return -EFAULT;
+	if (!strncmp("enable", cmd, 6))
+		skw_sdio_cp_log(0);
+	else if (!strncmp("disable", cmd, 7))
+		skw_sdio_cp_log(1);
+	return len;
+}
+
+static const struct file_operations skw_cp_log_fops = {
+	.owner = THIS_MODULE,
+	.open = skw_cp_log_open,
+	.read = seq_read,
+	.release = single_release,
+	.write = skw_cp_log_write,
+};
+static int skw_bluetooth_UART1_open(struct inode *inode, struct file *file)
+{
+        return single_open(file, NULL, inode->i_private);
+}
+
+
+static ssize_t skw_bluetooth_UART1_write(struct file *fp, const char __user *buffer,
+				size_t len, loff_t *offset)
+{
+	char cmd[32]={0};
+
+	if (len >= sizeof(cmd))
+		return -EINVAL;
+	if (copy_from_user(cmd, buffer, len))
+		return -EFAULT;
+	if (!strncmp("enable", cmd, 6)) {
+		memset(cmd, 0, sizeof(cmd));
+		reboot_to_change_bt_uart1(cmd);
+		printk("%s UART-HCI\n", cmd);
+	}
+	return len;
+}
+
+static const struct file_operations skw_bluetooth_UART1_fops = {
+	.owner = THIS_MODULE,
+	.open = skw_bluetooth_UART1_open,
+	.release = single_release,
+	.write = skw_bluetooth_UART1_write,
+};
+
+static int skw_bluetooth_antenna_show(struct seq_file *seq, void *data)
+{
+	char result[32];
+
+	memset(result, 0, sizeof(result));
+	get_bt_antenna_mode(result);
+	if(strlen(result))
+		seq_printf(seq, result);
+        return 0;
+}
+static int skw_bluetooth_antenna_open(struct inode *inode, struct file *file)
+{
+        return single_open(file, &skw_bluetooth_antenna_show, inode->i_private);
+}
+
+
+static ssize_t skw_bluetooth_antenna_write(struct file *fp, const char __user *buffer,
+				size_t len, loff_t *offset)
+{
+	char cmd[32]={0};
+
+	if (len >= sizeof(cmd))
+		return -EINVAL;
+	if (copy_from_user(cmd, buffer, len))
+		return -EFAULT;
+	if (!strncmp("switch", cmd, 6)) {
+		memset(cmd, 0, sizeof(cmd));
+		reboot_to_change_bt_antenna_mode(cmd);
+		printk("%s\n", cmd);
+	}
+	return len;
+}
+
+static const struct file_operations skw_bluetooth_antenna_fops = {
+	.owner = THIS_MODULE,
+	.open = skw_bluetooth_antenna_open,
+	.read = seq_read,
+	.release = single_release,
+	.write = skw_bluetooth_antenna_write,
+};
+
+
+static int skw_recovery_debug_show(struct seq_file *seq, void *data)
+{
+	if (skw_sdio_recovery_debug_status())
+		seq_printf(seq, "Disabled");
+	else
+		seq_printf(seq, "Enabled");
+        return 0;
+}
+static int skw_recovery_debug_open(struct inode *inode, struct file *file)
+{
+        return single_open(file, &skw_recovery_debug_show, inode->i_private);
+}
+
+
+static ssize_t skw_recovery_debug_write(struct file *fp, const char __user *buffer,
+				size_t len, loff_t *offset)
+{
+	char cmd[16]={0};
+
+	if (len >= sizeof(cmd))
+		return -EINVAL;
+	if (copy_from_user(cmd, buffer, len))
+		return -EFAULT;
+	if (!strncmp("disable", cmd, 7))
+		skw_sdio_recovery_debug(1);
+	else if (!strncmp("enable", cmd, 6))
+		skw_sdio_recovery_debug(0);
+
+	return len;
+}
+
+static const struct file_operations skw_recovery_debug_fops = {
+	.owner = THIS_MODULE,
+	.open = skw_recovery_debug_open,
+	.read = seq_read,
+	.release = single_release,
+	.write = skw_recovery_debug_write,
+};
+
+static int skw_dump_mem_show(struct seq_file *seq, void *data)
+{
+        return 0;
+}
+static int skw_dump_mem_open(struct inode *inode, struct file *file)
+{
+        return single_open(file, &skw_dump_mem_show, inode->i_private);
+}
+
+static ssize_t skw_dump_mem_write(struct file *fp, const char __user *buffer,
+				size_t len, loff_t *offset)
+{
+	char cmd[16]={0};
+
+	if (len >= sizeof(cmd))
+		return -EINVAL;
+	if (copy_from_user(cmd, buffer, len))
+		return -EFAULT;
+	if (!strncmp("dump", cmd, 4))
+		skw_sdio_dumpmem(1);
+	else if (!strncmp("stop", cmd, 4))
+		skw_sdio_dumpmem(0);
+
+	return len;
+}
+
+static const struct file_operations skw_dump_mem_fops = {
+	.owner = THIS_MODULE,
+	.open = skw_dump_mem_open,
+	.read = seq_read,
+	.release = single_release,
+	.write = skw_dump_mem_write,
+};
+
+
+static int skw_sdio_wifi_show(struct seq_file *seq, void *data)
+{
+	if (skw_sdio_wifi_status())
+		seq_printf(seq, "PowerOn");
+	else
+		seq_printf(seq, "PowerOff");
+	return 0;
+}
+static int skw_sdio_wifi_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, &skw_sdio_wifi_show, inode->i_private);
+}
+
+
+static ssize_t skw_sdio_wifi_poweron(struct file *fp, const char __user *buffer,
+                                  size_t len, loff_t *offset)
+{
+          char cmd[16]={0};
+
+          if (len >= sizeof(cmd))
+                  return -EINVAL;
+          if (copy_from_user(cmd, buffer, len))
+                  return -EFAULT;
+          if (!strncmp("on", cmd, 2))
+                  skw_sdio_wifi_power_on(1);
+          else if (!strncmp("off", cmd, 3))
+                skw_sdio_wifi_power_on(0);
+
+          return len;
+}
+
+static const struct file_operations skw_sdio_wifi_fops = {
+          .owner = THIS_MODULE,
+          .open = skw_sdio_wifi_open,
+          .read = seq_read,
+          .release = single_release,
+          .write = skw_sdio_wifi_poweron,
+};
+
+
+unsigned long skw_sdio_channel_record_get(void)
+{
+	return skw_sdio_channel_record;
+}
+
+static void skw_sdio_channel_record_enable(u32 chn, bool enable)
+{
+	unsigned long record = skw_sdio_channel_record_get();
+
+	record = skw_sdio_channel_record_get();
+	if (enable)
+		record |= BIT(chn);
+	else
+		record &= ~BIT(chn);
+
+	skw_sdio_info("port%d %s\n", chn, record & BIT(chn) ? "enable" : "disable");
+	xchg(&skw_sdio_channel_record, record);
+}
+
+void skw_sdio_channel_record_enable_all(void)
+{
+	unsigned long record = skw_sdio_channel_record_get();
+	int i = 0;
+
+	record = skw_sdio_channel_record_get();
+	for (i = 0; i < SDIO2_MAX_CH_NUM; i++)
+		record |= BIT(i);
+
+	skw_sdio_info("all port enable 0x%lu\n", record);
+	xchg(&skw_sdio_channel_record, record);
+}
+
+void skw_sdio_channel_record_disable_all(void)
+{
+	skw_sdio_channel_record = 0;
+}
+
+static int skw_sdio_channel_record_show(struct seq_file *seq, void *data)
+{
+#define SKW_SDIO_CHANNEL_RECORD(s) (skw_sdio_channel_record & (1<<s) ? "enable" : "disable")
+#define RECORD_BUFFER_DEPTH (6*1024)
+
+	int i;
+        char *records = kzalloc(RECORD_BUFFER_DEPTH, GFP_KERNEL);
+	for (i = 0; i < SDIO2_MAX_CH_NUM; i++) {
+		seq_printf(seq, "port%d record: %s\n", i, SKW_SDIO_CHANNEL_RECORD(i));
+	}
+
+	skw_get_channel_record(records, RECORD_BUFFER_DEPTH);
+        seq_printf(seq, "Records:\n %s", records);
+        kfree(records);
+
+	return 0;
+}
+
+static int skw_sdio_channel_record_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, &skw_sdio_channel_record_show, inode->i_private);
+}
+
+static int skw_sdio_channel_record_control(const char *cmd, bool enable)
+{
+	u32 port_num = 0;
+
+	port_num = (u32)(cmd[4] - '0');
+	if (!strncmp("port", cmd, 4))
+		skw_sdio_channel_record_enable(port_num, enable);
+	else if (!strncmp("all", cmd, 3))
+		skw_sdio_channel_record_enable_all();
+	else
+		return -EINVAL;
+
+	return 0;
+}
+
+static ssize_t skw_sdio_channel_record_write(struct file *fp, const char __user *buffer,
+				size_t len, loff_t *offset)
+{
+	int i, idx;
+	char cmd[32];
+	bool enable = false;
+
+	for (idx = 0, i = 0; i < len; i++) {
+		char c;
+
+		if (get_user(c, buffer))
+			return -EFAULT;
+
+		switch (c) {
+		case ' ':
+			break;
+
+		case ':':
+			cmd[idx] = 0;
+			if (!strcmp("enable", cmd))
+				enable = true;
+			else
+				enable = false;
+			idx = 0;
+			break;
+
+		case '|':
+		case '\0':
+		case '\n':
+			cmd[idx] = 0;
+			skw_sdio_channel_record_control(cmd, enable);
+			idx = 0;
+			break;
+
+		default:
+			cmd[idx++] = c;
+			idx %= 32;
+
+			break;
+		}
+
+		buffer++;
+	}
+
+	return len;
+}
+
+static const struct file_operations skw_sdio_channel_record_fops = {
+	.owner = THIS_MODULE,
+	.open = skw_sdio_channel_record_open,
+	.read = seq_read,
+	.release = single_release,
+	.write = skw_sdio_channel_record_write,
+};
+
+void skw_sdio_log_level_init(void)
+{
+	skw_sdio_set_log_level(SKW_SDIO_INFO);
+
+	skw_sdio_enable_func_log(SKW_SDIO_DUMP, false);
+	skw_sdio_enable_func_log(SKW_SDIO_PORT0, false);
+	skw_sdio_enable_func_log(SKW_SDIO_PORT1, false);
+	skw_sdio_enable_func_log(SKW_SDIO_PORT2, false);
+	skw_sdio_enable_func_log(SKW_SDIO_PORT3, false);
+	skw_sdio_enable_func_log(SKW_SDIO_PORT4, false);
+	skw_sdio_enable_func_log(SKW_SDIO_PORT5, false);
+	skw_sdio_enable_func_log(SKW_SDIO_PORT6, false);
+	skw_sdio_enable_func_log(SKW_SDIO_SAVELOG, false);
+	skw_sdio_enable_func_log(SKW_SDIO_PORT7, false);
+	skw_sdio_add_debugfs("log_level", 0666, NULL, &skw_sdio_log_fops);
+	skw_sdio_add_debugfs("Version", 0666, NULL, &skw_version_fops);
+	skw_sdio_add_debugfs("Statistic", 0666, NULL, &skw_port_statistic_fops);
+	skw_sdio_add_debugfs("CPLog", 0666, NULL, &skw_cp_log_fops);
+	skw_sdio_add_debugfs("recovery", 0666, NULL, &skw_recovery_debug_fops);
+	skw_sdio_add_debugfs("dumpmem", 0666, NULL, &skw_dump_mem_fops);
+	skw_sdio_add_debugfs("BT_ANT", 0666, NULL, &skw_bluetooth_antenna_fops);
+	skw_sdio_add_debugfs("BT_UART1", 0666, NULL, &skw_bluetooth_UART1_fops);
+	skw_sdio_add_debugfs("WiFi", 0666, NULL, &skw_sdio_wifi_fops);
+	skw_sdio_add_debugfs("CHN_REC", 0666, NULL, &skw_sdio_channel_record_fops);
+	skw_sdio_procfs_file(NULL, "log_level", 0666, &skw_sdio_log_fops, NULL);
+	skw_sdio_procfs_file(NULL,"Version", 0666, &skw_version_fops,NULL);
+	skw_sdio_procfs_file(NULL, "Statistic", 0666, &skw_port_statistic_fops, NULL);
+	skw_sdio_procfs_file(NULL,"CPLog", 0666, &skw_cp_log_fops,NULL);
+	skw_sdio_procfs_file(NULL,"WiFi", 0666, &skw_sdio_wifi_fops,NULL);
+	skw_sdio_procfs_file(NULL,"recovery", 0666, &skw_recovery_debug_fops,NULL);
+	skw_sdio_procfs_file(NULL,"dumpmem", 0666, &skw_dump_mem_fops,NULL);
+	skw_sdio_procfs_file(NULL,"BT_ANT", 0666, &skw_bluetooth_antenna_fops,NULL);
+	skw_sdio_procfs_file(NULL,"BT_UART1", 0666, &skw_bluetooth_UART1_fops,NULL);
+	skw_sdio_procfs_file(NULL,"CHN_REC", 0666, &skw_sdio_channel_record_fops,NULL);
+}
diff --git a/drivers/misc/seekwaveplatform_v20/sdio/skw_sdio_log.h b/drivers/misc/seekwaveplatform_v20/sdio/skw_sdio_log.h
new file mode 100755
index 000000000000..ba566759ca28
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/sdio/skw_sdio_log.h
@@ -0,0 +1,85 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2020-2030  Seekwave Corporation.
+ *
+ *****************************************************************************/
+#ifndef __SKW_SDIO_LOG_H__
+#define __SKW_SDIO_LOG_H__
+
+#define SKW_SDIO_ERROR    BIT(0)
+#define SKW_SDIO_WARNING  BIT(1)
+#define SKW_SDIO_INFO     BIT(2)
+#define SKW_SDIO_DEBUG    BIT(3)
+
+#define SKW_SDIO_CMD      BIT(16)
+#define SKW_SDIO_EVENT    BIT(17)
+#define SKW_SDIO_SCAN     BIT(18)
+#define SKW_SDIO_TIMER    BIT(19)
+#define SKW_SDIO_STATE    BIT(20)
+
+#define SKW_SDIO_PORT0     BIT(21)
+#define SKW_SDIO_PORT1     BIT(22)
+#define SKW_SDIO_PORT2     BIT(23)
+#define SKW_SDIO_PORT3     BIT(24)
+#define SKW_SDIO_PORT4     BIT(25)
+#define SKW_SDIO_PORT5     BIT(26)
+#define SKW_SDIO_PORT6     BIT(27)
+#define SKW_SDIO_PORT7     BIT(28)
+#define SKW_SDIO_SAVELOG     BIT(29)
+#define SKW_SDIO_DUMP     BIT(31)
+
+unsigned long skw_sdio_log_level(void);
+unsigned long skw_sdio_channel_record_get(void);
+
+#define skw_sdio_log(level, fmt, ...) \
+	do { \
+		if (skw_sdio_log_level() & level) \
+			pr_err(fmt,  ##__VA_ARGS__); \
+	} while (0)
+
+#define skw_sdio_port_log(port_num, fmt, ...) \
+	do { \
+		if (skw_sdio_log_level() &(SKW_SDIO_PORT0<<port_num)) \
+			pr_err(fmt,  ##__VA_ARGS__); \
+	} while (0)
+
+#define skw_port_log(port_num,fmt, ...) \
+	skw_sdio_log((SKW_SDIO_PORT0<<port_num), "[PORT_LOG] %s: "fmt, __func__, ##__VA_ARGS__)
+
+#define skw_sdio_err(fmt, ...) \
+	skw_sdio_log(SKW_SDIO_ERROR, "[SKWSDIO ERROR] %s: "fmt, __func__, ##__VA_ARGS__)
+
+#define skw_sdio_warn(fmt, ...) \
+	skw_sdio_log(SKW_SDIO_WARNING, "[SKWSDIO WARN] %s: "fmt, __func__, ##__VA_ARGS__)
+
+#define skw_sdio_info(fmt, ...) \
+	skw_sdio_log(SKW_SDIO_INFO, "[SKWSDIO INFO] %s: "fmt, __func__, ##__VA_ARGS__)
+
+#define skw_sdio_dbg(fmt, ...) \
+	skw_sdio_log(SKW_SDIO_DEBUG, "[SKWSDIO DBG] %s: "fmt, __func__, ##__VA_ARGS__)
+
+#define skw_sdio_hex_dump(prefix, buf, len) \
+	do { \
+		if (skw_sdio_log_level() & SKW_SDIO_DUMP) { \
+			u8 str[32] = {0};  \
+			snprintf(str, sizeof(str), "[SKWSDIO DUMP] %s", prefix); \
+			print_hex_dump(KERN_ERR, str, \
+				DUMP_PREFIX_OFFSET, 16, 1, buf, len, true); \
+		} \
+	} while (0)
+
+#define skw_is_record_enable(port_num) \
+		(skw_sdio_channel_record_get() & (1<<(port_num)))
+
+#if 0
+#define skw_sdio_port_log(port_num, fmt, ...) \
+	do { \
+		if (skw_sdio_log_level() &(SKW_SDIO_PORT0<<port_num)) \
+			pr_err("[PORT_LOG] %s:"fmt,__func__,  ##__VA_ARGS__); \
+	} while (0)
+
+#endif
+void skw_sdio_log_level_init(void);
+void skw_sdio_channel_record_disable_all(void);
+#endif
+
diff --git a/drivers/misc/seekwaveplatform_v20/sdio/skw_sdio_main.c b/drivers/misc/seekwaveplatform_v20/sdio/skw_sdio_main.c
new file mode 100755
index 000000000000..a5289ccee999
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/sdio/skw_sdio_main.c
@@ -0,0 +1,1803 @@
+/*
+ * Copyright (C) 2021 Seekwave Tech Inc.
+ *
+ * Filename : skw_sdio.c
+ * Abstract : This file is a implementation for Seekwave sdio  function
+ *
+ * Authors	:
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+#include <linux/kthread.h>
+#include <linux/ktime.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/pm_runtime.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/core.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/sdio.h>
+#include <linux/mmc/sdio_func.h>
+#include "skw_sdio_log.h"
+#include "skw_sdio_debugfs.h"
+#include "skw_sdio.h"
+int bind_device=0;
+
+module_param(bind_device, int, S_IRUGO);
+#ifndef MMC_CAP2_SDIO_IRQ_NOTHREAD
+#define MMC_CAP2_SDIO_IRQ_NOTHREAD (1 << 17)
+#endif
+
+#define skw_sdio_transfer_enter() mutex_lock(&skw_sdio->transfer_mutex)
+#define skw_sdio_transfer_exit() mutex_unlock(&skw_sdio->transfer_mutex)
+
+static int cp_log_status = 0;
+irqreturn_t skw_gpio_irq_handler(int irq, void *dev_id); //interrupt
+//int (*skw_dloader)(unsigned int subsys);
+//static int skw_get_chipid(char *chip_id);
+static int check_chipid(void);
+static int skw_sdio_cp_reset(void);
+static int skw_sdio_cp_service_ops(int service_ops);
+static int skw_sdio_cpdebug_boot(void);
+struct skw_sdio_data_t *g_skw_sdio_data;
+static struct sdio_driver skw_sdio_driver;
+
+static int skw_sdio_set_dma_type(unsigned int address, unsigned int dma_type);
+static int skw_sdio_slp_feature_en(unsigned int address, unsigned int slp_en);
+static int skw_sdio_host_irq_init(unsigned int irq_gpio_num);
+static int skw_WIFI_service_start(void);
+static int skw_WIFI_service_stop(void);
+static int skw_BT_service_start(void);
+static int skw_BT_service_stop(void);
+extern int sdio_reset_comm(struct mmc_card *card);
+extern void kernel_restart(char *cmd);
+extern void skw_sdio_exception_work(struct work_struct *work);
+
+extern char skw_cp_ver;
+extern int max_ch_num;
+extern int max_pac_size;
+extern int skw_sdio_blk_size;
+extern char assert_context[];
+extern int  assert_context_size;
+extern struct debug_vars debug_infos;
+extern int cls_recovery_mode_en;
+
+struct skw_sdio_data_t *skw_sdio_get_data(void)
+{
+	return g_skw_sdio_data;
+}
+
+void skw_sdio_unlock_rx_ws(struct skw_sdio_data_t *skw_sdio)
+{
+
+	if (!atomic_read(&skw_sdio->rx_wakelocked))
+		return;
+	atomic_set(&skw_sdio->rx_wakelocked, 0);
+#ifdef CONFIG_WAKELOCK
+	__pm_relax(&skw_sdio->rx_wl.ws);
+#else
+	__pm_relax(skw_sdio->rx_ws);
+#endif
+}
+static void skw_sdio_lock_rx_ws(struct skw_sdio_data_t *skw_sdio)
+{
+	if (atomic_read(&skw_sdio->rx_wakelocked))
+		return;
+	atomic_set(&skw_sdio->rx_wakelocked, 1);
+#ifdef CONFIG_WAKELOCK
+	__pm_stay_awake(&skw_sdio->rx_wl.ws);
+#else
+	__pm_stay_awake(skw_sdio->rx_ws);
+#endif
+}
+static void skw_sdio_wakeup_source_init(struct skw_sdio_data_t *skw_sdio)
+{
+	if(skw_sdio) {
+#ifdef CONFIG_WAKELOCK
+	wake_lock_init(&skw_sdio->rx_wl, WAKE_LOCK_SUSPEND,"skw_sdio_r_wakelock");
+#else
+	skw_sdio->rx_ws = skw_wakeup_source_register(NULL, "skw_sdio_r_wakelock");
+#endif
+	}
+}
+static void skw_sdio_wakeup_source_destroy(struct skw_sdio_data_t *skw_sdio)
+{
+	if(skw_sdio) {
+#ifdef CONFIG_WAKELOCK
+	wake_lock_destroy(&skw_sdio->rx_wl);
+#else
+	wakeup_source_unregister(skw_sdio->rx_ws);
+#endif
+	}
+}
+
+void skw_resume_check(void)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	unsigned int timeout;
+
+	timeout = 0;
+	while((!atomic_read(&skw_sdio->resume_flag)) && (timeout++ < 20000))
+		usleep_range(1500, 2000);
+}
+
+static void skw_sdio_abort(int error_code)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	struct sdio_func *func0 = skw_sdio->sdio_func[FUNC_0];
+	unsigned char value;
+	int ret;
+	int err_code = error_code;
+
+	if((err_code == -EBUSY)&&!skw_sdio->cp_state){
+		skw_sdio_err(" tx erro coed:%d \n", err_code);
+		send_modem_assert_command();
+	}
+	sdio_claim_host(func0);
+
+	value = sdio_readb(func0, SDIO_VER_CCCR, &ret);
+
+	sdio_writeb(func0, SDIO_ABORT_TRANS, SKW_SDIO_CCCR_ABORT, &ret);
+
+	value = sdio_readb(func0, SDIO_VER_CCCR, &ret);
+	skw_sdio_err("SDIO Abort, SDIO_VER_CCCR:0x%x\n", value);
+
+	sdio_release_host(func0);
+}
+
+int skw_sdio_sdma_write(unsigned char *src, unsigned int len)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	struct sdio_func *func = skw_sdio->sdio_func[FUNC_1];
+	int blksize = func->cur_blksize;
+	int ret = 0;
+
+	if (!src || len%4) {
+		skw_sdio_err("%s invalid para %p, %d\n", __func__, src, len);
+		return -1;
+	}
+
+	len = (len + blksize -1)/blksize*blksize;
+
+	skw_resume_check();
+	skw_sdio_transfer_enter();
+	sdio_claim_host(func);
+	ret = sdio_writesb(func, SKW_SDIO_PK_MODE_ADDR, src, len);
+	if (ret < 0)
+		skw_sdio_err("%s  ret = %d\n", __func__, ret);
+	sdio_release_host(func);
+	if (ret) 
+		skw_sdio_abort(ret);
+	skw_sdio_transfer_exit();
+
+	return ret;
+}
+
+int skw_sdio_sdma_read(unsigned char *src, unsigned int len)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	struct sdio_func *func = skw_sdio->sdio_func[FUNC_1];
+	int ret = 0;
+
+	skw_resume_check();
+	skw_sdio_transfer_enter();
+	sdio_claim_host(func);
+	ret = sdio_readsb(func, src, SKW_SDIO_PK_MODE_ADDR, len);
+	sdio_release_host(func);
+	if (ret != 0)
+		skw_sdio_abort(ret);
+	skw_sdio_transfer_exit();
+	return ret;
+}
+
+void *skw_get_bus_dev(void)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	int time_count=0;
+	if((!skw_sdio->sdio_dev_host)||(!skw_sdio)){
+		skw_sdio_err("%d try again get sdio bus dev  \n", __LINE__);
+		do{
+			msleep(10);
+			time_count++;
+		}while(!skw_sdio->sdio_dev_host && time_count < 50);
+	}
+	if ((!skw_sdio->sdio_dev_host)||(!skw_sdio)) {
+		skw_sdio_err("sdio_dev_host is NULL!\n");
+		return NULL;
+	}
+	return &skw_sdio->sdio_func[FUNC_1]->dev;
+}
+
+int skw_sdio_gpio_irq_pre_ops(void)
+{
+	int ret =0;
+	struct sdio_func *func;
+	unsigned char exti_val = 0;
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	if(!skw_sdio->boot_data)
+		return -1;
+
+	switch (skw_sdio->cp_detect_sleep_mode){
+	    case 0:
+			skw_sdio_info("cp_detect_sleep_mode is 0\n");
+		break;
+		case 1:
+		case 2:
+			skw_sdio_info("cp_detect_sleep_mode is 1 or 2\n");
+			ret = skw_sdio_readb(SKW_SDIO_CP2AP_EXTI_GETVAL, &exti_val);
+			if(ret){
+				skw_sdio_err("read exti val fail exti:%d, ret=%d \n",exti_val, ret);
+				return -1;
+			}
+			skw_sdio->sdio_exti_gpio_state	 = exti_val;
+			func = skw_sdio->sdio_func[FUNC_1];
+			sdio_claim_host(func);
+			sdio_release_irq(func);
+			sdio_release_host(func);
+			skw_sdio->gpio_in = skw_sdio->boot_data->gpio_in;
+			skw_sdio->gpio_out = skw_sdio->boot_data->gpio_out;
+			skw_sdio->irq_type = SKW_SDIO_EXTERNAL_IRQ;
+			ret = skw_sdio_host_irq_init(skw_sdio->gpio_in);
+		break;
+		case 3:
+			if(skw_sdio->boot_data->gpio_out < 0){
+				skw_sdio->sdio_exti_gpio_state = 0;
+				skw_sdio_err("gpio_out is %d\n", skw_sdio->boot_data->gpio_out);
+				return -1;
+			}
+			skw_sdio_info("cp_detect_sleep_mode is 3\n");
+			gpio_set_value(skw_sdio->boot_data->gpio_out,0);
+			msleep(100);
+			loopcheck_send_data("APGPIORDY", 9);
+			ret = skw_sdio_readb(SKW_SDIO_CP2AP_EXTI_GETVAL, &exti_val);
+			if(ret){
+				skw_sdio_err("read exti val fail exti:%d, ret=%d \n",exti_val, ret);
+				return -1;
+			}
+			skw_sdio->sdio_exti_gpio_state = exti_val;
+			func = skw_sdio->sdio_func[FUNC_1];
+			sdio_claim_host(func);
+			sdio_release_irq(func);
+			sdio_release_host(func);
+			skw_sdio->gpio_in = skw_sdio->boot_data->gpio_in;
+			skw_sdio->gpio_out = skw_sdio->boot_data->gpio_out;
+			skw_sdio->irq_type = SKW_SDIO_EXTERNAL_IRQ;
+			ret = skw_sdio_host_irq_init(skw_sdio->gpio_in);
+		break;
+		default:
+			skw_sdio_info("cp_detect_sleep_mode is %d\n", skw_sdio->cp_detect_sleep_mode);
+		break;
+
+	}
+	if(ret)
+		skw_sdio_err("gpio irq init fail\n");
+	return ret;
+}
+
+static int skw_sdio_start_transfer(struct scatterlist *sgs, int sg_count,
+	int total, struct sdio_func *sdio_func, uint fix_inc, bool dir, uint addr)
+{
+	struct mmc_request mmc_req;
+	struct mmc_command mmc_cmd;
+	struct mmc_data mmc_dat;
+	struct mmc_host *host = sdio_func->card->host;
+	bool fifo = (fix_inc == SKW_SDIO_DATA_FIX);
+	uint fn_num = sdio_func->num;
+	uint blk_num, blk_size, max_blk_count, max_req_size;
+	int err_ret = 0;
+
+
+	blk_size = SKW_SDIO_BLK_SIZE;
+	max_blk_count = min_t(unsigned int, host->max_blk_count, (uint)MAX_IO_RW_BLK);
+	max_req_size = min_t(unsigned int,	max_blk_count*blk_size, host->max_req_size);
+
+	memset(&mmc_req, 0, sizeof(struct mmc_request));
+	memset(&mmc_cmd, 0, sizeof(struct mmc_command));
+	memset(&mmc_dat, 0, sizeof(struct mmc_data));
+
+	if (total % blk_size != 0) {
+		skw_sdio_err("total %d not aligned to blk size\n", total);
+		return -1;
+	}
+
+	blk_num = total / blk_size;
+	mmc_dat.sg = sgs;
+	mmc_dat.sg_len = sg_count;
+	mmc_dat.blksz = blk_size;
+	mmc_dat.blocks = blk_num;
+	mmc_dat.flags = dir ? MMC_DATA_WRITE : MMC_DATA_READ;
+	mmc_cmd.opcode = 53; /* SD_IO_RW_EXTENDED */
+	mmc_cmd.arg = dir ? 1<<31 : 0;
+	mmc_cmd.arg |= (fn_num & 0x7) << 28;
+	mmc_cmd.arg |= 1<<27;
+	mmc_cmd.arg |= fifo ? 0 : 1<<26;
+	mmc_cmd.arg |= (addr & 0x1FFFF) << 9;
+	mmc_cmd.arg |= blk_num & 0x1FF;
+	mmc_cmd.flags = MMC_RSP_SPI_R5 | MMC_RSP_R5 | MMC_CMD_ADTC;
+	mmc_req.cmd = &mmc_cmd;
+	mmc_req.data = &mmc_dat;
+	if (!fifo)
+		addr += total;
+	skw_sdio_dbg("total:%d sg_count:%d cmd_arg 0x%x\n", total, sg_count, mmc_cmd.arg);
+	sdio_claim_host(sdio_func);
+	mmc_set_data_timeout(&mmc_dat, sdio_func->card);
+	mmc_wait_for_req(host, &mmc_req);
+	sdio_release_host(sdio_func);
+
+	err_ret = mmc_cmd.error ? mmc_cmd.error : mmc_dat.error;
+	if (err_ret != 0) {
+		skw_sdio_err("%s:CMD53 %s failed error=%d\n",__func__,
+				  dir ? "write" : "read", err_ret);
+	}
+	return err_ret;
+}
+
+int skw_sdio_adma_write(int portno, struct scatterlist *sgs, int sg_count, int total)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	int ret = 0;
+
+	skw_resume_check();
+	skw_sdio_transfer_enter();
+	if(skw_sdio->resume_com==0)
+		skw_sdio->resume_com = 1; 
+	ret = skw_sdio_start_transfer(sgs, sg_count, SKW_SDIO_ALIGN_BLK(total),
+				  skw_sdio->sdio_func[FUNC_1], SKW_SDIO_DATA_FIX,
+				  SKW_SDIO_WRITE, SKW_SDIO_PK_MODE_ADDR);
+	if (ret) {
+		skw_sdio_abort(ret);
+	} else {
+		if (skw_sdio->device_active==0 && skw_sdio->irq_type)
+			skw_sdio->device_active = gpio_get_value(skw_sdio->gpio_in);
+	}
+	skw_sdio_transfer_exit();
+
+	return ret;
+}
+
+int skw_sdio_adma_read(struct skw_sdio_data_t *skw_sdio, struct scatterlist *sgs, int sg_count, int total)
+{
+	int ret = 0;
+
+	skw_resume_check();
+	skw_sdio_transfer_enter();
+	ret = skw_sdio_start_transfer(sgs, sg_count, total,
+				  skw_sdio->sdio_func[FUNC_1], SKW_SDIO_DATA_FIX,
+				  SKW_SDIO_READ, SKW_SDIO_PK_MODE_ADDR);
+	if (ret)
+		skw_sdio_abort(ret);
+	skw_sdio_transfer_exit();
+	return ret;
+}
+
+static int skw_sdio_dt_set_address(unsigned int address)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	struct sdio_func *func = skw_sdio->sdio_func[FUNC_0];
+	unsigned char value ;
+	int err = 0;
+	int i;
+
+	sdio_claim_host(func);
+	for (i = 0; i < 4; i++) {
+		value = (address >> (8 * i)) & 0xFF;
+		sdio_writeb(func, value, SKW_SDIO_FBR_REG+i, &err);
+		if (err != 0)
+			break;
+	}
+	sdio_release_host(func);
+
+	return err;
+}
+
+
+int skw_sdio_writel(unsigned int address, void *data)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	struct sdio_func *func = skw_sdio->sdio_func[FUNC_1];
+	int ret = 0;
+
+	skw_resume_check();
+	skw_sdio_transfer_enter();
+
+	ret = skw_sdio_dt_set_address(address);
+	if (ret != 0) {
+		skw_sdio_transfer_exit();
+		return ret;
+	}
+
+	sdio_claim_host(func);
+	sdio_writel(func, *(unsigned int *)data, SKW_SDIO_DT_MODE_ADDR, &ret);
+	sdio_release_host(func);
+	skw_sdio_transfer_exit();
+
+	if (ret) {
+		skw_sdio_err("%s fail ret:%d, addr=0x%x\n", __func__,
+				ret, address);
+		skw_sdio_abort(ret);
+	}
+
+	return ret;
+}
+
+int skw_sdio_readl(unsigned int address, void *data)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	struct sdio_func *func = skw_sdio->sdio_func[FUNC_1];
+	int ret = 0;
+
+	skw_resume_check();
+	skw_sdio_transfer_enter();
+	ret = skw_sdio_dt_set_address(address);
+	if (ret != 0) {
+		skw_sdio_transfer_exit();
+		return ret;
+	}
+
+	sdio_claim_host(func);
+
+	*(unsigned int *)data = sdio_readl(func, SKW_SDIO_DT_MODE_ADDR, &ret);
+
+	sdio_release_host(func);
+	skw_sdio_transfer_exit();
+	if (ret) {
+		skw_sdio_err("%s fail ret:%d, addr=0x%x\n", __func__, ret, address);
+		skw_sdio_abort(ret);
+	}
+
+	return ret;
+}
+/*
+ *command = 0: service_start else service stop
+ *service = 0: WIFI_service else BT service.
+ */
+int send_modem_service_command(u16 service, u16 command)
+{
+	u16 cmd;
+	int ret = 0;
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	if(command)
+		skw_sdio->service_state_map&= ~(1<<service);
+		//command = 1;
+	cmd = (service<<1)|command;
+	cmd = 1 << cmd;
+	if (cmd>>8) {
+		skw_sdio_err("service command error 0x%x!", cmd);
+			return -EINVAL;
+	}
+
+	if(skw_sdio->cp_state)
+		return -EINVAL;
+
+	ret = skw_sdio_writeb(SKW_AP2CP_IRQ_REG, cmd & 0xff);
+	skw_sdio_info("ret = %d command %x\n", ret, command);
+	return ret;
+}
+
+static unsigned int max_bytes(struct sdio_func *func)
+{
+	unsigned int mval = func->card->host->max_blk_size;
+
+	if (func->card->quirks & MMC_QUIRK_BLKSZ_FOR_BYTE_MODE)
+		mval = min(mval, func->cur_blksize);
+	else
+		mval = min(mval, func->max_blksize);
+
+	if (func->card->quirks & MMC_QUIRK_BROKEN_BYTE_MODE_512)
+		return min(mval, 511u);
+
+	/* maximum size for byte mode */
+	return min(mval, 512u);
+}
+
+int skw_sdio_dt_write(unsigned int address,	void *buf, unsigned int len)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	struct sdio_func *func = skw_sdio->sdio_func[FUNC_1];
+	unsigned int remainder = len;
+	unsigned int trans_len;
+	int ret = 0;
+	char *data= skw_sdio->next_size_buf;
+
+	skw_resume_check();
+	skw_sdio_transfer_enter();
+
+	ret = skw_sdio_dt_set_address(address);
+	if (ret != 0) {
+		skw_sdio_err("%s set address error!!!", __func__);
+		skw_sdio_transfer_exit();
+		return ret;
+	}
+
+	if(skw_sdio->resume_com==0)
+		skw_sdio->resume_com = 1;
+	sdio_claim_host(func);
+	while (remainder > 0) {
+		if (remainder >= func->cur_blksize)
+			trans_len = func->cur_blksize;
+		else
+			trans_len = min(remainder, max_bytes(func));
+		memcpy(data, buf,trans_len);
+		ret = sdio_memcpy_toio(func, SKW_SDIO_DT_MODE_ADDR, data, trans_len);
+		if (ret) {
+			skw_sdio_err("%s sdio_memcpy_toio failed!!!", __func__);
+			break;
+		}
+		remainder -= trans_len;
+		buf += trans_len;
+	}
+	sdio_release_host(func);
+	skw_sdio_transfer_exit();
+	if (ret) {
+		skw_sdio_err("dt write fail ret:%d, address=0x%x\n", ret, address);
+		skw_sdio_abort(ret);
+	}
+
+	return ret;
+}
+
+int skw_sdio_dt_read(unsigned int address, void *buf, unsigned int len)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	struct sdio_func *func = skw_sdio->sdio_func[FUNC_1];
+	unsigned int remainder = len;
+	unsigned int trans_len;
+	int ret = 0;
+
+	ret = skw_sdio_dt_set_address(address);
+
+	if(skw_sdio->resume_com==0)
+		skw_sdio->resume_com = 1; 
+	skw_sdio_transfer_enter();
+	sdio_claim_host(func);
+	while (remainder > 0) {
+		if (remainder >= func->cur_blksize)
+			trans_len = func->cur_blksize;
+		else
+			trans_len = min(remainder, max_bytes(func));
+		ret = sdio_memcpy_fromio(func, buf, SKW_SDIO_DT_MODE_ADDR, trans_len);
+		if (ret) {
+			skw_sdio_err("sdio_memcpy_fromio: %p 0x%x ret=%d\n", buf, *(uint32_t *)buf, ret);
+			break;
+		}
+		remainder -= trans_len;
+		buf += trans_len;
+	}
+	sdio_release_host(func);
+	skw_sdio_transfer_exit();
+	if (ret) {
+		skw_sdio_err("dt read fail ret:%d, address=0x%x\n", ret, address);
+		skw_sdio_abort(ret);
+	}
+
+	return ret;
+}
+
+int skw_sdio_readb(unsigned int address, unsigned char *value)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	struct sdio_func *func = skw_sdio->sdio_func[FUNC_0];
+	unsigned char reg = 0;
+	int err = 0;
+
+	sdio_claim_host(func);
+	reg = sdio_readb(func, address, &err);
+	if (value)
+		*value = reg;
+	sdio_release_host(func);
+	return err;
+}
+
+int skw_sdio_writeb(unsigned int address, unsigned char value)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	struct sdio_func *func = skw_sdio->sdio_func[FUNC_0];
+	int err = 0;
+
+	try_to_wakeup_modem(8);
+	sdio_claim_host(func);
+	sdio_writeb(func, value, address, &err);
+	sdio_release_host(func);
+
+	return err;
+}
+
+static int skw_sdio_host_irq_init(unsigned int irq_gpio_num)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	int ret = 0;
+
+	skw_sdio->device_active = gpio_get_value(skw_sdio->gpio_in);
+	skw_sdio->irq_num = gpio_to_irq(skw_sdio->gpio_in);
+	skw_sdio->irq_trigger_type = IRQF_TRIGGER_RISING;
+	skw_sdio_info("gpio_In:%d,gpio_out:%d irq %d\n",
+					skw_sdio->gpio_in, skw_sdio->gpio_out, skw_sdio->irq_num);
+	if (skw_sdio->irq_num) {
+		ret = request_irq(skw_sdio->irq_num, skw_gpio_irq_handler,
+				skw_sdio->irq_trigger_type | IRQF_ONESHOT, "skw-gpio-irq", NULL);
+		if (ret != 0) {
+			free_irq(skw_sdio->irq_num, NULL);
+			skw_sdio_err("%s request gpio irq fail ret=%d\n", __func__, ret);
+			return -1;
+		} else {
+			skw_sdio_dbg("gpio request_irq=%d  GPIO value %d!\n",
+					skw_sdio->irq_num, skw_sdio->device_active);
+		}
+	}
+	enable_irq_wake(skw_sdio->irq_num);
+	skw_sdio_rx_up(skw_sdio);
+	return ret;
+}
+
+irqreturn_t skw_host_wake_irq_handler(int irq, void *dev_id) //interrupt
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	int	value = gpio_get_value(skw_sdio->gpio_in);
+
+	skw_sdio_dbg("gpio request_irq=%d  GPIO value %d!\n", irq, value);
+	return IRQ_HANDLED;
+}
+
+static int skw_sdio_host_wake_irq_init(unsigned int irq_gpio_num)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	int ret = 0;
+
+	skw_sdio->device_active = gpio_get_value(skw_sdio->gpio_in);
+	skw_sdio->irq_num = gpio_to_irq(skw_sdio->gpio_in);
+	skw_sdio->irq_trigger_type = IRQF_TRIGGER_RISING;
+	skw_sdio_info("gpio_irq %d\n", skw_sdio->irq_num);
+	if (skw_sdio->irq_num) {
+		ret = request_irq(skw_sdio->irq_num, skw_host_wake_irq_handler,
+				skw_sdio->irq_trigger_type | IRQF_ONESHOT, "skw-gpio-irq", NULL);
+		if (ret != 0) {
+			free_irq(skw_sdio->irq_num, NULL);
+			skw_sdio_err("%s request gpio irq fail ret=%d\n", __func__, ret);
+			return -1;
+		} else {
+			skw_sdio_dbg("gpio request_irq=%d  GPIO value %d!\n",
+					skw_sdio->irq_num, skw_sdio->device_active);
+		}
+	}
+	enable_irq_wake(skw_sdio->irq_num);
+	return ret;
+}
+static int skw_sdio_get_dev_func(struct sdio_func *func)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+
+	if (func->num >= MAX_FUNC_NUM) {
+		skw_sdio_err("func num err!!! func num is %d!!!",
+			func->num);
+		return -1;
+	}
+	skw_sdio_dbg("func num is %d.", func->num);
+
+	if (func->num == 1) {
+		skw_sdio->sdio_func[FUNC_0] = kmemdup(func, sizeof(*func),
+							 GFP_KERNEL);
+		skw_sdio->sdio_func[FUNC_0]->num = 0;
+		skw_sdio->sdio_func[FUNC_0]->max_blksize = SKW_SDIO_BLK_SIZE;
+	}
+
+	skw_sdio->sdio_func[FUNC_1] = func;
+
+	return 0;
+}
+
+extern u64 skw_local_clock(void);
+void skw_sdio_inband_irq_handler(struct sdio_func *func)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	struct sdio_func *func0 = skw_sdio->sdio_func[FUNC_0];
+	int ret;
+
+	if (!debug_infos.cp_assert_time) {
+		debug_infos.last_irq_time = skw_local_clock();
+		debug_infos.last_irq_times[debug_infos.rx_inband_irq_cnt % CHN_IRQ_RECORD_NUM] = debug_infos.last_irq_time;
+		skw_sdio_dbg("irq coming %d\n", debug_infos.rx_inband_irq_cnt);
+	}
+	if (!SKW_CARD_ONLINE(skw_sdio)) {
+		skw_sdio_err("%s  card offline\n", __func__);
+		return;
+	}
+
+	skw_resume_check();
+
+	/* send cmd to clear cp int status */
+	sdio_claim_host(func0);
+	try_to_wakeup_modem(8);
+	sdio_f0_readb(func0, SDIO_CCCR_INTx, &ret);
+	if (!debug_infos.cp_assert_time) {
+		debug_infos.last_clear_irq_times[debug_infos.rx_inband_irq_cnt % CHN_IRQ_RECORD_NUM] = debug_infos.last_irq_time;
+		debug_infos.rx_inband_irq_cnt++;
+	}
+	sdio_release_host(func0);
+	if (ret < 0)
+		skw_sdio_err("%s error %d\n", __func__, ret);
+	skw_sdio_lock_rx_ws(skw_sdio);
+	skw_sdio_rx_up(skw_sdio);
+}
+
+int skw_sdio_enable_async_irq(void)
+{
+	int ret = 0;
+	u8 reg;
+
+	ret = skw_sdio_readb(SDIO_INT_EXT, &reg);
+	if (ret)
+		return ret;
+
+	reg |= 1 << 1; /* Enable Asynchronous Interrupt */
+
+	ret = skw_sdio_writeb(SDIO_INT_EXT, reg & 0xff);
+	if (ret)
+		return ret;
+	ret = skw_sdio_readb(SDIO_INT_EXT, &reg);
+	if (ret)
+		return ret;
+
+	if (!(reg & (1 << 1)))
+		skw_sdio_err("enable sdio async irq fail reg = 0x%x\n", reg);
+
+	return ret;
+}
+
+void skw_set_bt_suspend_flag(void)
+{
+        struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+
+	if (skw_sdio->gpio_out < 0 && skw_sdio->gpio_in) {
+		skw_sdio_host_wake_irq_init(skw_sdio->gpio_in);
+        	skw_sdio->bt_suspend_flags |= BT_SUSPEND_SUPPORT;
+        	skw_sdio_info(" BT suspend enable\n");
+	}
+}
+#ifdef CONFIG_PM_SLEEP
+static void skw_sdio_BT_resume(void)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	char resume_cmd[] = {0x01, 0x86, 0xFC, 0x01, 0x00};
+
+	if (skw_sdio->bt_suspend_flags & BT_SUSPEND_SUPPORT)
+		send_data_async(2, resume_cmd, sizeof(resume_cmd));
+}
+
+static void skw_sdio_BT_suspend(void)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	char suspend_cmd[] = {0x01, 0x86, 0xFC, 0x01, 0x01};
+
+	if (skw_sdio->bt_suspend_flags & BT_SUSPEND_SUPPORT)
+		send_data_async(2, suspend_cmd, sizeof(suspend_cmd));
+}
+
+static int skw_sdio_suspend(struct device *dev)
+{
+	struct sdio_func *func = container_of(dev, struct sdio_func, dev);
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	int  ret = 0;
+
+	skw_sdio_dbg("[%s]enter\n", __func__);
+
+	if (skw_sdio->cp_state != 0)
+		return -EBUSY;
+
+	atomic_set(&skw_sdio->resume_flag, 0);
+
+	if (SKW_CARD_ONLINE(skw_sdio))
+		func->card->host->pm_flags |= MMC_PM_KEEP_POWER;
+
+	func = skw_sdio->sdio_func[FUNC_1];
+	send_host_suspend_indication(skw_sdio);
+	if ((skw_sdio->irq_type == SKW_SDIO_INBAND_IRQ) && skw_sdio->resume_com) {
+		sdio_claim_host(func);
+		try_to_wakeup_modem(8);
+		msleep(1);
+		ret = sdio_release_irq(func);
+		sdio_release_host(func);
+		skw_sdio_dbg("%s sdio_release_irq ret = %d\n", __func__, ret);
+	} 
+	skw_sdio_BT_suspend();
+	atomic_set(&skw_sdio->suspending, 1);
+	skw_sdio->resume_com = 0;
+	return ret;
+}
+
+static int skw_sdio_resume(struct device *dev)
+{
+	struct sdio_func *func = container_of(dev, struct sdio_func, dev);
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	int ret = 0;
+
+	skw_sdio_dbg("[%s]enter\n", __func__);
+#if defined(SKW_BOOT_DEBUG)
+	skw_dloader(2);
+#endif
+
+	if (SKW_CARD_ONLINE(skw_sdio))
+		func->card->host->pm_flags &= ~MMC_PM_KEEP_POWER;
+
+	func = skw_sdio->sdio_func[FUNC_1];
+	send_host_resume_indication(skw_sdio);
+	if (!func->irq_handler && (skw_sdio->irq_type == SKW_SDIO_INBAND_IRQ)) {
+		sdio_claim_host(func);
+		try_to_wakeup_modem(8);
+		ret=sdio_claim_irq(func, skw_sdio_inband_irq_handler);
+		sdio_release_host(func);
+		if(ret < 0) {
+			skw_sdio_err("%s sdio_claim_irq ret = %d\n", __func__, ret);
+		} else {
+			ret = skw_sdio_enable_async_irq();
+			if (ret < 0)
+				skw_sdio_err("enable sdio async irq fail ret = %d\n", ret);
+		}
+	}
+	atomic_set(&skw_sdio->resume_flag, 1);
+	skw_sdio_BT_resume();
+	return ret;
+}
+#endif
+irqreturn_t skw_gpio_irq_handler(int irq, void *dev_id) //interrupt
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	int	value = gpio_get_value(skw_sdio->gpio_in);
+
+	if (!debug_infos.cp_assert_time) {
+		debug_infos.last_irq_time = skw_local_clock();
+		debug_infos.last_irq_times[debug_infos.rx_gpio_irq_cnt % CHN_IRQ_RECORD_NUM] = debug_infos.last_irq_time;
+		debug_infos.rx_gpio_irq_cnt++;
+		skw_sdio_dbg("irq coming %d\n", debug_infos.rx_gpio_irq_cnt);
+	}
+	if (!SKW_CARD_ONLINE(skw_sdio)) {
+		skw_sdio_err("%s card offline\n", __func__);
+		return IRQ_HANDLED;
+	}
+	if(!skw_sdio->suspend_wake_unlock_enable){
+		skw_sdio_dbg("suspend wake lock enable!!!!\n");
+		skw_sdio_lock_rx_ws(skw_sdio);
+	}
+
+	if (value && (skw_sdio->irq_type == SKW_SDIO_EXTERNAL_IRQ)){
+			skw_sdio_rx_up(skw_sdio);
+	 }
+	host_gpio_in_routine(value);
+
+	return IRQ_HANDLED;
+}
+
+static int skw_check_cp_ready(void)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	if (wait_for_completion_timeout(&skw_sdio->download_done,
+		msecs_to_jiffies(3000)) == 0) {
+		 skw_sdio_err("check CP-ready time out\n");
+		 return -ETIME;
+	}
+	return 0;
+}
+
+static int skw_sdio_probe(struct sdio_func *func, const struct sdio_device_id *id)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	struct mmc_host *host = func->card->host;
+	int ret;
+
+	skw_sdio_log(SKW_SDIO_INFO,"%s: func->class=%x, vendor=0x%04x, device=0x%04x, "
+		 "func_num=0x%04x, clock=%d blksize=0x%x max_blkcnt %d\n", __func__,
+		 func->class, func->vendor, func->device, func->num, host->ios.clock,
+		 func->cur_blksize,
+			 func->card->host->max_blk_count);
+
+	ret = skw_sdio_get_dev_func(func);
+	if (ret < 0) {
+		skw_sdio_err("get func err\n");
+		return ret;
+	}
+
+	skw_sdio->sdio_dev_host = skw_sdio->sdio_func[FUNC_1]->card->host;
+	if (skw_sdio->sdio_dev_host == NULL) {
+		skw_sdio_err("get host failed!!!");
+		return -1;
+	}
+
+	if (!skw_sdio->pwrseq) {
+		struct sdio_func *func1 = skw_sdio->sdio_func[FUNC_1];
+		/* Enable Function 1 */
+		sdio_claim_host(func1);
+		ret = sdio_enable_func(func1);
+
+		skw_sdio_info("sdio_enable_func ret=%d type %d\n", ret, skw_sdio->irq_type);
+		if(!ret) {
+			sdio_set_block_size(func1, SKW_SDIO_BLK_SIZE);
+			func1->max_blksize = SKW_SDIO_BLK_SIZE;
+			if (skw_sdio->irq_type == SKW_SDIO_INBAND_IRQ) {
+				if(sdio_claim_irq(func1,skw_sdio_inband_irq_handler)) {
+					skw_sdio_err("sdio_claim_irq failed\n");
+				} else {
+					ret = skw_sdio_enable_async_irq();
+					if (ret < 0)
+						skw_sdio_err("enable sdio async irq fail ret = %d\n", ret);
+				}
+			}
+			sdio_release_host(func1);
+		} else {
+			sdio_release_host(func1);
+			skw_sdio_err("enable func1 err!!! ret is %d\n", ret);
+			return ret;
+		}
+		skw_sdio->resume_com = 1;
+		skw_sdio_info("enable func1 done\n");
+	} else
+		pm_runtime_put_noidle(&func->dev);
+	if (!SKW_CARD_ONLINE(skw_sdio))
+		atomic_sub(SKW_SDIO_CARD_OFFLINE, &skw_sdio->online);
+
+	complete(&skw_sdio->scan_done);
+
+	check_chipid();
+	if(strncmp((char *)skw_sdio->chip_id,"SV6160",12))
+	{
+		struct sdio_func *func1 = skw_sdio->sdio_func[FUNC_1];
+		sdio_claim_host(func1);
+		skw_sdio->sdio_func[FUNC_0]->max_blksize = SKW_SDIO_BLK_SIZE;
+		sdio_set_block_size(func1, SKW_SDIO_BLK_SIZE);
+		func1->max_blksize = SKW_SDIO_BLK_SIZE;
+		sdio_release_host(func1);
+	}
+	/* the card is nonremovable */
+	skw_sdio->sdio_dev_host->caps |= MMC_CAP_NONREMOVABLE;
+	if (bind_device == 1) {
+		ret = skw_sdio_writeb(SKW_SDIO_PLD_DMA_TYPE,ADMA);
+		skw_sdio->adma_rx_enable = 1;
+		if(ret !=0){
+			skw_sdio_err("the dma type write fail ret:%d\n",ret);
+			return -1;
+		}
+		skw_sdio_info("line%d,adma type \n",  __LINE__);
+		send_modem_service_command(WIFI_SERVICE, SERVICE_START);
+	}else if (bind_device ==2){
+		ret = skw_sdio_writeb(SKW_SDIO_PLD_DMA_TYPE,SDMA);
+		skw_sdio->adma_rx_enable = 0;
+		if(ret !=0){
+			skw_sdio_err("the dma type write fail: %d\n",ret);
+			return -1;
+		}
+		send_modem_service_command(WIFI_SERVICE, SERVICE_START);
+		skw_sdio_info("the skw_sdio sdma write the pass\n");
+	}
+	skw_sdio_bind_platform_driver(skw_sdio->sdio_func[FUNC_1]);
+	skw_sdio_bind_btseekwave_driver(skw_sdio->sdio_func[FUNC_1]);
+	skw_sdio->service_state_map = 0;
+	skw_sdio->host_active = 1;
+	skw_sdio->power_off = 0;
+	return 0;
+}
+
+static void skw_sdio_remove(struct sdio_func *func)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+
+	skw_sdio_info("Enter\n");
+
+	complete(&skw_sdio->remove_done);
+
+	if (skw_sdio->irq_type == SKW_SDIO_INBAND_IRQ) {
+		sdio_claim_host(skw_sdio->sdio_func[FUNC_1]);
+		sdio_release_irq(skw_sdio->sdio_func[FUNC_1]);
+		sdio_release_host(skw_sdio->sdio_func[FUNC_1]);
+	} else if (skw_sdio->irq_num)
+		free_irq(skw_sdio->irq_num, NULL);
+
+	skw_sdio->host_active = 0;
+	skw_sdio_unbind_platform_driver(skw_sdio->sdio_func[FUNC_1]);
+	skw_sdio_unbind_WIFI_driver(skw_sdio->sdio_func[FUNC_1]);
+	skw_sdio_unbind_BT_driver(skw_sdio->sdio_func[FUNC_1]);
+	kfree(skw_sdio->sdio_func[FUNC_0]);
+}
+
+void skw_sdio_launch_thread(void)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+
+	init_completion(&skw_sdio->rx_completed);
+	skw_sdio_wakeup_source_init(skw_sdio);
+	skw_sdio->rx_thread =
+		kthread_create(skw_sdio_rx_thread, NULL, "skw_sdio_rx_thread");
+	if (skw_sdio->rx_thread) {
+#if KERNEL_VERSION(5, 9, 0) <= LINUX_VERSION_CODE
+		sched_set_fifo_low(skw_sdio->rx_thread);
+#else
+		struct sched_param param;
+		param.sched_priority = 1;
+		sched_setscheduler(skw_sdio->rx_thread, SCHED_FIFO, &param);
+#endif
+		kthread_bind(skw_sdio->rx_thread, cpumask_first(cpu_online_mask));
+		set_user_nice(skw_sdio->rx_thread, SKW_MIN_NICE);
+		wake_up_process(skw_sdio->rx_thread);
+	} else
+		skw_sdio_err("creat skw_sdio_rx_thread fail\n");
+}
+
+void skw_sdio_stop_thread(void)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+
+	if (skw_sdio->rx_thread) {
+		skw_sdio->threads_exit = 1;
+		skw_sdio_rx_up(skw_sdio);
+		kthread_stop(skw_sdio->rx_thread);
+		skw_sdio->rx_thread = NULL;
+		skw_sdio_wakeup_source_destroy(skw_sdio);
+	}
+	skw_sdio_info("done\n");
+}
+
+static const struct dev_pm_ops skw_sdio_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(skw_sdio_suspend, skw_sdio_resume)
+};
+
+static const struct sdio_device_id skw_sdio_ids[] = {
+	//{ .compatible = "seekwave-sdio", },
+	{SDIO_DEVICE(0, 0)},
+	{SDIO_DEVICE(0xABCD, 0x1234)},
+	{SDIO_DEVICE(0x1FFE, 0x6316)},
+	{},
+};
+
+static struct sdio_driver skw_sdio_driver = {
+	.probe = skw_sdio_probe,
+	.remove = skw_sdio_remove,
+	.name = "skw_sdio",
+	.id_table = skw_sdio_ids,
+	.drv = {
+		.pm = &skw_sdio_pm_ops,
+	},
+};
+
+void skw_sdio_remove_card(void)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+
+	init_completion(&skw_sdio->remove_done);
+	sdio_unregister_driver(&skw_sdio_driver);
+	skw_sdio_info(" sdio_unregister_driver\n");
+	if (wait_for_completion_timeout(&skw_sdio->remove_done,
+					msecs_to_jiffies(5000)) == 0)
+		skw_sdio_err("remove card time out\n");
+	else
+		skw_sdio_info("remove card end\n");
+
+}
+
+int skw_sdio_scan_card(void)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	int ret = 0;
+
+	skw_sdio_info("sdio_scan_card\n");
+
+	if (SKW_CARD_ONLINE(skw_sdio)) {
+		skw_sdio_info("card already online!, 0x%x\n", atomic_read(&skw_sdio->online));
+		skw_sdio_remove_card();
+		msleep(100);
+	}
+
+	init_completion(&skw_sdio->scan_done);
+	init_completion(&skw_sdio->download_done);
+	init_completion(&skw_sdio->device_wakeup);
+	init_waitqueue_head(&skw_sdio->wq);
+	//skw_sdio->irq_type = SKW_SDIO_EXTERNAL_IRQ;
+	skw_sdio->irq_type = SKW_SDIO_INBAND_IRQ;
+	ret = sdio_register_driver(&skw_sdio_driver);
+	if (ret != 0) {
+		skw_sdio_err("sdio_register_driver error :%d\n", ret);
+		return ret;
+	}
+	if (wait_for_completion_timeout(&skw_sdio->scan_done, msecs_to_jiffies(2000)) == 0) {
+		skw_sdio_err("wait scan card time out\n");
+		return -ENODEV;
+	}
+	if (!skw_sdio->sdio_dev_host) {
+		skw_sdio_err("sdio_dev_host is NULL!\n");
+		return -ENODEV;
+	}
+	skw_sdio_info("scan end!\n");
+
+	return ret;
+}
+
+/****************************************************************
+ *Description:sleep feature support en api
+ *Author:junwei.jiang
+ *Date:2023-06-14
+ * ************************************************************/
+static int skw_sdio_slp_feature_en(unsigned int address, unsigned int slp_en)
+{
+	int ret = 0;
+	ret = skw_sdio_writeb(address,slp_en);
+	if(ret !=0){
+		skw_sdio_err("no-sleep support en write fail, ret=%d\n",ret);
+		return -1;
+	}
+	skw_sdio_info("no-sleep_support_enable:%d\n ",slp_en);
+	return 0;
+}
+
+/****************************************************************
+ *Description:set the dma type SDMA, AMDA
+ *Author:junwei.jiang
+ *Date:2021-11-23
+ * ************************************************************/
+static int skw_sdio_set_dma_type(unsigned int address, unsigned int dma_type)
+{
+	int ret = 0;
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	if(dma_type == SDMA){
+		/*support the sdma so adma_rx_enable set 0*/
+		skw_sdio->adma_rx_enable = 0;
+	}
+	if(!bind_device){
+		ret = skw_sdio_writeb(address,dma_type);
+		if(ret !=0){
+			skw_sdio_err("dma type write fail, ret=%d\n",ret);
+			return -1;
+		}
+	}
+	skw_sdio_info("dma_type=%d,adma_rx_enable:%d\n ",dma_type,skw_sdio->adma_rx_enable);
+	return 0;
+}
+
+/****************************************************************
+*Description:
+*Func:used the ap boot cp interface;
+*Output:the dloader the bin to cp
+*Return0:pass; other : fail
+*AuthorJUNWEI.JIANG
+*Date:2021-09-07
+****************************************************************/
+static int skw_sdio_boot_cp(int boot_mode)
+{
+	int ret =0;
+
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+
+	skw_sdio_enable_async_irq();
+	skw_sdio_set_dma_type(skw_sdio->boot_data->dma_type_addr,
+			skw_sdio->boot_data->dma_type);
+	skw_sdio_slp_feature_en(skw_sdio->boot_data->slp_disable_addr,
+			skw_sdio->boot_data->slp_disable);
+	//2:download the boot bin 1CPALL 2, wifi 3,bt
+	skw_sdio_info("DOWNLOAD BIN TO CP\n");
+	if(skw_sdio->boot_data->dram_dl_size)
+		ret = skw_sdio_dt_write(skw_sdio->boot_data->dram_dl_addr,
+				skw_sdio->boot_data->dram_img_data,skw_sdio->boot_data->dram_dl_size);
+	if(skw_sdio->boot_data->iram_dl_size)
+		ret = skw_sdio_dt_write(skw_sdio->boot_data->iram_dl_addr,
+				skw_sdio->boot_data->iram_img_data,skw_sdio->boot_data->iram_dl_size);
+	if(ret !=0)
+		goto FAIL;
+	//first boot need the setup cp first_dl_flag=0 is first
+	skw_sdio_info("line:%d write the download done flag\n", __LINE__);
+	if(skw_sdio->cp_state){
+		ret = skw_sdio_writeb(SKW_SDIO_AP2CP_EXTI_SETVAL,(skw_sdio->sdio_exti_gpio_state)&0xff);
+		skw_sdio_info("the ---------exti gpio state is %d\n",(skw_sdio->sdio_exti_gpio_state)&0xff);
+	}
+	ret= skw_sdio_writeb(skw_sdio->boot_data->save_setup_addr,BIT(0));
+	if(ret !=0)
+		goto FAIL;
+
+	return ret;
+FAIL:
+	skw_sdio_err("line:%d  fail ret=%d\n",__LINE__, ret);
+	return ret;
+}
+
+/************************************************************************
+ *Decription:release CP close the CP log
+ *Author:junwei.jiang
+ *Date:2023-02-16
+ *Modfiy:
+ *
+ ********************************************************************* */
+int skw_sdio_cp_log(int disable)
+{
+	int ret = 0;
+
+	cp_log_status = disable;
+	ret= skw_sdio_writeb(SDIOHAL_CPLOG_TO_AP_SWITCH, disable);
+	if(ret <0){
+		skw_sdio_err("close the log signal send fail ret=%d\n", ret);
+		return ret;
+	}
+	skw_sdio_writeb(SKW_AP2CP_IRQ_REG, BIT(5));
+	if(!disable)
+		skw_sdio_info("line:%d enable the CP log TO AP!!\n", __LINE__);
+	else
+		skw_sdio_info("line:%d disable the CP log !!\n", __LINE__);
+
+	return 0;
+}
+
+int skw_sdio_cp_log_status(void)
+{
+	return cp_log_status;
+}
+/************************************************************************
+ *Decription:send WIFI start command to modem.
+ *Author:junwei.jiang
+ *Date:2022-10-27
+ *Modfiy:
+ *
+ ********************************************************************* */
+static int skw_WIFI_service_start(void)
+{
+	int ret;
+
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	skw_sdio_info("Enter STARTWIFI cp_state:%d\n",skw_sdio->cp_state);
+	if (skw_sdio->service_state_map & (1<<WIFI_SERVICE))
+		return 0;
+
+	mutex_lock(&skw_sdio->except_mutex);
+	if(skw_sdio->service_state_map==0 && skw_sdio->power_off){
+		skw_reinit_completion(skw_sdio->download_done);
+		skw_recovery_mode();
+	}
+#ifdef CONFIG_SEEKWAVE_PLD_RELEASE
+	skw_sdio_cp_log(1);
+#endif
+	skw_reinit_completion(skw_sdio->download_done);
+	ret = send_modem_service_command(WIFI_SERVICE, SERVICE_START);
+	if (ret==0)
+		ret = skw_check_cp_ready();
+	mutex_unlock(&skw_sdio->except_mutex);
+	return ret;
+}
+/************************************************************************
+ *Decription: send WIFI stop command to modem.
+  *Author:junwei.jiang
+ *Date:2022-10-27
+ *Modfiy:
+ *
+ ********************************************************************* */
+static int skw_WIFI_service_stop(void)
+{
+	int ret = 0;
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	skw_sdio_info("Enter,STOPWIFI  cp_state:%d",skw_sdio->cp_state);
+	if(skw_sdio->cp_state)
+		return 0;
+	mutex_lock(&skw_sdio->except_mutex);
+	if (skw_sdio->service_state_map & (1<<WIFI_SERVICE))
+		ret = send_modem_service_command(WIFI_SERVICE, SERVICE_STOP);
+	if (!skw_sdio->cp_state &&ret==0 && skw_sdio->service_state_map==0) {
+#ifdef CONFIG_NO_SERVICE_PD
+		gpio_set_value(skw_sdio->chip_en, 0);
+		printk("chip power off %d\n", ret);
+		skw_sdio->power_off = 1;
+#endif		
+	}
+	mutex_unlock(&skw_sdio->except_mutex);
+	return ret;
+}
+/************************************************************************
+ *Decription:send BT start command to modem.
+ *Author:junwei.jiang
+ *Date:2022-10-27
+ *Modfiy:
+ *
+ ********************************************************************* */
+static int skw_BT_service_start(void)
+{
+	int ret;
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	skw_sdio_info("Enter cpstate=%d\n",skw_sdio->cp_state);
+
+	if(assert_context_size)
+		skw_sdio_info("%s\n", assert_context);
+	if (skw_sdio->service_state_map & (1<<BT_SERVICE))
+		return 0;
+
+	mutex_lock(&skw_sdio->except_mutex);
+	if (skw_sdio->service_state_map==0 && skw_sdio->power_off) {
+		//skw_reinit_completion(skw_sdio->download_done);
+		skw_recovery_mode();
+		msleep(100);
+	}
+#ifdef CONFIG_SEEKWAVE_PLD_RELEASE
+	skw_sdio_cp_log(1);
+#endif
+	skw_reinit_completion(skw_sdio->download_done);
+	ret = send_modem_service_command(BT_SERVICE, SERVICE_START);
+	if (ret==0)
+		ret = skw_check_cp_ready();
+	mutex_unlock(&skw_sdio->except_mutex);
+	return ret;
+}
+
+/************************************************************************
+ *Decription:send BT stop command to modem.
+ *Author:junwei.jiang
+ *Date:2022-10-27
+ *Modfiy:
+ *
+ ********************************************************************* */
+static int skw_BT_service_stop(void)
+{
+	int ret = 0;
+
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	skw_sdio_info("Enter cpstate=%d\n",skw_sdio->cp_state);
+	if(skw_sdio->cp_state)
+		return 0;
+
+	mutex_lock(&skw_sdio->except_mutex);
+	if (skw_sdio->service_state_map & (1<<BT_SERVICE)&& !skw_sdio->cp_state){
+		skw_reinit_completion(skw_sdio->download_done);
+		ret = send_modem_service_command(BT_SERVICE, SERVICE_STOP);
+	}
+
+	if (!skw_sdio->cp_state && ret==0 && skw_sdio->service_state_map==0) {
+#ifdef CONFIG_NO_SERVICE_PD
+		gpio_set_value(skw_sdio->chip_en, 0);
+		skw_sdio->power_off = 1;
+#endif
+	}
+	mutex_unlock(&skw_sdio->except_mutex);
+	return ret;
+}
+
+/****************************************************************
+*Description:
+*Func:used the ap boot cp interface;
+*Output:the dloader the bin to cp
+*Return0:pass; other : fail
+*AuthorJUNWEI.JIANG
+*Date:2021-09-07
+****************************************************************/
+static int skw_sdio_cp_service_ops(int service_ops)
+{
+	int ret =0;
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+
+	switch(service_ops)
+	{
+		case SKW_WIFI_START:
+			wait_event_interruptible_timeout(skw_sdio->wq,
+				!skw_sdio->cp_state, msecs_to_jiffies(2000));
+			ret=skw_WIFI_service_start();
+			skw_sdio_dbg("-----WIFI SERIVCE START\n");
+		break;
+		case SKW_WIFI_STOP:
+			ret=skw_WIFI_service_stop();
+			skw_sdio_dbg("----WIFI SERVICE---STOP\n");
+		break;
+		case SKW_BT_START:
+			wait_event_interruptible_timeout(skw_sdio->wq,
+				!skw_sdio->cp_state, msecs_to_jiffies(2000));
+			ret =skw_BT_service_start();
+			skw_sdio_dbg("-----BT SERIVCE --START\n");
+		break;
+		case SKW_BT_STOP:
+			ret=skw_BT_service_stop();
+			skw_sdio_dbg("-----BT SERVICE --STOP\n");
+		break;
+		default:
+			skw_sdio_info("service not support!\n");
+		break;
+	}
+	return 0;
+}
+/****************************************************************
+*Description:skw_boot_loader
+*Func:used the ap boot cp interface;
+*Output:the dloader the bin to cp
+*Return0:pass; other : fail
+*AuthorJUNWEI.JIANG
+*Date:2021-09-07
+****************************************************************/
+int skw_boot_loader(struct seekwave_device *boot_data)
+{
+	int ret =0;
+	//struct sdio_func *func;
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	skw_sdio->boot_data= boot_data;
+	if(skw_sdio->power_off)
+		boot_data->dl_module = RECOVERY_BOOT;
+	if(boot_data->dl_module== RECOVERY_BOOT && !skw_sdio_recovery_debug_status()){
+		skw_recovery_mode();
+	}else{
+		if(!skw_sdio->boot_data->first_dl_flag){
+			if(!strncmp((char *)skw_sdio->chip_id,"SV6160",12)){
+				boot_data->chip_id = 0x6160;
+				skw_sdio_info("boot chip id 0x%x\n", boot_data->chip_id);
+			}else if(!strncmp((char *)skw_sdio->chip_id,"SV6160LITE",12)){
+				boot_data->chip_id = 0x616001;
+				skw_sdio_info("boot chip id 0x%x\n", boot_data->chip_id);
+			}
+
+			skw_sdio->chip_en = boot_data->chip_en;
+			skw_sdio->gpio_in = boot_data->gpio_in;
+			skw_sdio->gpio_out = boot_data->gpio_out;
+			if(skw_sdio->boot_data->iram_dl_size&&
+					skw_sdio->boot_data->dram_dl_size){
+				ret=skw_sdio_boot_cp(SKW_FIRST_BOOT);
+			}else{
+				ret=skw_sdio_cpdebug_boot();
+			}
+			if(ret!=0)
+				goto FAIL;
+			ret = skw_check_cp_ready();
+			if(!ret){
+#if 0
+				if(!skw_sdio->boot_data->first_dl_flag){
+					if(skw_sdio->boot_data->gpio_in >= 0) {
+						func = skw_sdio->sdio_func[FUNC_1];
+						sdio_claim_host(func);
+						try_to_wakeup_modem(8);
+						ret = sdio_release_irq(func);
+						sdio_release_host(func);
+						skw_sdio->irq_type = SKW_SDIO_EXTERNAL_IRQ;
+						skw_sdio_host_irq_init(skw_sdio->gpio_in);
+					}
+				}
+#endif
+				skw_sdio_bind_WIFI_driver(skw_sdio->sdio_func[FUNC_1]);
+#ifndef CONFIG_SKW_BT
+				skw_sdio_bind_BT_driver(skw_sdio->sdio_func[FUNC_1]);
+#endif
+			}
+		}
+	}
+	/*------CP SERVICE OPS----------*/
+	ret=skw_sdio_cp_service_ops(skw_sdio->boot_data->service_ops);
+	if(ret!=0)
+		goto FAIL;
+	skw_sdio_info("boot loader ops end!!!\n");
+	return 0;
+FAIL:
+	skw_sdio_err("line:%d  fail ret=%d\n", __LINE__, ret);
+	return ret;
+}
+void get_bt_antenna_mode(char *mode)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	struct seekwave_device *boot_data = skw_sdio->boot_data;
+	u32 bt_antenna = boot_data->bt_antenna;
+
+	if(bt_antenna==0)
+		return;
+	bt_antenna--;
+	if(!mode)
+		return;
+	if (bt_antenna)
+		sprintf(mode,"bt_antenna : alone\n");
+	else
+		sprintf(mode,"bt_antenna : share\n");
+}
+
+void reboot_to_change_bt_antenna_mode(char *mode)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	struct seekwave_device *boot_data = skw_sdio->boot_data;
+	u32 *data = (u32 *) &boot_data->iram_img_data[boot_data->head_addr-4];
+	u32 bt_antenna;
+
+	if(boot_data->bt_antenna == 0)
+		return;
+
+	bt_antenna = boot_data->bt_antenna - 1;
+	bt_antenna = 1 - bt_antenna;
+	data[0] = (bt_antenna) | 0x80000000;
+	if(!mode)
+		return;
+	if (bt_antenna==1) {
+		boot_data->bt_antenna = 2;
+		sprintf(mode,"bt_antenna : alone\n");
+	} else {
+		boot_data->bt_antenna = 1;
+		sprintf(mode,"bt_antenna : share\n");
+	}
+	//skw_recovery_mode();
+	send_modem_assert_command();
+}
+
+void reboot_to_change_bt_uart1(char *mode)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	struct seekwave_device *boot_data = skw_sdio->boot_data;
+	u32 *data = (u32 *) &boot_data->iram_img_data[boot_data->head_addr-4];
+
+	if(data[0] & 0x80000000)
+		data[0] |=  0x0000008;
+	else
+		data[0] = 0x80000008;
+	//skw_recovery_mode();
+	send_modem_assert_command();
+}
+
+/****************************************************************
+*Description:check dev ready
+*Func:used the ap boot cp interface;
+*Calls:sdio or usb
+*Call By:host dev ready
+*Input:NULL
+*Output:pass :0 or fail ENODEV
+*Others:
+*AuthorJUNWEI.JIANG
+*Date:2022-06-09
+****************************************************************/
+int skw_reset_bus_dev(void)
+{
+	return 0;
+}
+
+/****************************************************************
+*Description:skw_get_chipid
+*Func:used the ap boot cp interface;
+*Calls:boot data
+*Call By:the ap host
+*Input:the boot data informations
+*Output:the dloader the bin to cp
+*Return0:pass; other : fail
+*Others:
+*AuthorJUNWEI.JIANG
+*Date:2021-10-11
+****************************************************************/
+static void skw_sdio_reset_card(void)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+
+#if KERNEL_VERSION(5, 10, 0) <= LINUX_VERSION_CODE
+	gpio_set_value(skw_sdio->chip_en, 0);
+	msleep(2);
+	gpio_set_value(skw_sdio->chip_en, 1);
+	msleep(5);
+	sdio_claim_host(skw_sdio->sdio_func[FUNC_1]);
+	if (NULL != skw_sdio->sdio_dev_host->card)
+		mmc_sw_reset(skw_sdio->sdio_dev_host->card);
+
+	sdio_release_host(skw_sdio->sdio_func[FUNC_1]);	
+#else
+#if KERNEL_VERSION(4, 10, 0) > LINUX_VERSION_CODE
+	gpio_set_value(skw_sdio->chip_en, 0);
+	msleep(20);
+	gpio_set_value(skw_sdio->chip_en, 1);
+	msleep(50);
+#endif
+    sdio_reset_comm((skw_sdio->sdio_dev_host->card));
+	//mmc_hw_reset(skw_sdio->sdio_dev_host);
+#endif
+	skw_sdio_info("the reset sdio host pass \n");
+
+}
+
+static int skw_sdio_cp_reset(void)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	struct sdio_func *func = skw_sdio->sdio_func[FUNC_1];
+	int ret;
+
+	if (skw_sdio->irq_type == SKW_SDIO_INBAND_IRQ){
+		sdio_claim_host(func);
+		ret=sdio_release_irq(func);
+		sdio_release_host(func);
+		if(ret < 0)
+			skw_sdio_err("%s sdio_release_irq ret = %d\n", __func__, ret);
+	}
+
+	skw_sdio_reset_card();
+	msleep(5);
+	/* Enable Function 1 */
+	sdio_claim_host(skw_sdio->sdio_func[FUNC_1]);
+	ret = sdio_enable_func(skw_sdio->sdio_func[FUNC_1]);
+	sdio_set_block_size(skw_sdio->sdio_func[FUNC_1],
+			SKW_SDIO_BLK_SIZE);
+	skw_sdio->sdio_func[FUNC_1]->max_blksize = SKW_SDIO_BLK_SIZE;
+	if (skw_sdio->irq_type == SKW_SDIO_INBAND_IRQ){
+		ret=sdio_claim_irq(skw_sdio->sdio_func[FUNC_1], skw_sdio_inband_irq_handler);
+		if(ret < 0) {
+			skw_sdio_err("%s sdio_claim_irq ret = %d\n", __func__, ret);
+		} else {
+			ret = skw_sdio_enable_async_irq();
+			if (ret < 0)
+				skw_sdio_err("enable sdio async irq fail ret = %d\n", ret);
+		}
+	}
+	sdio_release_host(skw_sdio->sdio_func[FUNC_1]);
+	if (ret < 0) {
+		skw_sdio_err("enable func1 err!!! ret is %d\n", ret);
+		return -1;
+	}
+	skw_sdio_info("CP RESET OK!\n");
+	return 0;
+}
+/****************************************************************
+*Description:skw_sdio_cpdebug_boot
+*Func:used the ap boot cp interface;
+*Others:
+*AuthorJUNWEI.JIANG
+*Date:2022-07-15
+****************************************************************/
+static int skw_sdio_cpdebug_boot(void)
+{
+	int ret =0;
+	struct sdio_func *func;
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+
+	skw_sdio_info("not download CP from AP!!!!\n");
+	skw_sdio_set_dma_type(skw_sdio->boot_data->dma_type_addr,
+			skw_sdio->boot_data->dma_type);
+	skw_sdio_slp_feature_en(skw_sdio->boot_data->slp_disable_addr,
+			skw_sdio->boot_data->slp_disable);
+	if(skw_sdio->gpio_in >= 0 && skw_sdio->gpio_out >=0 &&
+		(!skw_sdio->boot_data->first_dl_flag)) {
+		func = skw_sdio->sdio_func[FUNC_1];
+		sdio_claim_host(func);
+		try_to_wakeup_modem(8);
+		ret = sdio_release_irq(func);
+		sdio_release_host(func);
+		skw_sdio->irq_type = SKW_SDIO_EXTERNAL_IRQ;
+		skw_sdio_host_irq_init(skw_sdio->gpio_in);
+	}
+	skw_sdio_info(" CP DUEBGBOOT Done!!!\n");
+	return 0;
+}
+
+/****************************************************************
+*Description:skw_recovery_mode
+*Func:used the ap boot cp interface;
+*Calls:boot data
+*Call By:the ap host
+*Input:the boot data informations
+*Output:reset cp
+*Return0:pass; other : fail
+*Others:
+*AuthorJUNWEI.JIANG
+*Date:2022-07-15
+****************************************************************/
+int skw_recovery_mode(void)
+{
+	int ret=0;
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	skw_sdio_info("the CHIPID:%s \n", (char *)&skw_sdio->chip_id);
+
+	if(!skw_sdio->boot_data->iram_dl_size || !skw_sdio->boot_data->dram_dl_size
+		|| (cls_recovery_mode_en &&skw_sdio->cp_state)){
+		skw_sdio_err("CP DEBUG BOOT NO NEED RECOVERY!! \n");
+		return -1;
+	}
+	ret=skw_sdio_cp_reset();
+	if(ret!=0){
+		skw_sdio_err("CP RESET fail \n");
+		return -2;
+	}
+	skw_sdio->power_off = 0;
+	ret = skw_sdio_boot_cp(RECOVERY_BOOT);
+	//ret |= skw_check_cp_ready();
+	if(ret!=0){
+		skw_sdio_err("CP RESET fail \n");
+		return -1;
+	}
+	skw_sdio_info("Recovery ok\n");
+	return ret;
+}
+
+static int check_chipid(void)
+{
+	int ret;
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+
+	ret = skw_sdio_dt_read(SKW_CHIP_ID0, skw_sdio->chip_id, SKW_CHIP_ID_LENGTH);
+	if(!strncmp((char *)skw_sdio->chip_id,"SV6160",12)){
+		skw_cp_ver = SKW_SDIO_V10;
+		max_ch_num = MAX_CH_NUM;
+		max_pac_size = MAX_PAC_SIZE;
+		skw_sdio_blk_size = 256;
+		skw_sdio_info("Chip id:%s used SDIO10",(char *)skw_sdio->chip_id);
+	}else if(!strncmp((char *)skw_sdio->chip_id,"SV6160LITE",12)){
+		skw_cp_ver = SKW_SDIO_V20;
+		max_ch_num = SDIO2_MAX_CH_NUM;
+		max_pac_size = MAX2_PAC_SIZE;
+		skw_sdio_blk_size = 512;
+		skw_sdio_info("Chip id:%s used SDIO20 ", (char *)skw_sdio->chip_id);
+	}else{
+		skw_cp_ver = SKW_SDIO_V20;
+		max_ch_num = SDIO2_MAX_CH_NUM;
+		max_pac_size = MAX2_PAC_SIZE;
+		skw_sdio_blk_size = 512;
+		skw_sdio_info("Chip id:%s used SDIO20 ", (char *)skw_sdio->chip_id);
+	}
+	if(ret<0){
+		skw_sdio_err("Get the chip id fail!!\n");
+		return ret;
+	}
+	return 0;
+}
+#if 0
+static int skw_get_chipid(char *chip_id)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	chip_id = (char *)&skw_sdio->chip_id;
+	skw_sdio_info("---the chip id---%s\n", (char *)skw_sdio->chip_id);
+	return 0;
+}
+#endif
+static int __init skw_sdio_io_init(void)
+{
+	struct skw_sdio_data_t *skw_sdio;
+	int ret = 0;
+	cls_recovery_mode_en=0;
+	memset(&debug_infos, 0, sizeof(struct debug_vars));
+	skw_sdio_debugfs_init();
+	skw_sdio_log_level_init();
+
+	skw_sdio = kzalloc(sizeof(struct skw_sdio_data_t), GFP_KERNEL);
+	if (!skw_sdio) {
+		WARN_ON(1);
+		return -ENOMEM;
+	}
+
+	/* card not ready */
+	g_skw_sdio_data = skw_sdio;
+	mutex_init(&skw_sdio->transfer_mutex);
+	mutex_init(&skw_sdio->except_mutex);
+	atomic_set(&skw_sdio->resume_flag, 1);
+	skw_sdio->next_size_buf = kzalloc(SKW_BUF_SIZE, GFP_KERNEL);
+	if(skw_sdio->next_size_buf == NULL){
+		kfree(skw_sdio);
+		return -ENOMEM;
+	}
+	skw_sdio->eof_buf = kzalloc(SKW_BUF_SIZE, GFP_KERNEL);
+	atomic_set(&skw_sdio->online, SKW_SDIO_CARD_OFFLINE);
+	if(!bind_device){
+		skw_sdio->adma_rx_enable = 1;
+	}
+	INIT_DELAYED_WORK(&skw_sdio->skw_except_work, skw_sdio_exception_work);
+	skw_sdio_launch_thread();
+	skw_sdio_scan_card();
+	skw_sdio_info(" OK\n");
+	seekwave_boot_init();
+	return ret;
+}
+
+static void __exit  skw_sdio_io_exit(void)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+
+	seekwave_boot_exit();
+	skw_sdio_debugfs_deinit();
+	skw_sdio_stop_thread();
+	if (SKW_CARD_ONLINE(skw_sdio)) {
+		skw_sdio_remove_card();
+	}
+	skw_sdio_reset_card();
+	cancel_delayed_work_sync(&skw_sdio->skw_except_work);
+	mutex_destroy(&skw_sdio->transfer_mutex);
+	mutex_destroy(&skw_sdio->except_mutex);
+	if (skw_sdio) {
+		kfree(skw_sdio->next_size_buf);
+		kfree(skw_sdio->eof_buf);
+		skw_sdio->boot_data = NULL;
+		skw_sdio->sdio_dev_host = NULL;
+		kfree(skw_sdio);
+		skw_sdio = NULL;
+	}
+	skw_sdio_info(" OK\n");
+}
+module_init(skw_sdio_io_init)
+module_exit(skw_sdio_io_exit)
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/misc/seekwaveplatform_v20/sdio/skw_sdio_rx.c b/drivers/misc/seekwaveplatform_v20/sdio/skw_sdio_rx.c
new file mode 100755
index 000000000000..37d06aeb592b
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/sdio/skw_sdio_rx.c
@@ -0,0 +1,2929 @@
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kref.h>
+#include <linux/uaccess.h>
+#include <linux/usb.h>
+#include <linux/mutex.h>
+#include <linux/bitops.h>
+#include <linux/kthread.h>
+#include <linux/notifier.h>
+#include <linux/platform_device.h>
+#include <linux/scatterlist.h>
+#include <linux/dma-mapping.h>
+#include <linux/semaphore.h>
+#include <linux/module.h>
+#include <linux/list.h>
+#include <linux/timer.h>
+#include <linux/err.h>
+#include <linux/gpio.h>
+#include <linux/mmc/sdio_func.h>
+#include <linux/skbuff.h>
+#include "skw_sdio.h"
+#include "skw_sdio_log.h"
+#include <linux/workqueue.h>
+#define MODEM_ASSERT_TIMEOUT_VALUE  2*HZ
+#define MAX_SG_COUNT	100
+#define SDIO_BUFFER_SIZE	(16*1024)
+#define MAX_FIRMWARE_SIZE 256
+#define PORT_STATE_IDLE	0
+#define PORT_STATE_OPEN	1
+#define PORT_STATE_CLSE	2
+#define PORT_STATE_ASST	3
+
+#define CRC_16_L_SEED	0x80
+#define CRC_16_L_POLYNOMIAL  0x8000
+#define CRC_16_POLYNOMIAL  0x1021
+
+int cls_recovery_mode_en=0;
+
+struct sdio_channel_record {
+        u32 channel;
+        u32 len;
+        u32 seqno;
+#define MAX_DATA_NUM 7
+        u32 data[MAX_DATA_NUM];
+};
+#define MAX_RECORD_NUM 5
+static struct sdio_channel_record channel_record[SDIO2_MAX_CH_NUM*MAX_RECORD_NUM] = {0};
+
+/***********************************************************/
+char firmware_version[128];
+char assert_context[1024];
+int  assert_context_size=0;
+static int assert_info_print;
+static u8 fifo_ind;
+static u64 port_dmamask = DMA_BIT_MASK(32);
+struct sdio_port sdio_ports[SDIO2_MAX_CH_NUM];
+static u8 cp_fifo_status;
+struct debug_vars debug_infos;
+static BLOCKING_NOTIFIER_HEAD(modem_notifier_list);
+#if KERNEL_VERSION(4,4,0) <= LINUX_VERSION_CODE
+static DEFINE_PER_CPU(struct page_frag_cache, skw_sdio_alloc_cache);
+#endif
+unsigned int crc_16_l_calc(char *buf_ptr,unsigned int len);
+static int skw_sdio_rx_port_follow_ctl(int portno, int rx_fctl);
+//add the crc api the same as cp crc_16 api
+extern void kernel_restart(char *cmd);
+static int skw_sdio_irq_ops(int irq_enable);
+static int bt_service_start(void);
+static int bt_service_stop(void);
+static int wifi_service_start(void);
+static int wifi_service_stop(void);
+char skw_cp_ver = SKW_SDIO_V10;
+int max_ch_num = MAX_CH_NUM;
+int max_pac_size = MAX_PAC_SIZE;
+int skw_sdio_blk_size = 256;
+
+#ifdef CONFIG_PRINTK_TIME_FROM_ARM_ARCH_TIMER
+#include <clocksource/arm_arch_timer.h>
+u64 skw_local_clock(void)
+{
+        u64 ns;
+
+        ns = arch_timer_read_counter() * 1000;
+        do_div(ns, 24);
+
+        return ns;
+}
+#else
+#if KERNEL_VERSION(4,11,0) <= LINUX_VERSION_CODE
+#include <linux/sched/clock.h>
+#else
+#include <linux/sched.h>
+#endif
+u64 skw_local_clock(void)
+{
+        return local_clock();
+}
+#endif
+#define IS_LOG_PORT(portno)  ((skw_cp_ver == SKW_SDIO_V10)?(portno==1):(portno==SDIO2_BSP_LOG_PORT))
+
+
+void skw_get_assert_print_info(char *buffer, int size)
+{
+	int ret = 0;
+	int j = 0;
+	u64 ts;
+	unsigned long rem_nsec;
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+
+	if(!buffer) {
+		skw_sdio_info("buffer is null!\n");
+		return;
+	}
+	ret += sprintf(&buffer[ret], "last irq times: [%6d] [%6d] ", debug_infos.rx_inband_irq_cnt, debug_infos.rx_gpio_irq_cnt);
+	for (j = 0; j < CHN_IRQ_RECORD_NUM; j++) {
+		ts = debug_infos.last_irq_times[j];
+		rem_nsec = do_div(ts, 1000000000);
+		ret += sprintf(&buffer[ret], "[%5lu.%06lu] ", (unsigned long)ts, rem_nsec / 1000);
+	}
+	if (SKW_SDIO_INBAND_IRQ == skw_sdio->irq_type) {
+		ret += sprintf(&buffer[ret], "\nlast clear irq times:    [%6d] ", debug_infos.rx_inband_irq_cnt);
+		for (j = 0; j < CHN_IRQ_RECORD_NUM; j++) {
+			ts = debug_infos.last_clear_irq_times[j];
+			rem_nsec = do_div(ts, 1000000000);
+			ret += sprintf(&buffer[ret], "[%5lu.%06lu] ", (unsigned long)ts, rem_nsec / 1000);
+		}
+	}
+	ret += sprintf(&buffer[ret], "\nlast rx read times:      [%6d] ", debug_infos.rx_read_cnt);
+	for (j = 0; j < CHN_IRQ_RECORD_NUM; j++) {
+		ts = debug_infos.last_rx_read_times[j];
+		rem_nsec = do_div(ts, 1000000000);
+		ret += sprintf(&buffer[ret], "[%5lu.%06lu] ", (unsigned long)ts, rem_nsec / 1000);
+	}
+
+	if(ret >= size)
+		skw_sdio_info("ret bigger than size %d %d\n", ret, size);
+}
+
+void skw_get_sdio_debug_info(char *buffer, int size)
+{
+	int ret = 0;
+	int i = 0;
+	int j = 0;
+	u64 ts;
+	unsigned long rem_nsec;
+
+	if(!buffer) {
+		skw_sdio_info("buffer is null!\n");
+		return;
+	}
+
+	ret += sprintf(&buffer[ret], "channel irq times:\n");
+	for (i = 0; i < max_ch_num; i++) {
+		ret += sprintf(&buffer[ret], "channel[%2d]: [%6d] ", i, debug_infos.chn_irq_cnt[i]);
+		for (j = 0; j < CHN_IRQ_RECORD_NUM; j++) {
+			ts = debug_infos.chn_last_irq_time[i][j];
+			rem_nsec = do_div(ts, 1000000000);
+			ret += sprintf(&buffer[ret], "[%5lu.%06lu] ", (unsigned long)ts, rem_nsec / 1000);
+		}
+		ret += sprintf(&buffer[ret], "\n");
+	}
+	ret += sprintf(&buffer[ret], "cmd_timeout_cnt: %d\n", debug_infos.cmd_timeout_cnt);
+	ret += sprintf(&buffer[ret], "last_sent_wifi_cmd[0]: 0x%x\n", debug_infos.last_sent_wifi_cmd[0]);
+	ret += sprintf(&buffer[ret], "last_sent_wifi_cmd[1]: 0x%x\n", debug_infos.last_sent_wifi_cmd[1]);
+	ret += sprintf(&buffer[ret], "last_sent_wifi_cmd[2]: 0x%x\n", debug_infos.last_sent_wifi_cmd[2]);
+	ts = debug_infos.last_sent_time;
+	rem_nsec = do_div(ts, 1000000000);
+	ret += sprintf(&buffer[ret], "last_sent_time: [%5lu.%06lu]\n", (unsigned long)ts, rem_nsec / 1000);
+	ts = debug_infos.last_rx_submit_time;
+	rem_nsec = do_div(ts, 1000000000);
+	ret += sprintf(&buffer[ret], "last_rx_submit_time: [%5lu.%06lu]\n", (unsigned long)ts, rem_nsec / 1000);
+	if (debug_infos.host_assert_cp_time) {
+		ts = debug_infos.host_assert_cp_time;
+		rem_nsec = do_div(ts, 1000000000);
+		ret += sprintf(&buffer[ret], "host_assert_cp_time: [%5lu.%06lu]\n", (unsigned long)ts, rem_nsec / 1000);
+	}
+	if (debug_infos.cp_assert_time) {
+		ts = debug_infos.cp_assert_time;
+		rem_nsec = do_div(ts, 1000000000);
+		ret += sprintf(&buffer[ret], "cp_assert_time: [%5lu.%06lu]\n", (unsigned long)ts, rem_nsec / 1000);
+	}
+	if (debug_infos.host_assert_cp_time > debug_infos.last_sent_time) {
+		ts = debug_infos.host_assert_cp_time - debug_infos.last_sent_time;
+		rem_nsec = do_div(ts, 1000000000);
+		ret += sprintf(&buffer[ret], "timeout: [%5lu.%06lu]\n", (unsigned long)ts, rem_nsec / 1000);
+	}
+
+	if(ret >= size)
+		skw_sdio_info("ret bigger than size %d %d\n", ret, size);
+}
+/********************************************************
+ * skw_sdio_update img crc checksum
+ * For update the CP IMG
+ *Author: JUNWEI JIANG
+ *Date:2022-08-11
+ * *****************************************************/
+
+int skw_log_port(void)
+{
+	return (skw_cp_ver == SKW_SDIO_V10)?(1):(SDIO2_BSP_LOG_PORT);
+}
+
+void skw_get_port_statistic(char *buffer, int size)
+{
+		int ret = 0;
+		int i;
+
+		if(!buffer)
+			return;
+
+		for(i=0; i<SDIO2_MAX_CH_NUM; i++)
+		{
+			if(ret >= size)
+				break;
+
+			if(sdio_ports[i].state)
+				ret += sprintf(&buffer[ret], "port%d: rx %d %d, tx %d %d\n",
+						i, sdio_ports[i].rx_count, sdio_ports[i].rx_packet,
+						sdio_ports[i].total, sdio_ports[i].sent_packet);
+
+		}
+}
+
+void skw_get_channel_record(char *buffer, int size)
+{
+		int ret = 0;
+		int i,j,k;
+
+		if(!buffer)
+			return;
+		for(j=0; j<SDIO2_MAX_CH_NUM; j++) {
+			for(i=0; i<MAX_RECORD_NUM; i++) {
+				if(ret >= size) {
+					skw_sdio_err("%s buffer is full %d\n", __FUNCTION__, ret);
+					break;
+				}
+				ret += sprintf(&buffer[ret], "port%d: packet len:%d seqno:%d ", j, channel_record[j*MAX_RECORD_NUM+i].len, channel_record[j*MAX_RECORD_NUM+i].seqno);
+				for (k = 0; k < sizeof(channel_record[0].data)/sizeof(channel_record[0].data[0]); k++) {
+					ret += sprintf(&buffer[ret], "data%d:0x%x ", k, channel_record[j*MAX_RECORD_NUM+i].data[k]);
+				}
+				ret += sprintf(&buffer[ret], "\n");
+			}
+		}
+}
+
+void skw_sdio_record_packet(struct skw_packet_header *header, int portno) {
+	struct sdio_port  *port;
+	struct sdio_channel_record *record_ptr = NULL;
+	u32 *data = NULL;
+	int i = 0;
+
+	port = &sdio_ports[portno];
+	record_ptr = &channel_record[portno*MAX_RECORD_NUM];
+	for (i = 0; i < MAX_RECORD_NUM; i++) {
+		if (record_ptr[i].seqno == 0) {
+			break;
+		} else if (record_ptr[i].seqno > record_ptr[(i+1)%MAX_RECORD_NUM].seqno) {
+			i = (i+1)%MAX_RECORD_NUM;
+			break;
+		}
+	}
+	record_ptr += i;
+	data = (uint32_t *)header;
+	record_ptr->channel = header->channel;
+	record_ptr->len = header->len;
+	record_ptr->seqno = port->rx_packet-1;
+        for (i = 0; i < sizeof(channel_record[0].data)/sizeof(channel_record[0].data[0]); i++) {
+		record_ptr->data[i] = data[i];
+	}
+}
+
+void skw_sdio_record_packet2(struct skw_packet2_header *header, int portno) {
+	struct sdio_port  *port;
+	struct sdio_channel_record *record_ptr = NULL;
+	u32 *data = NULL;
+	int i = 0;
+
+	port = &sdio_ports[portno];
+	record_ptr = &channel_record[portno*MAX_RECORD_NUM];
+	for (i = 0; i < MAX_RECORD_NUM; i++) {
+		if (record_ptr[i].seqno == 0 || record_ptr[i].seqno == 1) {
+			break;
+		} else if (record_ptr[i].seqno > record_ptr[(i+1)%MAX_RECORD_NUM].seqno) {
+			i = (i+1)%MAX_RECORD_NUM;
+			break;
+		}
+	}
+	record_ptr += i;
+	data = (uint32_t *)header;
+	record_ptr->channel = header->channel;
+	record_ptr->len = header->len;
+	record_ptr->seqno = port->rx_packet;
+        for (i = 0; i < sizeof(record_ptr->data)/sizeof(record_ptr->data[0]); i++) {
+		record_ptr->data[i] = data[i];
+	}
+}
+
+unsigned int crc_16_l_calc(char *buf_ptr,unsigned int len)
+{
+	unsigned int i;
+	unsigned short crc=0;
+
+	while(len--!=0)
+	{
+		for(i= CRC_16_L_SEED;i!=0;i=i>>1)
+		{
+			if((crc &CRC_16_L_POLYNOMIAL)!=0)
+			{
+				crc= crc<<1;
+				crc= crc ^ CRC_16_POLYNOMIAL;
+			}else{
+				crc = crc <<1;
+			}
+
+			if((*buf_ptr &i)!=0)
+			{
+				crc = crc ^ CRC_16_POLYNOMIAL;
+			}
+		}
+		buf_ptr++;
+	}
+	return (crc);
+}
+
+static int skw_sdio_rx_port_follow_ctl(int portno, int rx_fctl)
+{
+	char ftl_val = 0;
+	int ret = 0;
+
+	skw_sdio_info(" portno:%d, rx_fctl:%d \n", portno, rx_fctl);
+
+	if((portno < 0) || (portno > max_ch_num))
+		return -1;
+
+	if(portno < 8){
+		ret = skw_sdio_readb(SKW_SDIO_RX_CHANNEL_FTL0, &ftl_val);
+		if(ret)
+			return -1;
+
+		if(rx_fctl)
+			ftl_val = ftl_val | (1 << portno);
+		else
+			ftl_val = ftl_val & (~(1 << portno));
+		ret = skw_sdio_writeb(SKW_SDIO_RX_CHANNEL_FTL0, ftl_val);
+	}
+	else{
+		portno = portno - 8;
+		ret = skw_sdio_readb(SKW_SDIO_RX_CHANNEL_FTL1, &ftl_val);
+		if(ret)
+			return -1;
+
+		if(rx_fctl)
+			ftl_val = ftl_val | (1 << portno);
+		else
+			ftl_val = ftl_val & (~(1 << portno));
+		ret = skw_sdio_writeb(SKW_SDIO_RX_CHANNEL_FTL1, ftl_val);
+	}
+	return ret;
+}
+
+void modem_register_notify(struct notifier_block *nb)
+{
+	blocking_notifier_chain_register(&modem_notifier_list, nb);
+}
+void modem_unregister_notify(struct notifier_block *nb)
+{
+	blocking_notifier_chain_unregister(&modem_notifier_list, nb);
+}
+void modem_notify_event(int event)
+{
+	blocking_notifier_call_chain(&modem_notifier_list, event, NULL);
+}
+
+void skw_sdio_exception_work(struct work_struct *work)
+{
+	int i=0;
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	skw_sdio_info(" entern...\n");
+	mutex_lock(&skw_sdio->except_mutex);
+	if(skw_sdio->cp_state!=1)
+	{
+		mutex_unlock(&skw_sdio->except_mutex);
+		skw_sdio_err("DEBUG - the cp_state is not 1, exit!\n");
+		return;
+	}
+	skw_sdio->cp_state = DEVICE_BLOCKED_EVENT;
+	mutex_unlock(&skw_sdio->except_mutex);
+	if(!skw_sdio->host_state)
+		modem_notify_event(DEVICE_BLOCKED_EVENT);
+
+	for (i=0; i<5; i++)
+	{
+		if(!sdio_ports[i].state || sdio_ports[i].state==PORT_STATE_CLSE)
+			continue;
+
+		sdio_ports[i].state = PORT_STATE_ASST;
+		complete(&(sdio_ports[i].rx_done));
+		if(i!=skw_log_port())
+			complete(&(sdio_ports[i].tx_done));
+		if(i==0 || i==skw_log_port())
+			sdio_ports[i].next_seqno= 1;
+	}
+	skw_sdio->service_state_map=0;
+	skw_recovery_mode();
+}
+
+#if KERNEL_VERSION(4,14,0) <= LINUX_VERSION_CODE
+static void *skw_sdio_alloc_frag(unsigned int fragsz, gfp_t gfp_mask)
+{
+	struct page_frag_cache *nc;
+	unsigned long flags;
+	void *data;
+
+	local_irq_save(flags);
+	nc = this_cpu_ptr(&skw_sdio_alloc_cache);
+	data = page_frag_alloc(nc, fragsz, gfp_mask);
+	local_irq_restore(flags);
+	return data;
+}
+#elif KERNEL_VERSION(4,4,0) > LINUX_VERSION_CODE
+static void *skw_sdio_alloc_frag(unsigned int fragsz, gfp_t gfp_mask)
+{
+	void *data;
+	data = netdev_alloc_frag(fragsz);
+	return data;
+}
+static void page_frag_free(void *data)
+{
+ 	put_page(virt_to_head_page(data));
+}
+
+#else
+static void *skw_sdio_alloc_frag(unsigned int fragsz, gfp_t gfp_mask)
+{
+	struct page_frag_cache *nc;
+	unsigned long flags;
+	void *data;
+	
+	local_irq_save(flags);
+	nc = this_cpu_ptr(&skw_sdio_alloc_cache);
+	data = __alloc_page_frag(nc, fragsz, gfp_mask);
+	local_irq_restore(flags);
+	return data;
+}
+#if KERNEL_VERSION(4,4,94) <= LINUX_VERSION_CODE
+	#define page_frag_free __free_page_frag
+#endif
+#endif
+
+static void skw_sdio_rx_down(struct skw_sdio_data_t * skw_sdio)
+{
+	wait_for_completion_interruptible(&skw_sdio->rx_completed);
+}
+void skw_sdio_rx_up(struct skw_sdio_data_t * skw_sdio)
+{
+	skw_reinit_completion(skw_sdio->rx_completed);
+	complete(&skw_sdio->rx_completed);
+}
+void skw_sdio_dispatch_packets(struct skw_sdio_data_t * skw_sdio)
+{
+	int i;
+	struct sdio_port *port;
+
+	for(i=0; i<max_ch_num; i++) {
+		port = &sdio_ports[i];
+		if(!port->state)
+			continue;
+		if(port->rx_rp!=port->rx_wp)
+			skw_sdio_dbg("port[%d] sg_index=%d (%d,%d)\n", i,
+				port->sg_index, port->rx_rp, port->rx_wp);
+		if(port->rx_submit && port->sg_index) {
+			debug_infos.last_rx_submit_time = skw_local_clock();
+			port->rx_submit(port->channel, port->sg_rx, port->sg_index, port->rx_data);
+			skw_sdio_dbg("port[%d] sg_index=%d (%d,%d)\n", i,
+				port->sg_index, port->rx_rp, port->rx_wp);
+			port->sg_index = 0;
+		}
+	}
+}
+static void skw_sdio_sdma_set_nsize(unsigned int size)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	int count;
+
+	if (size == 0) {
+		skw_sdio->next_size = max_pac_size;
+		return;
+	}
+
+	count = (size >> 10) + 9;
+	size = SKW_SDIO_ALIGN_BLK(size + (count<<3));
+	skw_sdio->next_size = (size>SDIO_BUFFER_SIZE) ? SDIO_BUFFER_SIZE:size;
+}
+
+static void skw_sdio_adma_set_packet_num(unsigned int num)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+
+	if (num == 0) 
+		num = 1;
+
+	if (num >= MAX_SG_COUNT)
+		skw_sdio->remain_packet = MAX_SG_COUNT;
+	else 
+		skw_sdio->remain_packet = num;
+}
+
+/************************************************************************
+ *Decription:release debug recovery auto test
+ *Author:junwei.jiang
+ *Date:2023-05-30
+ *Modfiy:
+ *
+ ********************************************************************* */
+int skw_sdio_recovery_debug(int disable)
+{
+	cls_recovery_mode_en = disable;
+	skw_sdio_info("the recovery status =%d\n", cls_recovery_mode_en);
+	return 0;
+}
+
+int skw_sdio_recovery_debug_status(void)
+{
+	skw_sdio_info("the recovery val =%d\n", cls_recovery_mode_en);
+	return cls_recovery_mode_en;
+}
+
+/************************************************************************
+ *Decription:dump mem file
+ *Author:junwei.jiang
+ *Date:2024-05-10
+ *Modfiy:
+ *
+ ********************************************************************* */
+int skw_sdio_dumpmem(int dump)
+{
+	int dumpmem_status = dump;
+	skw_sdio_info("the dump status =%d\n", dumpmem_status);
+	if(dumpmem_status == 1) {
+		skw_sdio_info("dump mem start\n");
+		modem_notify_event(DEVICE_DUMPMEM_EVENT);
+	}else if(dumpmem_status == 0) {
+		skw_sdio_info("dump mem stop\n");
+	}
+	return 0;
+}
+
+
+static int skw_sdio_handle_packet(struct skw_sdio_data_t *skw_sdio,
+		struct scatterlist *sg, struct skw_packet_header *header, int portno)
+{
+	struct sdio_port  *port;
+	int buf_size, i;
+	char *addr;
+	u32 *data;
+	if (portno >= max_ch_num)
+		return -EINVAL;
+	if (skw_is_record_enable(portno)) {
+		skw_sdio_record_packet(header, portno);
+	}
+	port = &sdio_ports[portno];
+	port->rx_packet++;
+	port->rx_count += header->len;
+	if(portno == LOOPCHECK_PORT) {
+		char *cmd = (char *)(header+4);
+		cmd[header->len - 12] = 0;
+		skw_sdio_info("LOOPCHECK channel received: %s\n", (char *)cmd);
+		if (header->len==19 && !strncmp(cmd, "BTREADY", 7)) {
+			skw_sdio->service_state_map |= 2;
+			//kernel_restart(0);
+			skw_sdio->device_active = 1;
+			complete(&skw_sdio->download_done);
+		}else if(header->len==18 && !strncmp(cmd, "BTEXIT", 6)){
+			complete(&skw_sdio->download_done);
+		}else if(header->len==21 && !strncmp(cmd, "WIFIREADY", 9)){
+			skw_sdio->service_state_map |= 1;
+			//kernel_restart(0);
+			skw_sdio->device_active = 1;
+			complete(&skw_sdio->download_done);
+		} else if (!strncmp((char *)cmd, "BSPASSERT", 9)){
+			debug_infos.cp_assert_time = skw_local_clock();
+			skw_sdio_channel_record_disable_all();
+			if(!skw_sdio->cp_state)
+				schedule_delayed_work(&skw_sdio->skw_except_work , msecs_to_jiffies(8000));
+
+			mutex_lock(&skw_sdio->except_mutex);
+			if(skw_sdio->cp_state==DEVICE_BLOCKED_EVENT){
+				if(skw_sdio->adma_rx_enable)
+					page_frag_free(header);
+
+				mutex_unlock(&skw_sdio->except_mutex);
+				return 0;
+			}
+			skw_sdio->cp_state=1;/*cp except set value*/
+			mutex_unlock(&skw_sdio->except_mutex);
+			skw_sdio->service_state_map = 0;
+			memset(assert_context, 0, 1024);
+			assert_context_size = 0;
+			modem_notify_event(DEVICE_ASSERT_EVENT);
+			skw_sdio_err(" bsp assert !!!\n");
+		}else if (header->len==20 && !strncmp(cmd, "DUMPDONE",8)){
+			mutex_lock(&skw_sdio->except_mutex);
+			if(skw_sdio->cp_state==DEVICE_BLOCKED_EVENT){
+				if(skw_sdio->adma_rx_enable)
+					page_frag_free(header);
+
+				mutex_unlock(&skw_sdio->except_mutex);
+				return 0;
+			}
+			skw_sdio->cp_state=DEVICE_DUMPDONE_EVENT;/*cp except set value 2*/
+			mutex_unlock(&skw_sdio->except_mutex);
+			cancel_delayed_work_sync(&skw_sdio->skw_except_work);
+#ifdef CONFIG_SEEKWAVE_PLD_RELEASE
+			modem_notify_event(DEVICE_DUMPDONE_EVENT);
+#else
+			if(!strncmp((char *)skw_sdio->chip_id,"SV6160",6) && !cls_recovery_mode_en){
+				modem_notify_event(DEVICE_DUMPDONE_EVENT);
+			}
+#endif
+			skw_sdio_err("The CP DUMPDONE OK : \n %d::%s\n",assert_context_size, assert_context);
+			for (i=0; i<5; i++) {
+				if(!sdio_ports[i].state || sdio_ports[i].state==PORT_STATE_CLSE)
+					continue;
+
+				sdio_ports[i].state = PORT_STATE_ASST;
+				complete(&(sdio_ports[i].rx_done));
+				if(i!=skw_log_port())
+					complete(&(sdio_ports[i].tx_done));
+				if(i==0 || i==skw_log_port())
+					sdio_ports[i].next_seqno= 1;
+			}
+#ifdef CONFIG_SEEKWAVE_PLD_RELEASE
+			skw_recovery_mode();//recoverymode open api
+#else
+			if(!strncmp((char *)skw_sdio->chip_id,"SV6160",6) &&skw_sdio->cp_state !=DEVICE_BLOCKED_EVENT){
+				skw_recovery_mode();//recoverymode open api
+			}
+#endif
+		}else if (!strncmp("trunk_W", cmd, 7)) {
+			memset(firmware_version, 0 , sizeof(firmware_version));
+			strncpy(firmware_version, cmd, strlen(cmd));
+			cmd = strstr(firmware_version, "slp=");
+			if (cmd)
+				skw_sdio->cp_detect_sleep_mode = cmd[4] - 0x30;
+			else
+				skw_sdio->cp_detect_sleep_mode = 4;
+
+			if(!skw_sdio->cp_state)
+				complete(&skw_sdio->download_done);
+
+			if(skw_sdio->cp_state){
+				assert_info_print = 0;
+				if(sdio_ports[0].state == PORT_STATE_ASST)
+					sdio_ports[0].state = PORT_STATE_OPEN;
+				modem_notify_event(DEVICE_BSPREADY_EVENT);
+				skw_sdio_info("send the bsp state to log service or others\n");
+			}
+			skw_sdio->host_state =0;
+			skw_sdio->cp_state = 0;
+			wake_up(&skw_sdio->wq);
+			skw_sdio_info("cp_state = %d \n", skw_sdio->cp_state);
+			memset(firmware_version, 0 , sizeof(firmware_version));
+			strncpy(firmware_version, cmd, strlen(cmd));
+			skw_sdio_info("firmware version: %s:%s \n",cmd, firmware_version);
+		} else if (!strncmp(cmd, "BSPREADY",8)) {
+			loopcheck_send_data("RDVERSION", 9);
+		}
+		skw_sdio_dbg("Line:%d the port=%d \n", __LINE__, port->channel);
+		if(skw_sdio->adma_rx_enable)
+			page_frag_free(header);
+		return 0;
+	}
+	if(!port->state) {
+		if(skw_sdio->adma_rx_enable){
+			if (!IS_LOG_PORT(portno))
+				skw_sdio_err("port%d discard data for wrong state\n", portno);
+			page_frag_free(header);
+			return 0;
+		}
+	}
+	if (port->sg_rx && port->rx_data){
+		if (port->sg_index >= MAX_SG_COUNT){
+			skw_sdio_err(" rx sg_buffer is overflow!\n");
+		}else{
+			sg_set_buf(&port->sg_rx[port->sg_index++], header, header->len+4);
+		}
+	}else {
+		int packet=0, total=0;
+		mutex_lock(&port->rx_mutex);
+		buf_size = (port->length + port->rx_wp - port->rx_rp)%port->length;
+		buf_size = port->length - 1 - buf_size;
+		addr = (char *)(header+1);
+		data = (u32 *) addr;
+		if(((data[2] & 0xffff) != port->next_seqno) &&
+			(header->len > 12) && !IS_LOG_PORT(portno)) {
+			skw_sdio_err("portno:%d, packet lost recv seqno=%d expected %d\n", port->channel,
+					data[2] & 0xffff, port->next_seqno);
+			if(skw_sdio->adma_rx_enable)
+				page_frag_free(header);
+			mutex_unlock(&port->rx_mutex);
+			return 0;
+		}
+		if(header->len > 12) {
+			port->next_seqno++;
+			addr += 12;
+			header->len -= 12;
+			total = data[1] >> 8;
+			packet = data[2] & 0xFFFF;
+		} else if (header->len == 12) {
+			header->len = 0;
+			port->tx_flow_ctrl--;
+			complete(&port->tx_done);
+			skw_port_log(portno,"%s link msg: 0x%x 0x%x port%d: %d \n", __func__,
+					data[0], data[1], portno, port->tx_flow_ctrl);
+		}
+		if(skw_sdio->cp_state){
+			if(header->len!=245 || buf_size < 2048) {
+				if(assert_info_print++ < 28 && strncmp((const char *)addr, "+LOG", 4)) {
+					if (assert_context_size + header->len < sizeof(assert_context)) {
+						memcpy(assert_context + assert_context_size, addr, header->len);
+						assert_context_size += header->len;
+					}
+				}
+			}
+			if(buf_size <2048)
+				msleep(10);
+		}
+		if (port->rx_submit && !port->sg_rx) {
+			if (header->len && port->pdev)
+				port->rx_submit(portno, port->rx_data, header->len, addr);
+		} else if (buf_size < header->len) {
+			skw_port_log(portno,"%s port%d overflow:buf_size %d-%d, packet size %d (w,r)=(%d, %d)\n",
+					__func__, portno, buf_size, port->length, header->len,
+					port->rx_wp,  port->rx_rp);
+		} else if(port->state && header->len) {
+			if(port->length - port->rx_wp > header->len){
+				memcpy(&port->read_buffer[port->rx_wp], addr, header->len);
+				port->rx_wp += header->len;
+			} else {
+				memcpy(&port->read_buffer[port->rx_wp], addr, port->length - port->rx_wp);
+				memcpy(&port->read_buffer[0], &addr[port->length - port->rx_wp],
+						header->len - port->length + port->rx_wp);
+				port->rx_wp = header->len - port->length + port->rx_wp;
+			}
+
+			if(!port->rx_flow_ctrl && buf_size-header->len < (port->length/3)) {
+				port->rx_flow_ctrl = 1;
+				skw_sdio_rx_port_follow_ctl(portno, port->rx_flow_ctrl);
+			}
+			mutex_unlock(&port->rx_mutex);
+			complete(&port->rx_done);
+			if(skw_sdio->adma_rx_enable)
+				page_frag_free(header);
+			return 0;
+		}
+		mutex_unlock(&port->rx_mutex);
+		if(skw_sdio->adma_rx_enable)
+			page_frag_free(header);
+	}
+	return 0;
+}
+
+static int skw_sdio2_handle_packet(struct skw_sdio_data_t *skw_sdio,
+		struct scatterlist *sg, struct skw_packet2_header *header, int portno)
+{
+	struct sdio_port  *port;
+	int buf_size, i;
+	char *addr;
+	u32 *data;
+
+	if (portno >= max_ch_num)
+		return -EINVAL;
+	if (skw_is_record_enable(portno)) {
+		skw_sdio_record_packet2(header, portno);
+	}
+	port = &sdio_ports[portno];
+	port->rx_packet++;
+	port->rx_count += header->len;
+	if(portno == SDIO2_LOOPCHECK_PORT) {
+		char *cmd = (char *)(header+4);
+		cmd[header->len - 12] = 0;
+		skw_sdio_info("LOOPCHECK channel received: %s\n", (char *)cmd);
+		if (header->len==19 && !strncmp(cmd, "BTREADY", 7)) {
+			skw_sdio->service_state_map |= 2;
+			//kernel_restart(0);
+			skw_sdio->device_active = 1;
+			complete(&skw_sdio->download_done);
+		}else if(header->len==21 && !strncmp(cmd, "WIFIREADY", 9)){
+			skw_sdio->service_state_map |= 1;
+			//kernel_restart(0);
+			skw_sdio->device_active = 1;
+			complete(&skw_sdio->download_done);
+		} else if (header->len==21 && !strncmp((char *)cmd, "BSPASSERT", 9)) {
+			debug_infos.cp_assert_time = skw_local_clock();
+			skw_sdio_channel_record_disable_all();
+			if(!skw_sdio->cp_state &&(!strncmp((char *)skw_sdio->chip_id,"SV6160",6)))
+				schedule_delayed_work(&skw_sdio->skw_except_work , msecs_to_jiffies(12000));
+
+			mutex_lock(&skw_sdio->except_mutex);
+			if(skw_sdio->cp_state==DEVICE_BLOCKED_EVENT){
+				if(skw_sdio->adma_rx_enable)
+					page_frag_free(header);
+
+				mutex_unlock(&skw_sdio->except_mutex);
+				return 0;
+			}
+			skw_sdio->cp_state=1;/*cp except set value*/
+			mutex_unlock(&skw_sdio->except_mutex);
+			skw_sdio->service_state_map = 0;
+			memset(assert_context, 0, 1024);
+			assert_context_size = 0;
+			modem_notify_event(DEVICE_ASSERT_EVENT);
+			skw_sdio_err(" bsp assert !!!\n");
+		}else if (header->len==20 && !strncmp(cmd, "DUMPDONE",8)){
+			mutex_lock(&skw_sdio->except_mutex);
+			if(skw_sdio->cp_state==DEVICE_BLOCKED_EVENT){
+				if(skw_sdio->adma_rx_enable)
+					page_frag_free(header);
+
+				mutex_unlock(&skw_sdio->except_mutex);
+				return 0;
+			}
+			skw_sdio->cp_state=DEVICE_DUMPDONE_EVENT;/*cp except set value 2*/
+			mutex_unlock(&skw_sdio->except_mutex);
+			cancel_delayed_work_sync(&skw_sdio->skw_except_work);
+#ifdef CONFIG_SEEKWAVE_PLD_RELEASE
+			modem_notify_event(DEVICE_DUMPDONE_EVENT);
+#else
+			if(!strncmp((char *)skw_sdio->chip_id,"SV6360",6) && !cls_recovery_mode_en){
+				modem_notify_event(DEVICE_DUMPDONE_EVENT);
+			}
+#endif
+			skw_sdio_err("The CP DUMPDONE OK : \n %d::%s\n",assert_context_size, assert_context);
+			for (i=0; i<5; i++) {
+				if(!sdio_ports[i].state || sdio_ports[i].state==PORT_STATE_CLSE)
+					continue;
+
+				sdio_ports[i].state = PORT_STATE_ASST;
+				complete(&(sdio_ports[i].rx_done));
+				if(i!=1)
+					complete(&(sdio_ports[i].tx_done));
+				if(i==1)
+					sdio_ports[i].next_seqno= 1;
+			}
+#ifdef CONFIG_SEEKWAVE_PLD_RELEASE
+			skw_recovery_mode();//recoverymode open api
+#else
+			if(!strncmp((char *)skw_sdio->chip_id,"SV6316",6) && !cls_recovery_mode_en
+					&&skw_sdio->cp_state !=DEVICE_BLOCKED_EVENT){
+				skw_recovery_mode();//recoverymode open api
+			}
+#endif
+
+		}else if (!strncmp("trunk_W", cmd, 7)) {
+			memset(firmware_version, 0 , sizeof(firmware_version));
+			strncpy(firmware_version, cmd, strlen(cmd));
+			cmd = strstr(firmware_version, "slp=");
+			if (cmd)
+				skw_sdio->cp_detect_sleep_mode = cmd[4] - 0x30;
+			else
+				skw_sdio->cp_detect_sleep_mode = 4;
+			if(!skw_sdio->cp_state)
+				complete(&skw_sdio->download_done);
+
+			if(!skw_sdio->boot_data->first_dl_flag){
+				skw_sdio_gpio_irq_pre_ops();
+			}
+			if(skw_sdio->cp_state){
+				assert_info_print = 0;
+				if(sdio_ports[0].state == PORT_STATE_ASST)
+					sdio_ports[0].state = PORT_STATE_OPEN;
+				modem_notify_event(DEVICE_BSPREADY_EVENT);
+			}
+			wake_up(&skw_sdio->wq);
+			skw_sdio->host_state =0;
+			skw_sdio->cp_state = 0;
+			//skw_sdio_info("firmware version: %s:%s \n",cmd, firmware_version);
+		} else if (!strncmp(cmd, "BSPREADY",8)) {
+			loopcheck_send_data("RDVERSION", 9);
+		}
+		skw_sdio_dbg("Line:%d the port=%d \n", __LINE__, port->channel);
+		if(skw_sdio->adma_rx_enable)
+			page_frag_free(header);
+		return 0;
+	}
+	//skw_sdio_info("Line:%d the port=%d \n", __LINE__, port->channel);
+	if(!port->state) {
+		if(skw_sdio->adma_rx_enable){
+			if (!IS_LOG_PORT(portno))
+				skw_sdio_err("port%d discard data for wrong state\n", portno);
+			page_frag_free(header);
+			return 0;
+		}
+	}
+	if (port->sg_rx){
+		if (port->sg_index >= MAX_SG_COUNT){
+			skw_sdio_err(" rx sg_buffer is overflow!\n");
+		}else{
+			sg_set_buf(&port->sg_rx[port->sg_index++], header, header->len+4);
+		}
+	}else {
+		int packet=0, total=0;
+		mutex_lock(&port->rx_mutex);
+		buf_size = (port->length + port->rx_wp - port->rx_rp)%port->length;
+		buf_size = port->length - 1 - buf_size;
+		addr = (char *)(header+1);
+		data = (u32 *) addr;
+		if(((data[2] & 0xffff) != port->next_seqno) && header->len > 12) {
+			skw_sdio_err("portno:%d, packet lost recv seqno=%d expected %d\n", port->channel,
+					data[2] & 0xffff, port->next_seqno);
+			port->next_seqno = (data[2] & 0xffff);
+		}
+		if(header->len > 12) {
+			port->next_seqno++;
+			addr += 12;
+			header->len -= 12;
+			total = data[1] >> 8;
+			packet = data[2] & 0xFFFF;
+		} else if (header->len == 12) {
+			header->len = 0;
+			port->tx_flow_ctrl--;
+			skw_port_log(portno,"%s link msg: 0x%x 0x%x 0x%x: %d\n", __func__,
+					data[0], data[1], data[2], port->tx_flow_ctrl);
+			complete(&port->tx_done);
+		}
+		if(skw_sdio->cp_state){
+			if(header->len!=245 || buf_size < 2048)
+			skw_sdio_info("%s(%d.%d) (%d,%d) len=%d : 0x%x\n",__func__,
+						portno, port->next_seqno, port->rx_wp,  port->rx_rp, header->len, data[3]);
+			if(buf_size <2048)
+				msleep(10);
+		}
+		if (port->rx_submit && !port->sg_rx) {
+			if (header->len && port->pdev)
+				port->rx_submit(portno, port->rx_data, header->len, addr);
+		} else 	if (buf_size < header->len) {
+			skw_port_log(portno,"%s port%d overflow:buf_size %d-%d, packet size %d (w,r)=(%d, %d)\n",
+					__func__, portno, buf_size, port->length, header->len,
+					port->rx_wp,  port->rx_rp);
+		} else if(port->state && header->len) {
+			if(port->length - port->rx_wp > header->len){
+				memcpy(&port->read_buffer[port->rx_wp], addr, header->len);
+				port->rx_wp += header->len;
+			} else {
+				memcpy(&port->read_buffer[port->rx_wp], addr, port->length - port->rx_wp);
+				memcpy(&port->read_buffer[0], &addr[port->length - port->rx_wp],
+						header->len - port->length + port->rx_wp);
+				port->rx_wp = header->len - port->length + port->rx_wp;
+			}
+
+			if(!port->rx_flow_ctrl && buf_size-header->len < (port->length/3)) {
+				port->rx_flow_ctrl = 1;
+				skw_sdio_rx_port_follow_ctl(portno, port->rx_flow_ctrl);
+			}
+			mutex_unlock(&port->rx_mutex);
+			complete(&port->rx_done);
+			if(skw_sdio->adma_rx_enable)
+				page_frag_free(header);
+			return 0;
+		}
+		mutex_unlock(&port->rx_mutex);
+		if(skw_sdio->adma_rx_enable)
+			page_frag_free(header);
+	}
+	return 0;
+}
+int send_modem_assert_command(void)
+{
+	int ret =0;
+	u32 *cmd = debug_infos.last_sent_wifi_cmd;
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+        char *statistic = kzalloc(2048, GFP_KERNEL);
+
+	if(skw_sdio->cp_state)
+		return ret;
+
+	skw_sdio->cp_state=1;/*cp except set value*/
+	ret =skw_sdio_writeb(SKW_AP2CP_IRQ_REG, BIT(4));
+	if(ret !=0){
+		skw_sdio->host_state =1;
+		skw_sdio_err("the sdio host controller exception err= %d !!\n",ret);
+	}
+	debug_infos.host_assert_cp_time = skw_local_clock();
+	skw_sdio_err("%s ret=%d cmd: 0x%x 0x%x 0x%x :%d-%d %ums-%ums\n", __func__,
+			 ret, cmd[0], cmd[1], cmd[2], cp_fifo_status, fifo_ind, jiffies_to_msecs(debug_infos.last_sent_time), jiffies_to_msecs(debug_infos.host_assert_cp_time));
+	skw_get_assert_print_info(statistic, 2048);
+	skw_sdio_info("sdio last irqs information:\n%s\n", statistic);
+	kfree(statistic);
+#ifdef CONFIG_SEEKWAVE_PLD_RELEASE
+	schedule_delayed_work(&skw_sdio->skw_except_work , msecs_to_jiffies(2000));
+#else
+	schedule_delayed_work(&skw_sdio->skw_except_work , msecs_to_jiffies(6000));
+#endif
+	return ret;
+}
+
+/* for adma */
+static int skw_sdio_adma_parser(struct skw_sdio_data_t *skw_sdio, struct scatterlist *sgs,
+				int packet_count)
+{
+	struct skw_packet_header *header = NULL;
+	unsigned int i;
+	int channel = 0;
+	unsigned int parse_len = 0;
+	uint32_t *data;
+	struct sdio_port *port;
+
+	port = &sdio_ports[0];
+	for (i = 0; i < packet_count; i++) {
+		header = (struct skw_packet_header *)sg_virt(sgs + i);
+		data = (uint32_t *)header;
+		if (atomic_read(&skw_sdio->suspending))
+			skw_sdio_info("ch:%d len:%d 0x%x 0x%x\n", header->channel, header->len, data[2], data[3]);
+		skw_port_log(header->channel, "%s[%d]:ch:%d len:0x%0x 0x%08X 0x%08X : 0x%08X 0x%08x 0x%08X\n", __func__,
+			i,	header->channel, header->len, data[2], data[3], data[5], data[6], data[7]);
+		channel = header->channel;
+
+		if (!header->eof && (channel < max_ch_num) && header->len) {
+			parse_len += header->len;
+			data = (uint32_t *)(header+1);
+			if ((channel >= max_ch_num) || (header->len >
+				(max_pac_size - sizeof(struct skw_packet_header))) ||
+				(header->len == 0)) {
+				skw_sdio_err("%s invalid header[%d]len[%d]: 0x%x 0x%x\n",
+						__func__,  header->channel, header->len, data[0], data[1]);
+				page_frag_free(header);
+				continue;
+			}
+			skw_sdio->rx_packer_cnt++;
+			skw_sdio_handle_packet(skw_sdio, sgs+i, header, channel);
+		} else {
+			skw_sdio_channel_record_disable_all();
+			skw_sdio_err("%s[%d]:ch:%d len:0x%0x 0x%08X 0x%08X : 0x%08X 0x%08x 0x%08X\n", __func__,
+			i,	header->channel, header->len, data[2], data[3], data[5], data[6], data[7]);
+#if 0
+			print_hex_dump(KERN_ERR, "PACKET ERR:", 0, 16, 1,
+					header, 1792, 1);
+			skw_sdio_err("%s PUB HAEAD ERROR: packet[%d/%d] channel=%d,size=%d eof=%d!!!",
+					__func__, i, packet_count, channel, header->len, header->eof);
+#endif
+			page_frag_free(header);
+			continue;
+		}
+	}
+	if (debug_infos.last_irq_time && (channel > 0 && channel < max_ch_num)) {
+		if (channel > SDIO2_MAX_CH_NUM)
+			skw_sdio_err("line: %d channel number error %d %d\n", __LINE__, channel, SDIO2_MAX_CH_NUM);
+		debug_infos.chn_last_irq_time[channel][debug_infos.chn_irq_cnt[channel] % CHN_IRQ_RECORD_NUM] = debug_infos.last_irq_time;
+		debug_infos.chn_irq_cnt[channel]++;
+	}
+	atomic_set(&skw_sdio->suspending, 0);
+	return 0;
+}
+
+static int skw_sdio2_adma_parser(struct skw_sdio_data_t *skw_sdio, struct scatterlist *sgs,
+				int packet_count)
+{
+	struct skw_packet2_header *header = NULL;
+	unsigned int i;
+	int channel = 0;
+	unsigned int parse_len = 0;
+	uint32_t *data;
+	struct sdio_port *port;
+
+	port = &sdio_ports[0];
+	for (i = 0; i < packet_count; i++) {
+		header = (struct skw_packet2_header *)sg_virt(sgs + i);
+		data = (uint32_t *)header;
+		if (atomic_read(&skw_sdio->suspending))
+			skw_sdio_info("ch:%d len:%d 0x%x 0x%x\n", header->channel, header->len, data[2], data[3]);
+		skw_port_log(header->channel, "%s[%d]:ch:%d len:0x%0x 0x%08X 0x%08X : 0x%08X 0x%08x 0x%08X\n", __func__,
+			i,	header->channel, header->len, data[2], data[3], data[5], data[6], data[7]);
+		channel = header->channel;
+
+		if (!header->eof && (channel < max_ch_num) && header->len) {
+			parse_len += header->len;
+			data = (uint32_t *)(header+1);
+			if ((channel >= max_ch_num) || (header->len >
+				(max_pac_size - sizeof(struct skw_packet2_header))) ||
+				(header->len == 0)) {
+				skw_sdio_err("%s invalid header[%d]len[%d]: 0x%x 0x%x\n",
+						__func__,  header->channel, header->len, data[0], data[1]);
+				page_frag_free(header);
+				continue;
+			}
+			skw_sdio->rx_packer_cnt++;
+			skw_sdio2_handle_packet(skw_sdio, sgs+i, header, channel);
+		} else {
+			skw_sdio_err("%s[%d]:ch:%d len:0x%0x 0x%08X 0x%08X : 0x%08X 0x%08x 0x%08X\n", __func__,
+			i,	header->channel, header->len, data[2], data[3], data[5], data[6], data[7]);
+#if 0
+			print_hex_dump(KERN_ERR, "PACKET ERR:", 0, 16, 1,
+					header, 1792, 1);
+			skw_sdio_err("%s PUB HAEAD ERROR: packet[%d/%d] channel=%d,size=%d eof=%d!!!",
+					__func__, i, packet_count, channel, header->len, header->eof);
+#endif
+			page_frag_free(header);
+			continue;
+		}
+	}
+	if (debug_infos.last_irq_time && (channel > 0 && channel < max_ch_num)) {
+		if (channel > SDIO2_MAX_CH_NUM)
+			skw_sdio_err("line: %d channel number error %d %d\n", __LINE__, channel, SDIO2_MAX_CH_NUM);
+		debug_infos.chn_last_irq_time[channel][debug_infos.chn_irq_cnt[channel] % CHN_IRQ_RECORD_NUM] = debug_infos.last_irq_time;
+		debug_infos.chn_irq_cnt[channel]++;
+	}
+	atomic_set(&skw_sdio->suspending, 0);
+	return 0;
+}
+/* for normal dma */
+static int skw_sdio_sdma_parser(char *data_buf, int total)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	struct skw_packet_header *header = NULL;
+	int channel;
+	uint32_t *data;
+	unsigned char *p = NULL;
+	unsigned int parse_len = 0;
+	int current_len=0;
+#if 0
+	print_hex_dump(KERN_ERR, "skw_rx_buf:", 0, 16, 1,
+			data_buf, total, 1);
+#endif
+	header = (struct skw_packet_header *)data_buf;
+	for (parse_len = 0; parse_len < total;) {
+		if (header->eof != 0)
+			break;
+		p = (unsigned char *)header;
+		data = (uint32_t *)header;
+		if (atomic_read(&skw_sdio->suspending))
+			skw_sdio_info("ch:%d len:%d 0x%x 0x%x\n", header->channel, header->len, data[2], data[3]);
+		skw_port_log(header->channel, "%s:ch:%d len:0x%0x 0x%08X 0x%08X : 0x%08X 0x%08x 0x%08X\n", __func__,
+				header->channel, header->len, data[1], data[2], data[3], data[4], data[5]);
+		channel = header->channel;
+		current_len = header->len;
+		parse_len += current_len;
+		if ((channel >= max_ch_num) || (current_len == 0) ||
+			(current_len > (max_pac_size - sizeof(struct skw_packet_header)))) {
+			skw_sdio_err("%s skip [%d]len[%d]\n",__func__, header->channel, current_len);
+			break;
+		}
+		skw_sdio->rx_packer_cnt++;
+		skw_sdio_handle_packet(skw_sdio, NULL, header, channel);
+		skw_port_log(header->channel, "the -header->len----%d\n", current_len);
+		/* pointer to next packet header*/
+		p += sizeof(struct skw_packet_header) + SKW_SDIO_ALIGN_4BYTE(current_len);
+		header = (struct skw_packet_header *)p;
+	}
+	if (debug_infos.last_irq_time && (channel > 0 && channel < max_ch_num)) {
+		if (channel > SDIO2_MAX_CH_NUM)
+			skw_sdio_err("line: %d channel number error %d %d\n", __LINE__, channel, SDIO2_MAX_CH_NUM);
+		debug_infos.chn_last_irq_time[channel][debug_infos.chn_irq_cnt[channel] % CHN_IRQ_RECORD_NUM] = debug_infos.last_irq_time;
+		debug_infos.chn_irq_cnt[channel]++;
+	}
+	atomic_set(&skw_sdio->suspending, 0);
+	return 0;
+}
+static int skw_sdio2_sdma_parser(char *data_buf, int total)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	struct skw_packet2_header *header = NULL;
+	int channel;
+	uint32_t *data;
+	unsigned char *p = NULL;
+	unsigned int parse_len = 0;
+	int current_len=0;
+#if 0
+	print_hex_dump(KERN_ERR, "skw_rx_buf:", 0, 16, 1,
+			data_buf, total, 1);
+#endif
+	header = (struct skw_packet2_header *)data_buf;
+	for (parse_len = 0; parse_len < total;) {
+		if (header->eof != 0)
+			break;
+		p = (unsigned char *)header;
+		data = (uint32_t *)header;
+		if (atomic_read(&skw_sdio->suspending))
+			skw_sdio_info("ch:%d len:%d 0x%x 0x%x\n", header->channel, header->len, data[2], data[3]);
+		skw_port_log(header->channel, "ch:%d len:0x%0x 0x%08X 0x%08X : 0x%08X 0x%08x 0x%08X\n",
+				header->channel, header->len, data[1], data[2], data[3], data[4], data[5]);
+		channel = header->channel;
+		current_len = header->len;
+		parse_len += current_len;
+		if ((channel >= max_ch_num) || (current_len == 0) ||
+			(current_len > (max_pac_size - sizeof(struct skw_packet2_header)))) {
+			skw_sdio_err("%s skip [%d]len[%d]\n",__func__, header->channel, current_len);
+			break;
+		}
+		skw_sdio->rx_packer_cnt++;
+		skw_sdio2_handle_packet(skw_sdio, NULL, header, channel);
+		skw_port_log(header->channel, "the -header->len----%d\n", current_len);
+		/* pointer to next packet header*/
+		p += sizeof(struct skw_packet2_header) + SKW_SDIO_ALIGN_4BYTE(current_len);
+		header = (struct skw_packet2_header *)p;
+	}
+	if (debug_infos.last_irq_time && (channel > 0 && channel < max_ch_num)) {
+		if (channel > SDIO2_MAX_CH_NUM)
+			skw_sdio_err("line: %d channel number error %d %d\n", __LINE__, channel, SDIO2_MAX_CH_NUM);
+		debug_infos.chn_last_irq_time[channel][debug_infos.chn_irq_cnt[channel] % CHN_IRQ_RECORD_NUM] = debug_infos.last_irq_time;
+		debug_infos.chn_irq_cnt[channel]++;
+	}
+	atomic_set(&skw_sdio->suspending, 0);
+	return 0;
+}
+struct scatterlist *skw_sdio_prepare_adma_buffer(struct skw_sdio_data_t *skw_sdio, int *sg_count, int *nsize_offset)
+{
+	struct scatterlist *sgs;
+	void	*buffer;
+	int	i, j, data_size;
+	int	alloc_size = PAGE_SIZE;
+
+	sgs = kzalloc((*sg_count) * sizeof(struct scatterlist), GFP_KERNEL);
+
+	if(sgs == NULL)
+		return NULL;
+
+	for(i = 0; i < (*sg_count) - 1; i++) {
+		buffer = skw_sdio_alloc_frag(alloc_size, GFP_ATOMIC);
+		if(buffer)
+			sg_set_buf(&sgs[i], buffer, max_pac_size);
+		else{
+			*sg_count = i+1;
+			break;
+		}
+	}
+
+	if(i <= 0)
+		goto err;
+
+	sg_mark_end(&sgs[*sg_count - 1]);
+	data_size = max_pac_size*((*sg_count)-1);
+	data_size = data_size%SKW_SDIO_NSIZE_BUF_SIZE;
+	*nsize_offset = SKW_SDIO_NSIZE_BUF_SIZE - data_size;
+	if(*nsize_offset < 8)
+		*nsize_offset = SKW_SDIO_NSIZE_BUF_SIZE + *nsize_offset;
+	*nsize_offset = *nsize_offset + SKW_SDIO_NSIZE_BUF_SIZE;
+	sg_set_buf(sgs + i, skw_sdio->next_size_buf, *nsize_offset);
+	return sgs;
+err:
+	skw_sdio_err("%s failed\n", __func__);
+	for(j=0; j<i; j++)
+		page_frag_free(sg_virt(sgs + j));
+	kfree(sgs);
+	return NULL;
+
+}
+
+int skw_sdio_rx_thread(void *p)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	int read_len, buf_num;
+	int ret = 0;
+	unsigned int rx_nsize = 0;
+	unsigned int valid_len = 0;
+	char *rx_buf;
+	struct scatterlist *sgs = NULL;
+
+	skw_sdio_sdma_set_nsize(0);
+	skw_sdio_adma_set_packet_num(1);
+	cp_fifo_status = 0;
+	while (1) {
+		/* Wait the semaphore */
+		skw_sdio_rx_down(skw_sdio);
+		if (!debug_infos.cp_assert_time) {
+			debug_infos.last_rx_read_times[debug_infos.rx_read_cnt % CHN_IRQ_RECORD_NUM] = skw_local_clock();
+			debug_infos.rx_read_cnt++;
+		}
+		if (skw_sdio->threads_exit) {
+			skw_sdio_err("line %d threads exit\n",__LINE__);
+			break;
+		}
+		if (!SKW_CARD_ONLINE(skw_sdio)) {
+			skw_sdio_unlock_rx_ws(skw_sdio);
+			skw_sdio_err("line %d not have card\n",__LINE__);
+			continue;
+		}
+		skw_resume_check();
+		if (skw_sdio->irq_type == SKW_SDIO_EXTERNAL_IRQ) {
+			int value = gpio_get_value(skw_sdio->gpio_in);
+
+			if(value == 0) {
+				ret = skw_sdio_readb(SKW_SDIO_CP2AP_FIFO_IND, &fifo_ind);
+				if(ret){
+					skw_sdio_err("line %d sdio cmd52 read fail ret:%d\n",__LINE__, ret);
+					skw_sdio_unlock_rx_ws(skw_sdio);
+					continue;
+				}
+			}
+			ret = skw_sdio_readb(SKW_SDIO_CP2AP_FIFO_IND, &fifo_ind);
+			if(ret) {
+				skw_sdio_err("line %d sdio cmd52 read fail ret:%d\n",__LINE__, ret);
+				skw_sdio_unlock_rx_ws(skw_sdio);
+				continue;
+			}
+			skw_sdio_dbg("line:%d cp fifo status(%d,%d) ret=%d\n",
+					__LINE__,fifo_ind, cp_fifo_status, ret);
+			if (!ret && !fifo_ind)
+				skw_sdio_dbg("cp fifo ret -- %d \n", ret);
+			if(fifo_ind == cp_fifo_status) {
+				skw_sdio_info("line:%d cp fifo status(%d,%d) ret=%d\n",
+						__LINE__,fifo_ind, cp_fifo_status, ret);
+				skw_sdio_unlock_rx_ws(skw_sdio);
+				continue;
+			}
+		}
+		cp_fifo_status = fifo_ind;
+receive_again:
+		if (skw_sdio->adma_rx_enable) {
+			int	nsize_offset;
+			buf_num = skw_sdio->remain_packet;
+			if (buf_num > MAX_PAC_COUNT)
+				buf_num = MAX_PAC_COUNT;
+
+			buf_num = buf_num + 1;
+			sgs = skw_sdio_prepare_adma_buffer(skw_sdio, &buf_num, &nsize_offset);
+			buf_num = buf_num -1;
+			if (! sgs) {
+				skw_sdio_err("line %d get_tx_buf_list fail\n", __LINE__);
+				goto submit_packets;
+			}
+			if (skw_sdio->power_off) {
+				skw_sdio_err("line %d device power off\n", __LINE__);
+				rx_nsize = 0;
+				ret = -EIO;
+			} else {
+				ret = skw_sdio_adma_read(skw_sdio, sgs, buf_num + 1,
+					buf_num * max_pac_size+nsize_offset);
+			}
+			if (ret != 0) {
+				skw_sdio_err("%s line %d adma read fail ret:%d\n", __func__, __LINE__, ret);
+				if (ret == -ETIMEDOUT && !skw_sdio->power_off) {
+					try_to_wakeup_modem(8);
+					ret = skw_sdio_adma_read(skw_sdio, sgs, buf_num + 1,
+							buf_num * max_pac_size+nsize_offset);
+				}
+				if (ret) {
+					skw_sdio_err("%s line %d adma read fail ret:%d\n", __func__, __LINE__, ret);
+					rx_nsize = 0;
+					kfree(sgs);
+					goto submit_packets;
+				}
+			}
+			rx_nsize =  *((uint32_t *)(skw_sdio->next_size_buf + (nsize_offset - 4)));
+			valid_len = *((uint32_t *)(skw_sdio->next_size_buf + (nsize_offset - 8)));
+			skw_sdio_dbg("line:%d total:%lld next_pac:%d:, valid len:%d cnt %d\n",
+					  __LINE__,skw_sdio->rx_packer_cnt, rx_nsize, valid_len, buf_num);
+
+			if(skw_cp_ver == SKW_SDIO_V10){
+				skw_sdio_adma_parser(skw_sdio, sgs, buf_num);
+			}
+			else{
+				skw_sdio2_adma_parser(skw_sdio, sgs, buf_num);
+			}
+			kfree(sgs);
+		} else {
+			unsigned int alloc_size;
+
+			read_len = skw_sdio->next_size;
+			alloc_size = SKW_SDIO_ALIGN_BLK(read_len);
+			rx_buf = kzalloc(alloc_size, GFP_KERNEL);
+			if (!rx_buf) {
+				skw_sdio_err("line %d sdma malloc fail:%d\n", __LINE__, ret);
+				goto submit_packets;
+			}
+
+			ret = skw_sdio_sdma_read(rx_buf, alloc_size);
+#if 0
+			print_hex_dump(KERN_ERR, "src_sdma_data:", 0, 16, 1,
+					rx_buf, alloc_size, 1);
+#endif
+			if (ret != 0) {
+				skw_sdio_err("%d sdma read fail ret:%d\n", __LINE__, ret);
+				rx_nsize = 0;
+				goto submit_packets;
+			}
+			rx_nsize = *((uint32_t *)(rx_buf + (alloc_size- 4)));
+			valid_len = *((uint32_t *)(rx_buf + (alloc_size - 8)));
+
+			skw_sdio_dbg("%s the sdma rx thread alloc_size:%d,read_len:%d,rx_nsize:%d,valid_len:%d\n",
+					__func__,alloc_size, read_len, rx_nsize, valid_len);
+			if(skw_cp_ver == SKW_SDIO_V10){
+				skw_sdio_sdma_parser(rx_buf, valid_len);
+			}
+			else{
+				skw_sdio2_sdma_parser(rx_buf, valid_len);
+			}
+			kfree(rx_buf);
+		}
+submit_packets:
+		skw_sdio_dispatch_packets(skw_sdio);
+		if (skw_sdio->adma_rx_enable)
+			skw_sdio_adma_set_packet_num(rx_nsize);
+		else
+			skw_sdio_sdma_set_nsize(rx_nsize);
+		if (skw_sdio->power_off)
+			rx_nsize = 0;
+		if (rx_nsize > 0)
+			goto receive_again;
+
+		debug_infos.last_irq_time = 0;
+		skw_sdio_unlock_rx_ws(skw_sdio);
+	}
+	skw_sdio_info("%s exit\n", __func__);
+	return 0;
+}
+
+static int open_sdio_port(int id, void *callback, void *data)
+{
+	struct sdio_port *port;
+
+	if(id >= max_ch_num)
+		return -EINVAL;
+
+	port = &sdio_ports[id];
+	if((port->state==PORT_STATE_OPEN) || port->rx_submit)
+		return -EBUSY;
+	port->rx_submit = callback;
+	port->rx_data = data;
+	init_completion(&port->rx_done);
+	init_completion(&port->tx_done);
+	mutex_init(&port->rx_mutex);
+	port->state = PORT_STATE_OPEN;
+	port->tx_flow_ctrl = 0;
+	port->rx_flow_ctrl = 0;
+	if(id && id!=skw_log_port()) {
+		port->rx_wp = port->rx_rp = 0;
+		port->next_seqno = 1; //cp start seqno default no 1
+	}
+	skw_sdio_info("%s(%d) %s portno = %d\n", current->comm, current->pid, __func__, id);
+	return 0;
+}
+static int close_sdio_port(int id)
+{
+	struct sdio_port *port;
+
+	if(id >= max_ch_num)
+		return -EINVAL;
+	port = &sdio_ports[id];
+	skw_sdio_info("%s(state=%d) portno = %d\n", current->comm, port->state, id);
+	if(!port->state)
+		return -ENODEV;
+	port->state = PORT_STATE_CLSE;
+	port->rx_submit = NULL;
+	complete(&port->rx_done);
+	return 0;
+}
+
+void send_host_suspend_indication(struct skw_sdio_data_t *skw_sdio)
+{
+	uint32_t value = 0;
+	uint32_t timeout = 2000, timeout1 = 20;
+	if(skw_sdio->gpio_out>=0 && skw_sdio->resume_com) {
+		skw_sdio_dbg("%s enter gpio=0\n", __func__);
+		skw_sdio->host_active = 0;
+		if (gpio_get_value(skw_sdio->gpio_in) == 0) {
+			udelay(10);
+			if (gpio_get_value(skw_sdio->gpio_in) == 0) {
+				disable_irq(skw_sdio->irq_num);
+				gpio_set_value(skw_sdio->gpio_out, 0);
+				do {
+					value = gpio_get_value(skw_sdio->gpio_in);
+					if (value || timeout1 == 0) {
+						skw_sdio_info("%s cp sts:%d in %d ms\n", __func__, value, 20 - timeout1);
+						enable_irq(skw_sdio->irq_num);
+						goto next;
+					}
+					mdelay(1);
+				} while(timeout1--);
+			}
+		}
+		gpio_set_value(skw_sdio->gpio_out, 0);
+next:
+		skw_sdio->device_active = 0;
+		do {
+			value = gpio_get_value(skw_sdio->gpio_in);
+			if(value == 0)
+				break;
+			udelay(10);
+		}while(timeout--);
+	} else
+		skw_sdio_dbg("%s enter\n", __func__);
+}
+
+void send_host_resume_indication(struct skw_sdio_data_t *skw_sdio)
+{
+	if(skw_sdio->gpio_out >= 0) {
+		skw_sdio_dbg("%s enter\n", __func__);
+		skw_sdio->host_active = 1;
+		gpio_set_value(skw_sdio->gpio_out, 1);
+		skw_sdio->resume_com = 1;
+	}
+}
+
+static void send_cp_wakeup_signal(struct skw_sdio_data_t *skw_sdio)
+{
+	if(skw_sdio->gpio_out < 0)
+		return;
+
+	gpio_set_value(skw_sdio->gpio_out, 0);
+	udelay(5);
+	gpio_set_value(skw_sdio->gpio_out, 1);
+}
+
+extern int skw_sdio_enable_async_irq(void);
+int try_to_wakeup_modem(int portno)
+{
+	int ret = 0;
+	int val;
+	unsigned long flags;
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+
+	if(skw_sdio->gpio_out < 0)
+		return 0;
+	skw_sdio->device_active = gpio_get_value(skw_sdio->gpio_in);
+
+	if(skw_sdio->device_active)
+		return 0;
+	skw_reinit_completion(skw_sdio->device_wakeup);
+	skw_sdio->tx_req_map |= 1<<portno;
+	//skw_sdio_info("%s enter gpio_val=%d : %d\n", __func__, skw_sdio->device_active, skw_sdio->resume_com);
+	skw_port_log(portno,"%s enter device_active=%d : %d\n", __func__, skw_sdio->device_active, skw_sdio->resume_com);
+	if(skw_sdio->device_active == 0) {
+		local_irq_save(flags);
+		if(skw_sdio->resume_com==0)
+			gpio_set_value(skw_sdio->gpio_out, 1);
+		else
+			send_cp_wakeup_signal(skw_sdio);
+		local_irq_restore(flags);
+		ret = wait_for_completion_interruptible_timeout(&skw_sdio->device_wakeup, HZ/100);
+		if (ret < 0) {
+			skw_sdio->tx_req_map &= ~(1<<portno);
+			return -ETIMEDOUT;
+		}
+	}
+	val = gpio_get_value(skw_sdio->gpio_in);
+	if(!val) {
+		local_irq_save(flags);
+		send_cp_wakeup_signal(skw_sdio);
+		local_irq_restore(flags);
+		ret = wait_for_completion_interruptible_timeout(&skw_sdio->device_wakeup, HZ/100);
+		if (ret < 0) {
+			skw_sdio->tx_req_map &= ~(1<<portno);
+			return -ETIMEDOUT;
+		}
+		val = gpio_get_value(skw_sdio->gpio_in);
+	}
+	if ( val && !skw_sdio->sdio_func[FUNC_1]->irq_handler &&
+		!skw_sdio->resume_com && skw_sdio->irq_type == SKW_SDIO_INBAND_IRQ) {
+		sdio_claim_host(skw_sdio->sdio_func[FUNC_1]);
+		ret=sdio_claim_irq(skw_sdio->sdio_func[FUNC_1],skw_sdio_inband_irq_handler);
+		ret = skw_sdio_enable_async_irq();
+		if (ret < 0)
+			skw_sdio_err("enable sdio async irq fail ret = %d\n", ret);
+		sdio_release_host(skw_sdio->sdio_func[FUNC_1]);
+		skw_port_log(portno,"%s enable SDIO inband IRQ ret=%d\n", __func__, ret);
+	}
+	return ret;
+}
+void host_gpio_in_routine(int value)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	int  device_active = skw_sdio->device_active;
+	if(skw_sdio->gpio_out < 0)
+		return;
+
+	skw_sdio->device_active = value;
+	skw_sdio_dbg("%s enter %d-%d, host tx=0x%x:%d\n", __func__, device_active,
+			skw_sdio->device_active, skw_sdio->tx_req_map, skw_sdio->host_active);
+	if(device_active  && !skw_sdio->device_active &&
+		skw_sdio->tx_req_map && skw_sdio->host_active) {
+		send_cp_wakeup_signal(skw_sdio);
+	}
+	if(skw_sdio->device_active && atomic_read(&skw_sdio->resume_flag))
+		complete(&skw_sdio->device_wakeup);
+	if(skw_sdio->device_active) {
+		if(skw_sdio->host_active == 0)
+			skw_sdio->host_active = 1;
+		gpio_set_value(skw_sdio->gpio_out, 1);
+		skw_sdio->resume_com = 1;
+	}
+}
+
+static int setup_sdio_packet(void *packet, u8 channel, char *msg, int size)
+{
+	struct skw_packet_header *header = NULL;
+	u32 *data = packet;
+
+	data[0] = 0;
+	header = (struct skw_packet_header *)data;
+	header->channel = channel;
+	header->len = size;
+	memcpy(data+1, msg, size);
+	data++;
+	data[size>>2] = 0;
+	header = (struct skw_packet_header *)&data[size>>2];
+	header->eof = 1;
+	size += 8;
+	return size;
+}
+static int setup_sdio2_packet(void *packet, u8 channel, char *msg, int size)
+{
+	struct skw_packet2_header *header = NULL;
+	u32 *data = packet;
+
+	data[0] = 0;
+	header = (struct skw_packet2_header *)data;
+	header->channel = channel;
+	header->len = size;
+	memcpy(data+1, msg, size);
+	data++;
+	data[size>>2] = 0;
+	header = (struct skw_packet2_header *)&data[size>>2];
+	header->eof = 1;
+	size += 8;
+	return size;
+}
+int loopcheck_send_data(char *buffer, int size)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	struct sdio_port *port;
+	int ret, count;
+	if(skw_cp_ver == SKW_SDIO_V10){
+		port = &sdio_ports[LOOPCHECK_PORT];
+	}else{
+		port = &sdio_ports[SDIO2_LOOPCHECK_PORT];
+		skw_sdio_info("the sdio2 loopcheck_send_data is called --%d",SDIO2_LOOPCHECK_PORT);
+	}
+	count = (size + 3) & 0xFFFFFFFC;
+	skw_sdio_dbg("start--debug----portno=%d----port length=%x -\n",port->channel,port->length);
+	if(count + 8 < port->length) {
+		if(skw_cp_ver == SKW_SDIO_V10){
+			count = setup_sdio_packet(port->write_buffer, port->channel, buffer, count);
+		}
+		else{
+			count = setup_sdio2_packet(port->write_buffer, port->channel, buffer, count);
+		}
+		try_to_wakeup_modem(LOOPCHECK_PORT);
+		if(!(ret = skw_sdio_sdma_write(port->write_buffer, count))) {
+			port->total += count;
+			port->sent_packet++;
+			ret = size;
+		}
+		skw_sdio->tx_req_map &= ~(1<<LOOPCHECK_PORT);
+		return ret;
+	}
+	return -ENOMEM;
+}
+
+int send_data_async(int portno, char *buffer, int size)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	struct sdio_port *port;
+	int ret, count;
+	u32 *data = (u32 *)buffer;
+	if(size==0)
+		return 0;
+	if(portno >= max_ch_num)
+		return -EINVAL;
+	port = &sdio_ports[portno];
+	if(!port->state || skw_sdio->cp_state)
+		return -EIO;
+
+	if(port->state == PORT_STATE_CLSE) {
+		port->state = PORT_STATE_IDLE;
+		return -EIO;
+	}
+	skw_sdio_dbg("line:%d---the portno %d --send data size=%d 0x%x, 0x%x \n",__LINE__,portno, size, data[0], data[1]);
+	count = (size + 3) & 0xFFFFFFFC;
+	if(count + 8 < port->length) {
+		if(skw_cp_ver == SKW_SDIO_V10){
+			count = setup_sdio_packet(port->write_buffer, port->channel, buffer, count);
+		}
+		else{
+			count = setup_sdio2_packet(port->write_buffer, port->channel, buffer, count);
+		}
+		if(skw_sdio->cp_state)
+			return -EIO;
+
+		if(!(ret = skw_sdio_sdma_write(port->write_buffer, count))) {
+			port->tx_flow_ctrl++;
+			port->total += count;
+			port->sent_packet++;
+			ret = size;
+		}
+		skw_sdio->tx_req_map &= ~(1<<portno);
+		return ret;
+	}
+	return -ENOMEM;
+}
+
+static int skw_sdio_suspend_sdma_cmd(int portno, char *buffer, int size)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	struct sdio_port *port;
+	int ret, count, i;
+	if(size==0)
+		return 0;
+	if(portno >= max_ch_num)
+		return -EINVAL;
+	port = &sdio_ports[portno];
+	if(!port->state || skw_sdio->cp_state)
+		return -EIO;
+
+	if(port->state == PORT_STATE_CLSE) {
+		port->state = PORT_STATE_IDLE;
+		return -EIO;
+	}
+
+	count = (size + 3) & 0xFFFFFFFC;
+	if(count + 8 < port->length) {
+		if(skw_cp_ver == SKW_SDIO_V10){
+			count = setup_sdio_packet(port->write_buffer, port->channel, buffer, count);
+		}
+		else{
+			count = setup_sdio2_packet(port->write_buffer, port->channel, buffer, count);
+		}
+		skw_reinit_completion(port->tx_done);
+		try_to_wakeup_modem(portno);
+
+		if(skw_sdio->cp_state)
+			return -EIO;
+
+		if(!(ret = skw_sdio_sdma_write(port->write_buffer, count))) {
+			port->tx_flow_ctrl++;
+			if(sdio_ports[portno].state != PORT_STATE_ASST) {
+				ret = wait_for_completion_interruptible_timeout(&port->tx_done, 
+						msecs_to_jiffies(100));
+				if(!ret && port->tx_flow_ctrl) {
+					try_to_wakeup_modem(portno);
+					port->tx_flow_ctrl--;
+				}
+			}
+			port->total += count;
+			port->sent_packet++;
+			ret = size;
+		} else {
+			skw_sdio_info("%s ret=%d\n", __func__, ret);
+		}
+		skw_sdio->tx_req_map &= ~(1<<portno);
+		return ret;
+	} else {
+		for(i=0; i<2; i++) {
+			try_to_wakeup_modem(portno);
+			if(!(ret = skw_sdio_sdma_write(buffer, count))) {
+				port->total += count;
+				port->sent_packet++;
+				ret = size;
+				break;
+			} else {
+				skw_sdio_info("%s ret=%d\n", __func__, ret);
+				if(ret == -ETIMEDOUT && !skw_sdio->device_active)
+					continue;
+			}
+		}
+		skw_sdio->tx_req_map &= ~(1<<portno);
+		return ret;
+	}
+	return -ENOMEM;
+}
+
+static int send_data(int portno, char *buffer, int size)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	struct sdio_port *port;
+	int ret, count, i;
+	u32 *data = (u32 *)buffer;
+
+	if(size==0)
+		return 0;
+	if(portno >= max_ch_num)
+		return -EINVAL;
+	port = &sdio_ports[portno];
+	if(!port->state || skw_sdio->cp_state)
+		return -EIO;
+
+	if(port->state == PORT_STATE_CLSE) {
+		port->state = PORT_STATE_IDLE;
+		return -EIO;
+	}
+	//skw_sdio_info("line:%d---the portno %d --send data \n",__LINE__,portno);
+	count = (size + 3) & 0xFFFFFFFC;
+	if(count + 8 < port->length) {
+		if(skw_cp_ver == SKW_SDIO_V10){
+			count = setup_sdio_packet(port->write_buffer, port->channel, buffer, count);
+		}
+		else{
+			count = setup_sdio2_packet(port->write_buffer, port->channel, buffer, count);
+		}
+		skw_reinit_completion(port->tx_done);
+		for(i=0; i<2; i++) {
+		try_to_wakeup_modem(portno);
+
+		if(skw_sdio->cp_state)
+			return -EIO;
+
+		if(!(ret = skw_sdio_sdma_write(port->write_buffer, count))) {
+			port->tx_flow_ctrl++;
+			if(sdio_ports[portno].state != PORT_STATE_ASST) {
+				ret = wait_for_completion_interruptible_timeout(&port->tx_done, 
+						msecs_to_jiffies(100));
+				if(!ret && port->tx_flow_ctrl) {
+					try_to_wakeup_modem(portno);
+					skw_sdio_info("%s port%d ret=%d:%d and retry again\n", __func__, port->channel, ret, port->tx_flow_ctrl);
+					port->tx_flow_ctrl--;
+					continue;
+				}
+			}
+			port->total += count;
+			port->sent_packet++;
+			ret = size;
+			break;
+		} else {
+			skw_sdio_info("%s ret=%d\n", __func__, ret);
+			if(ret == -ETIMEDOUT && !skw_sdio->device_active)
+				continue;
+		}
+		}
+		skw_sdio->tx_req_map &= ~(1<<portno);
+		skw_port_log(portno,"%s port%d size=%d 0x%x 0x%x\n",
+			__func__, portno, size, data[0], data[1]);
+		return ret;
+	} else {
+		for(i=0; i<2; i++) {
+			try_to_wakeup_modem(portno);
+			if(!(ret = skw_sdio_sdma_write(buffer, count))) {
+				port->total += count;
+				port->sent_packet++;
+				ret = size;
+				break;
+			} else {
+				skw_sdio_info("%s ret=%d\n", __func__, ret);
+				if(ret == -ETIMEDOUT && !skw_sdio->device_active)
+					continue;
+			}
+		}
+		skw_sdio->tx_req_map &= ~(1<<portno);
+		skw_port_log(portno,"%s port%d size=%d 0x%x 0x%x\n",
+			__func__, portno, size, data[0], data[1]);
+		return ret;
+	}
+	return -ENOMEM;
+}
+static int sdio_read(struct sdio_port *port, char *buffer, int size)
+{
+	int data_size;
+	int	ret = 0;
+	int buffer_size;
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	skw_sdio_dbg("%s buffer size = %d , (wp, rp) = (%d, %d), state %d\n",
+			__func__, size, port->rx_wp, port->rx_rp, port->state);
+	if(port->state == PORT_STATE_ASST) {
+		skw_sdio_err("Line:%d The CP assert  portno =%d error code =%d cp_state=%d !!\n",__LINE__,
+				port->channel, ENOTCONN, skw_sdio->cp_state);
+		if(skw_sdio->cp_state!=0){
+			if(port->channel==skw_log_port())
+				port->state = PORT_STATE_OPEN;
+
+			return -ENOTCONN;
+		}
+	}
+try_again0:
+	skw_reinit_completion(port->rx_done);
+	if(port->rx_wp == port->rx_rp) {
+
+		if ((port->state == PORT_STATE_CLSE) ||((port->channel>0&&port->channel !=skw_log_port())
+					&& !(skw_sdio->service_state_map & (1<<BT_SERVICE)))) {
+			skw_sdio_err("the log port or at port ---%d --%d\n", port->channel, skw_log_port());
+			return -EIO;
+		}
+		ret = wait_for_completion_interruptible(&port->rx_done);
+		if(ret)
+			return ret;
+		if(port->state == PORT_STATE_CLSE) {
+			port->state = PORT_STATE_IDLE;
+			return -EAGAIN;
+		}else if(port->state == PORT_STATE_ASST) {
+			skw_sdio_err("The CP assert  portno =%d error code =%d!!!!\n", port->channel, ENOTCONN);
+			if(skw_sdio->cp_state!=0){
+				if(port->channel==skw_log_port())
+					port->state = PORT_STATE_OPEN;
+
+				return -ENOTCONN;
+			}
+		}
+	}
+	mutex_lock(&port->rx_mutex);
+	data_size = (port->length + port->rx_wp - port->rx_rp)%port->length;
+	if(data_size==0) {
+		skw_sdio_info("%s buffer size = %d , (wp, rp) = (%d, %d)\n",
+			__func__, size, port->rx_wp, port->rx_rp);
+		mutex_unlock(&port->rx_mutex);
+		goto try_again0;
+	}
+	if(size > data_size)
+		size = data_size;
+	data_size = port->length - port->rx_rp;
+	if(size > data_size) {
+		memcpy(buffer, &port->read_buffer[port->rx_rp], data_size);
+		memcpy(buffer+data_size, &port->read_buffer[0], size - data_size);
+		port->rx_rp = size - data_size;
+	} else {
+		skw_sdio_dbg("size1 = %d , (wp, rp) = (%d, %d) (packet, total)=(%d, %d)\n",
+				size, port->rx_wp, port->rx_rp, port->rx_packet, port->rx_count);
+		memcpy(buffer, &port->read_buffer[port->rx_rp], size);
+		port->rx_rp += size;
+	}
+
+	if (port->rx_rp == port->length)
+		port->rx_rp = 0;
+
+	if(port->rx_rp == port->rx_wp){
+		port->rx_rp = 0;
+		port->rx_wp = 0;
+	}
+	if(port->rx_flow_ctrl) {
+		buffer_size = (port->length + port->rx_wp - port->rx_rp)%port->length;
+		buffer_size = port->length - 1 - buffer_size;
+
+		if (buffer_size > (port->length*2/3)) {
+			port->rx_flow_ctrl = 0;
+			skw_sdio_rx_port_follow_ctl(port->channel, port->rx_flow_ctrl);
+		}
+	}
+	mutex_unlock(&port->rx_mutex);
+	return size;
+}
+
+int recv_data(int portno, char *buffer, int size)
+{
+	struct sdio_port *port;
+	int ret;
+	if(size==0)
+		return 0;
+	if(portno >= max_ch_num)
+		return -EINVAL;
+	port = &sdio_ports[portno];
+	if(!port->state)
+		return -EIO;
+	if(port->state == PORT_STATE_CLSE) {
+		port->state = PORT_STATE_IDLE;
+		return -EIO;
+	}
+	ret = sdio_read(port, buffer, size);
+	return ret;
+}
+int skw_sdio_suspend_adma_cmd(int portno, struct scatterlist *sg, int sg_num, int total)
+{
+	struct sdio_port *port;
+	int ret, i;
+	int irq_state = 0;
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	u32 *data;
+
+	if(total==0)
+		return 0;
+	if(portno >= max_ch_num)
+		return -EINVAL;
+	port = &sdio_ports[portno];
+	if(!port->state)
+		return -EIO;
+	data = (u32 *)sg_virt(sg);
+	irq_state = skw_sdio_irq_ops(0);
+	for(i=0; i<2; i++) {
+		try_to_wakeup_modem(portno);
+		ret = skw_sdio_adma_write(portno, sg, sg_num, total);
+		if(!ret){
+			break;
+		}
+		if(skw_sdio->gpio_in >=0)
+			skw_sdio_info("timeout gpioin value=%d \n",gpio_get_value(skw_sdio->gpio_in));
+	}
+	if(!irq_state){
+		skw_sdio_irq_ops(1);
+	}
+	skw_sdio->tx_req_map &= ~(1<<portno);
+	skw_port_log(portno,"%s port%d sg_num=%d total=%d 0x%x 0x%x\n",
+			__func__, portno, sg_num, total, data[0], data[1]);
+	if(portno == WIFI_CMD_PORT) {
+		if (skw_sdio->gpio_in >=0 && !gpio_get_value(skw_sdio->gpio_in)) {
+			skw_sdio_info("modem is sleep and wakeup it\n");
+			try_to_wakeup_modem(portno);
+		}
+	}
+	port->total += total;
+	port->sent_packet += sg_num;
+	return ret;
+}
+
+static int skw_sdio_irq_ops(int irq_enable)
+{
+	int ret =-1;
+#if 0//def CONFIG_SKW_DL_TIME_STATS
+	ktime_t cur_time,last_time;
+#endif
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	if(skw_sdio->gpio_in < 0 ) {
+		skw_sdio_info("gpio_in < 0 no need the cls the irq ops !!\n");
+		return ret;
+	}
+	skw_sdio_info("gpio_in num %d the value %d !!\n",skw_sdio->gpio_in,gpio_get_value(skw_sdio->gpio_in));
+	if(irq_enable){
+		skw_sdio_info("enable irq\n");
+		skw_sdio->suspend_wake_unlock_enable = 1;
+		enable_irq(skw_sdio->irq_num);
+		ret = 0;
+		//enable_irq_wake(skw_sdio->irq_num);
+		//last_time = ktime_get();
+		//skw_sdio_info("line %d start time %llu and the over time %llu ,the usertime=%llu \n",__LINE__,
+		//cur_time, last_time,(last_time-cur_time));
+	}else{
+		if (gpio_get_value(skw_sdio->gpio_in) == 0) {
+			udelay(10);
+			if (gpio_get_value(skw_sdio->gpio_in) == 0) {
+				disable_irq(skw_sdio->irq_num);
+				ret = 0;
+#if 0//def CONFIG_SKW_DL_TIME_STATS
+				cur_time = ktime_get();
+#endif
+				skw_sdio_info("disable irq\n");
+			}else{
+				skw_sdio_info("NO disable irq cp wake !the value %d !!\n",gpio_get_value(skw_sdio->gpio_in));
+				ret = -2;
+			}
+		}
+		//disable_irq_wake(skw_sdio->irq_num);
+		//disable_irq(skw_sdio->irq_num);
+	}
+
+	return ret;
+};
+
+int wifi_send_cmd(int portno, struct scatterlist *sg, int sg_num, int total)
+{
+	struct sdio_port *port;
+	int ret, i;
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	u32 *data;
+
+	if(total==0)
+		return 0;
+	if(portno >= max_ch_num)
+		return -EINVAL;
+	port = &sdio_ports[portno];
+	if(!port->state)
+		return -EIO;
+	data = (u32 *)sg_virt(sg);
+	for(i=0; i<2; i++) {
+		try_to_wakeup_modem(portno);
+		ret = skw_sdio_adma_write(portno, sg, sg_num, total);
+		if(!ret)
+			break;
+		skw_sdio_info("timeout gpioin value=%d \n",gpio_get_value(skw_sdio->gpio_in));
+	}
+	skw_sdio->tx_req_map &= ~(1<<portno);
+	if (portno == WIFI_CMD_PORT ||
+	   (skw_cp_ver == SKW_SDIO_V20 && portno ==  WIFI_DATA_PORT)) {
+		skw_port_log(portno, "%s port%d sg_num=%d total=%d 0x%x 0x%x 0x%x 0x%x\n",
+			__func__, portno, sg_num, total, data[0], data[1], data[2], data[3]);
+		memcpy(debug_infos.last_sent_wifi_cmd, data, 12);
+		debug_infos.last_sent_time = skw_local_clock();
+		if (skw_sdio->gpio_in >=0 && !gpio_get_value(skw_sdio->gpio_in)) {
+			skw_sdio_info("modem is sleep and wakeup it\n");
+			try_to_wakeup_modem(portno);
+		}
+	}
+	port->total += total;
+	port->sent_packet += sg_num;
+	return ret;
+}
+static int register_rx_callback(int id, void *func, void *para)
+{
+	struct sdio_port *port;
+
+	if(id >= max_ch_num)
+		return -EINVAL;
+	port = &sdio_ports[id];
+	if(port->state && func)
+		return -EBUSY;
+	port->rx_submit = func;
+	port->rx_data = para;
+	if(func) {
+		port->sg_rx = kzalloc(MAX_SG_COUNT * sizeof(struct scatterlist), GFP_KERNEL);
+		if(port->sg_rx == NULL)
+			return -ENOMEM;
+		port->state = PORT_STATE_OPEN;
+	} else {
+		if (port->sg_rx) {
+			kfree(port->sg_rx);
+			port->sg_rx = NULL;
+		}
+		port->state = PORT_STATE_IDLE;
+	}
+	return 0;
+}
+/***************************************************************************
+ *Description:
+ *Seekwave tech LTD
+ *Author:
+ *Date:
+ *Modify:
+ **************************************************************************/
+static int bt_service_start(void)
+{
+	int ret =0;
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	if(skw_sdio->boot_data==NULL)
+		return ret;
+	ret=skw_sdio->boot_data->bt_start();
+	return ret;
+}
+
+/***************************************************************************
+ *Description:
+ *Seekwave tech LTD
+ *Author:
+ *Date:
+ *Modify:
+ **************************************************************************/
+static int bt_service_stop(void)
+{
+	int ret =0;
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	if(skw_sdio->boot_data ==NULL)
+		return ret;
+	ret=skw_sdio->boot_data->bt_stop();
+	return ret;
+}
+
+
+/***************************************************************************
+ *Description:
+ *Seekwave tech LTD
+ *Author:
+ *Date:
+ *Modify:
+ **************************************************************************/
+static int wifi_service_start(void)
+{
+	int ret =0;
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	if(skw_sdio->boot_data==NULL)
+		return ret;
+	ret=skw_sdio->boot_data->wifi_start();
+	return ret;
+}
+
+/***************************************************************************
+ *Description:
+ *Seekwave tech LTD
+ *Author:
+ *Date:
+ *Modify:
+ **************************************************************************/
+static int wifi_service_stop(void)
+{
+	int ret =0;
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	if(skw_sdio->boot_data ==NULL){
+		return ret;
+    }
+	ret=skw_sdio->boot_data->wifi_stop();
+	return ret;
+}
+
+static int wifi_get_credit(void)
+{
+	char val;
+	int err;
+
+	err = skw_sdio_readb(SDIOHAL_PD_DL_CP2AP_SIG4, &val);
+	if(err)
+		return err;
+	return val;
+}
+static int wifi_store_credit_to_cp(unsigned char val)
+{
+	int err;
+
+	err = skw_sdio_writeb(SKW_SDIO_CREDIT_TO_CP, val);
+
+	return err;
+}
+
+void kick_rx_thread(void)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+
+	debug_infos.cmd_timeout_cnt++;
+	if(skw_sdio->gpio_out < 0) {
+		skw_sdio_rx_up(skw_sdio);
+	} else {
+		skw_sdio->device_active = gpio_get_value(skw_sdio->gpio_in);
+		if(skw_sdio->device_active) {
+			skw_sdio_rx_up(skw_sdio);
+		} else {
+			try_to_wakeup_modem(LOOPCHECK_PORT);
+		}
+	}
+}
+
+struct sv6160_platform_data wifi_pdata = {
+	.data_port =  WIFI_DATA_PORT,
+	.cmd_port =  WIFI_CMD_PORT,
+	.bus_type = SDIO_LINK|TX_ADMA|RX_ADMA|CP_DBG,
+	.max_buffer_size = 170*1536,
+	.align_value = 256,
+	.hw_adma_tx = wifi_send_cmd,
+	.hw_sdma_tx = send_data,
+	.callback_register = register_rx_callback,
+	.modem_assert = send_modem_assert_command,
+	.service_start = wifi_service_start,
+	.service_stop = wifi_service_stop,
+	.modem_register_notify = modem_register_notify,
+	.modem_unregister_notify = modem_unregister_notify,
+	.wifi_power_on = skw_sdio_wifi_power_on,
+	.at_ops = {
+		.port = 0,
+		.open = open_sdio_port,
+		.close = close_sdio_port,
+		.read = recv_data,
+		.write = send_data,
+	},
+	.wifi_get_credit=wifi_get_credit,
+	.wifi_store_credit=wifi_store_credit_to_cp,
+	.debug_info = assert_context,
+	.suspend_adma_cmd = skw_sdio_suspend_adma_cmd,
+	.suspend_sdma_cmd  = skw_sdio_suspend_sdma_cmd,
+	.rx_thread_wakeup = kick_rx_thread
+};
+struct sv6160_platform_data ucom_pdata = {
+	.data_port = 2,
+	.cmd_port  = 3,
+	.audio_port = 4,
+	.bus_type = SDIO_LINK,
+	.max_buffer_size = 0x1000,
+	.align_value = 4,
+	.hw_sdma_rx = recv_data,
+	.hw_sdma_tx = send_data,
+	.open_port = open_sdio_port,
+	.close_port = close_sdio_port,
+	.modem_assert = send_modem_assert_command,
+	.service_start = bt_service_start,
+	.service_stop = bt_service_stop,
+	.modem_register_notify = modem_register_notify,
+	.modem_unregister_notify = modem_unregister_notify,
+	.skw_dump_mem = skw_sdio_dt_read,
+};
+
+int skw_sdio_bind_platform_driver(struct sdio_func *func)
+{
+	struct platform_device *pdev;
+	char	pdev_name[32];
+	struct sdio_port *port;
+	int ret = 0;
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+
+	memset(sdio_ports, 0, sizeof(struct sdio_port)*MAX_CH_NUM);
+	sprintf(pdev_name, "skw_ucom");
+/*
+ *	creaete AT device
+ */
+	pdev = platform_device_alloc(pdev_name, PLATFORM_DEVID_AUTO);
+	if(!pdev)
+		return -ENOMEM;
+	pdev->dev.parent = &func->dev;
+	pdev->dev.dma_mask = &port_dmamask;
+	pdev->dev.coherent_dma_mask = port_dmamask;
+	ucom_pdata.port_name = "ATC";
+	ucom_pdata.data_port = 0;
+	memcpy(ucom_pdata.chipid, skw_sdio->chip_id, SKW_CHIP_ID_LENGTH);
+	ret = platform_device_add_data(pdev, &ucom_pdata, sizeof(ucom_pdata));
+	if(ret) {
+		dev_err(&func->dev, "failed to add platform data \n");
+		platform_device_put(pdev);;
+		return ret;
+	}
+	port = &sdio_ports[ucom_pdata.data_port];
+	port->state = PORT_STATE_IDLE;
+	port->next_seqno = 1;
+	ret = platform_device_add(pdev);
+	if(ret) {
+		dev_err(&func->dev, "failt to register platform device\n");
+		platform_device_put(pdev);
+		return ret;
+	}
+	port->pdev = pdev;
+	port->channel = ucom_pdata.data_port;
+	port->length = SDIO_BUFFER_SIZE >> 2;
+	port->read_buffer = kzalloc(port->length , GFP_KERNEL);
+	if(port->read_buffer == NULL) {
+		dev_err(&func->dev, "failed to allocate %s RX buffer\n", ucom_pdata.port_name);
+		return -ENOMEM;
+	}
+	port->write_buffer = kzalloc(port->length , GFP_KERNEL);
+	if(port->write_buffer == NULL) {
+		dev_err(&func->dev, "failed to allocate %s TX buffer\n", ucom_pdata.port_name);
+		return -ENOMEM;
+	}
+/*
+ *	creaete log device
+ */
+	pdev = platform_device_alloc(pdev_name, PLATFORM_DEVID_AUTO);
+	if(!pdev)
+		return -ENOMEM;
+	pdev->dev.parent = &func->dev;
+	pdev->dev.dma_mask = &port_dmamask;
+	pdev->dev.coherent_dma_mask = port_dmamask;
+	ucom_pdata.port_name = "LOG";
+	if(skw_cp_ver == SKW_SDIO_V10)
+		ucom_pdata.data_port = 1;
+	else
+		ucom_pdata.data_port = SDIO2_BSP_LOG_PORT;
+	ret = platform_device_add_data(pdev, &ucom_pdata, sizeof(ucom_pdata));
+	if(ret) {
+		dev_err(&func->dev, "failed to add %s device \n", ucom_pdata.port_name);
+		platform_device_put(pdev);;
+		return ret;
+	}
+	port = &sdio_ports[ucom_pdata.data_port];
+	port->state = PORT_STATE_IDLE;
+	port->next_seqno = 1;
+	ret = platform_device_add(pdev);
+	if(ret) {
+		dev_err(&func->dev, "failt to register platform device\n");
+		platform_device_put(pdev);
+		return ret;
+	}
+
+	port->pdev = pdev;
+	port->channel = ucom_pdata.data_port;
+	port->length = SDIO_BUFFER_SIZE >> 2;
+	port->read_buffer = kzalloc(port->length , GFP_KERNEL);
+	if(port->read_buffer == NULL) {
+		dev_err(&func->dev, "failed to allocate %s RX buffer\n", ucom_pdata.port_name);
+		return -ENOMEM;
+	}
+	port->write_buffer = kzalloc(port->length , GFP_KERNEL);
+	if(port->write_buffer == NULL) {
+		dev_err(&func->dev, "failed to allocate %s TX buffer\n", ucom_pdata.port_name);
+		return -ENOMEM;
+	}
+/*
+ *	creaete LOOPCHECK device
+ */
+	pdev = platform_device_alloc(pdev_name, PLATFORM_DEVID_AUTO);
+	if(!pdev)
+		return -ENOMEM;
+	pdev->dev.parent = &func->dev;
+	pdev->dev.dma_mask = &port_dmamask;
+	pdev->dev.coherent_dma_mask = port_dmamask;
+	ucom_pdata.port_name = "LOOPCHECK";
+	if(skw_cp_ver == SKW_SDIO_V10)
+		ucom_pdata.data_port = 7;
+	else
+		ucom_pdata.data_port = SDIO2_LOOPCHECK_PORT;
+	ret = platform_device_add_data(pdev, &ucom_pdata, sizeof(ucom_pdata));
+	if(ret) {
+		dev_err(&func->dev, "failed to add platform data \n");
+		platform_device_put(pdev);;
+		return ret;
+	}
+	port = &sdio_ports[ucom_pdata.data_port];
+	port->state = PORT_STATE_IDLE;
+	ret = platform_device_add(pdev);
+	if(ret) {
+		dev_err(&func->dev, "failt to register platform device\n");
+		platform_device_put(pdev);
+		return ret;
+	}
+
+	port->pdev = pdev;
+	port->channel = ucom_pdata.data_port;
+	port->length = SDIO_BUFFER_SIZE >> 2;
+	port->read_buffer = kzalloc(port->length , GFP_KERNEL);
+	if(port->read_buffer == NULL) {
+		dev_err(&func->dev, "failed to allocate %s RX buffer\n", ucom_pdata.port_name);
+		return -ENOMEM;
+	}
+	port->write_buffer = kzalloc(port->length , GFP_KERNEL);
+	if(port->write_buffer == NULL) {
+		dev_err(&func->dev, "failed to allocate %s TX buffer\n", ucom_pdata.port_name);
+		return -ENOMEM;
+	}
+#if 0
+	if(skw_cp_ver == SKW_SDIO_V20){
+	/*
+	 *	create BSPUPDATE device
+	 */
+		pdev = platform_device_alloc(pdev_name, PLATFORM_DEVID_AUTO);
+		if(!pdev)
+			return -ENOMEM;
+		pdev->dev.parent = &func->dev;
+		pdev->dev.dma_mask = &port_dmamask;
+		pdev->dev.coherent_dma_mask = port_dmamask;
+		ucom_pdata.port_name = "BSPUPDATE";
+		ucom_pdata.data_port = SDIO2_BSP_UPDATE_PORT;
+		ret = platform_device_add_data(pdev, &ucom_pdata, sizeof(ucom_pdata));
+		if(ret) {
+			dev_err(&func->dev, "failed to add platform data \n");
+			platform_device_put(pdev);;
+			return ret;
+		}
+		port = &sdio_ports[ucom_pdata.data_port];
+		port->state = PORT_STATE_IDLE;
+		ret = platform_device_add(pdev);
+		if(ret) {
+			dev_err(&func->dev, "failt to register platform device\n");
+			platform_device_put(pdev);
+			return ret;
+		}
+
+		port->pdev = pdev;
+		port->channel = ucom_pdata.data_port;
+		port->length = SDIO_BUFFER_SIZE >> 2;
+		port->read_buffer = kzalloc(port->length , GFP_KERNEL);
+		if(port->read_buffer == NULL) {
+			dev_err(&func->dev, "failed to allocate %s RX buffer\n", ucom_pdata.port_name);
+			return -ENOMEM;
+		}
+		port->write_buffer = kzalloc(port->length , GFP_KERNEL);
+		if(port->write_buffer == NULL) {
+			dev_err(&func->dev, "failed to allocate %s TX buffer\n", ucom_pdata.port_name);
+			return -ENOMEM;
+		}
+	}
+#endif
+	return ret;
+}
+int skw_sdio_bind_WIFI_driver(struct sdio_func *func)
+{
+	struct platform_device *pdev;
+	char	pdev_name[32];
+	struct sdio_port *port;
+	int ret = 0;
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+
+	if (sdio_ports[WIFI_DATA_PORT].pdev)
+		return 0;
+	if(!strncmp((char *)skw_sdio->chip_id,"SV6160",6))
+		sprintf(pdev_name, "%s%d", SV6160_WIRELESS, func->num);
+	else
+		sprintf(pdev_name, "%s%d", SV6316_WIRELESS, func->num);
+	pdev = platform_device_alloc(pdev_name, PLATFORM_DEVID_AUTO);
+	if(!pdev)
+		return -ENOMEM;
+	pdev->dev.parent = &func->dev;
+	pdev->dev.dma_mask = &port_dmamask;
+	pdev->dev.coherent_dma_mask = port_dmamask;
+#ifdef CONFIG_SEEKWAVE_PLD_RELEASE
+	wifi_pdata.bus_type |= CP_RLS;
+#else
+	if(!strncmp((char *)skw_sdio->chip_id,"SV6160",6)){
+		wifi_pdata.bus_type |= CP_RLS;
+	}
+#endif
+	/*support the sdma type bus*/
+	if(!skw_sdio->adma_rx_enable){
+		if(skw_cp_ver == SKW_SDIO_V10)
+			wifi_pdata.bus_type = SDIO_LINK|TX_ADMA|RX_SDMA;
+		else
+			wifi_pdata.bus_type = SDIO2_LINK|TX_ADMA|RX_SDMA;
+	}
+	else{
+		if(skw_cp_ver == SKW_SDIO_V10)
+			wifi_pdata.bus_type = SDIO_LINK|TX_ADMA|RX_ADMA|CP_DBG;
+		else
+			wifi_pdata.bus_type = SDIO2_LINK|TX_ADMA|RX_ADMA|CP_DBG;
+	}
+	wifi_pdata.align_value = skw_sdio_blk_size;
+	skw_sdio_info(" wifi_pdata bus_type:0x%x \n", wifi_pdata.bus_type);
+	if(skw_cp_ver == SKW_SDIO_V20){
+		wifi_pdata.data_port = (SDIO2_WIFI_DATA1_PORT << 4) | SDIO2_WIFI_DATA_PORT;
+		wifi_pdata.cmd_port = SDIO2_WIFI_CMD_PORT;
+	}
+	memcpy(wifi_pdata.chipid, skw_sdio->chip_id, SKW_CHIP_ID_LENGTH);
+	ret = platform_device_add_data(pdev, &wifi_pdata, sizeof(wifi_pdata));
+	if(ret <0) {
+		dev_err(&func->dev, "failed to add platform data  ret=%d\n",ret);
+		platform_device_put(pdev);
+		return ret;
+	}
+	if(skw_cp_ver == SKW_SDIO_V20){
+		port = &sdio_ports[(wifi_pdata.data_port >> 4) & 0x0F];
+		port->pdev = pdev;
+		port->channel = (wifi_pdata.data_port >> 4) & 0x0F;
+		port->rx_wp = 0;
+		port->rx_rp = 0;
+		port->sg_index = 0;
+		port->state = 0;
+	}
+
+	port = &sdio_ports[wifi_pdata.data_port & 0x0F];
+	port->pdev = pdev;
+	port->channel = wifi_pdata.data_port & 0x0F;
+	port->rx_wp = 0;
+	port->rx_rp = 0;
+	port->sg_index = 0;
+	port->state = 0;
+
+	port = &sdio_ports[wifi_pdata.cmd_port];
+	port->pdev = pdev;
+	port->channel = wifi_pdata.cmd_port;
+	port->rx_wp = 0;
+	port->rx_rp = 0;
+	port->sg_index = 0;
+	port->state = 0;
+
+	ret = platform_device_add(pdev);
+	if(ret < 0) {
+		dev_err(&func->dev, "failt to register platform device\n");
+		platform_device_put(pdev);
+	}
+	return ret;
+}
+int skw_sdio_wifi_status(void)
+{
+	struct sdio_port *port = &sdio_ports[wifi_pdata.cmd_port];
+	if (port->pdev == NULL)
+		return 0;
+	return 1;
+}
+int skw_sdio_wifi_power_on(int power_on)
+{
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+	int ret;
+	if (power_on) {
+		if (skw_sdio->power_off)
+			skw_recovery_mode();
+
+		ret = skw_sdio_bind_WIFI_driver(skw_sdio->sdio_func[FUNC_1]);
+	} else {
+		ret = skw_sdio_unbind_WIFI_driver(skw_sdio->sdio_func[FUNC_1]);
+	}
+	return ret;
+}
+int skw_sdio_bind_btseekwave_driver(struct sdio_func *func)
+{
+	struct platform_device *pdev;
+	char	pdev_name[32];
+	struct sdio_port *port;
+	int ret = 0;
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+
+	sprintf(pdev_name, "btseekwave");
+/*
+ *	creaete BT DATA device
+ */
+	pdev = platform_device_alloc(pdev_name, PLATFORM_DEVID_AUTO);
+	if(!pdev)
+		return -ENOMEM;
+	pdev->dev.parent = &func->dev;
+	pdev->dev.dma_mask = &port_dmamask;
+	pdev->dev.coherent_dma_mask = port_dmamask;
+	if(skw_cp_ver == SKW_SDIO_V20){
+		ucom_pdata.data_port = 5;
+		ucom_pdata.cmd_port = 2;
+		ucom_pdata.audio_port = 3;
+	}
+	memcpy(ucom_pdata.chipid, skw_sdio->chip_id, SKW_CHIP_ID_LENGTH);
+	ret = platform_device_add_data(pdev, &ucom_pdata, sizeof(ucom_pdata));
+	if(ret) {
+		dev_err(&func->dev, "failed to add platform data \n");
+		platform_device_put(pdev);;
+		return ret;
+	}
+	port = &sdio_ports[ucom_pdata.data_port];
+	port->state = PORT_STATE_IDLE;
+	ret = platform_device_add(pdev);
+	if(ret) {
+		dev_err(&func->dev, "failt to register platform device\n");
+		platform_device_put(pdev);
+		return ret;
+	}
+	port->pdev = pdev;
+	port->channel = ucom_pdata.data_port;
+	port->length = SDIO_BUFFER_SIZE;
+	port->write_buffer = kzalloc(port->length , GFP_KERNEL);
+	if(port->write_buffer == NULL) {
+		dev_err(&func->dev, "failed to allocate %s TX buffer\n", ucom_pdata.port_name);
+		return -ENOMEM;
+	}
+/*
+ *	creaete BT COMMAND device
+ */
+	ucom_pdata.data_port = ucom_pdata.cmd_port;
+	port = &sdio_ports[ucom_pdata.data_port];
+	port->state = PORT_STATE_IDLE;
+	port->pdev = NULL;
+	port->channel = ucom_pdata.data_port;
+	port->length = SDIO_BUFFER_SIZE;
+	port->write_buffer = kzalloc(port->length , GFP_KERNEL);
+	if(port->write_buffer == NULL) {
+		dev_err(&func->dev, "failed to allocate %s TX buffer\n", ucom_pdata.port_name);
+		return -ENOMEM;
+	}
+
+/*
+ *	creaete BT audio device
+ */
+	ucom_pdata.data_port = ucom_pdata.audio_port;
+	port = &sdio_ports[ucom_pdata.data_port];
+	port->state = PORT_STATE_IDLE;
+	port->pdev = NULL;
+	port->channel = ucom_pdata.data_port;
+	port->length = SDIO_BUFFER_SIZE;
+	port->write_buffer = kzalloc(port->length , GFP_KERNEL);
+	if(port->write_buffer == NULL) {
+		dev_err(&func->dev, "failed to allocate %s TX buffer\n", ucom_pdata.port_name);
+		return -ENOMEM;
+	}
+/*
+*	creaete BT ISOC device
+*/
+#if 0
+	if(skw_cp_ver == SKW_SDIO_V20){
+		ucom_pdata.data_port = SDIO2_BT_ISOC_PORT;
+		port = &sdio_ports[ucom_pdata.data_port];
+		port->state = PORT_STATE_IDLE;
+		port->pdev = NULL;
+		port->channel = ucom_pdata.data_port;
+		port->length = SDIO_BUFFER_SIZE >> 2;
+		port->write_buffer = kzalloc(port->length , GFP_KERNEL);
+		if(port->write_buffer == NULL) {
+			dev_err(&func->dev, "failed to allocate %s TX buffer\n", ucom_pdata.port_name);
+			return -ENOMEM;
+		}
+	}
+#endif
+	skw_sdio_info(" OK!!\n");
+	return ret;
+}
+
+#ifndef CONFIG_SKW_BT
+int skw_sdio_bind_BT_driver(struct sdio_func *func)
+{
+	struct platform_device *pdev;
+	char	pdev_name[32];
+	struct sdio_port *port;
+	int ret = 0;
+	struct skw_sdio_data_t *skw_sdio = skw_sdio_get_data();
+
+
+	sprintf(pdev_name, "skw_ucom");
+/*
+ *	creaete BT DATA device
+ */
+	pdev = platform_device_alloc(pdev_name, PLATFORM_DEVID_AUTO);
+	if(!pdev)
+		return -ENOMEM;
+	pdev->dev.parent = &func->dev;
+	pdev->dev.dma_mask = &port_dmamask;
+	pdev->dev.coherent_dma_mask = port_dmamask;
+	ucom_pdata.port_name = "BTDATA";
+	if(skw_cp_ver == SKW_SDIO_V20)
+		ucom_pdata.data_port = 5;
+	else
+		ucom_pdata.data_port = 2;
+	memcpy(ucom_pdata.chipid, skw_sdio->chip_id, SKW_CHIP_ID_LENGTH);
+	ret = platform_device_add_data(pdev, &ucom_pdata, sizeof(ucom_pdata));
+	if(ret) {
+		dev_err(&func->dev, "failed to add platform data \n");
+		platform_device_put(pdev);;
+		return ret;
+	}
+	port = &sdio_ports[ucom_pdata.data_port];
+	port->state = PORT_STATE_IDLE;
+	ret = platform_device_add(pdev);
+	if(ret) {
+		dev_err(&func->dev, "failt to register platform device\n");
+		platform_device_put(pdev);
+		return ret;
+	}
+	port->pdev = pdev;
+	port->channel = ucom_pdata.data_port;
+	port->length = SDIO_BUFFER_SIZE;
+	port->read_buffer = kzalloc(port->length , GFP_KERNEL);
+	if(port->read_buffer == NULL) {
+		dev_err(&func->dev, "failed to allocate %s RX buffer\n", ucom_pdata.port_name);
+		return -ENOMEM;
+	}
+	port->write_buffer = kzalloc(port->length , GFP_KERNEL);
+	if(port->write_buffer == NULL) {
+		dev_err(&func->dev, "failed to allocate %s TX buffer\n", ucom_pdata.port_name);
+		return -ENOMEM;
+	}
+
+/*
+ *	creaete BT COMMAND device
+ */
+	pdev = platform_device_alloc(pdev_name, PLATFORM_DEVID_AUTO);
+	if(!pdev)
+		return -ENOMEM;
+	pdev->dev.parent = &func->dev;
+	pdev->dev.dma_mask = &port_dmamask;
+	pdev->dev.coherent_dma_mask = port_dmamask;
+	ucom_pdata.port_name = "BTCMD";
+	if(skw_cp_ver == SKW_SDIO_V20)
+		ucom_pdata.data_port = 2;
+	else
+		ucom_pdata.data_port = ucom_pdata.cmd_port;
+
+	//memcpy(ucom_pdata.chipid, skw_sdio->chip_id, SKW_CHIP_ID_LENGTH);
+	skw_sdio_info("The check chipid ucompdata = %s \n",ucom_pdata.chipid);
+	ret = platform_device_add_data(pdev, &ucom_pdata, sizeof(ucom_pdata));
+	if(ret) {
+		dev_err(&func->dev, "failed to add %s device \n", ucom_pdata.port_name);
+		platform_device_put(pdev);;
+		return ret;
+	}
+	port = &sdio_ports[ucom_pdata.data_port];
+	port->state = PORT_STATE_IDLE;
+	ret = platform_device_add(pdev);
+	if(ret) {
+		dev_err(&func->dev, "failt to register platform device\n");
+		platform_device_put(pdev);
+		return ret;
+	}
+
+	port->pdev = pdev;
+	port->channel = ucom_pdata.data_port;
+	port->length = SDIO_BUFFER_SIZE >> 2;
+	port->read_buffer = kzalloc(port->length , GFP_KERNEL);
+	if(port->read_buffer == NULL) {
+		dev_err(&func->dev, "failed to allocate %s RX buffer\n", ucom_pdata.port_name);
+		return -ENOMEM;
+	}
+	port->write_buffer = kzalloc(port->length , GFP_KERNEL);
+	if(port->write_buffer == NULL) {
+		dev_err(&func->dev, "failed to allocate %s TX buffer\n", ucom_pdata.port_name);
+		return -ENOMEM;
+	}
+
+/*
+ *	creaete BT audio device
+ */
+	pdev = platform_device_alloc(pdev_name, PLATFORM_DEVID_AUTO);
+	if(!pdev)
+		return -ENOMEM;
+	pdev->dev.parent = &func->dev;
+	pdev->dev.dma_mask = &port_dmamask;
+	pdev->dev.coherent_dma_mask = port_dmamask;
+	ucom_pdata.port_name = "BTAUDIO";
+	if(skw_cp_ver == SKW_SDIO_V20)
+		ucom_pdata.data_port = 3;
+	else
+		ucom_pdata.data_port = ucom_pdata.audio_port;
+	ret = platform_device_add_data(pdev, &ucom_pdata, sizeof(ucom_pdata));
+	if(ret) {
+		dev_err(&func->dev, "failed to add platform data \n");
+		platform_device_put(pdev);;
+		return ret;
+	}
+	port = &sdio_ports[ucom_pdata.data_port];
+	port->state = PORT_STATE_IDLE;
+	ret = platform_device_add(pdev);
+	if(ret) {
+		dev_err(&func->dev, "failt to register platform device\n");
+		platform_device_put(pdev);
+		return ret;
+	}
+
+	port->pdev = pdev;
+	port->channel = ucom_pdata.data_port;
+	port->length = SDIO_BUFFER_SIZE >> 2;
+	port->read_buffer = kzalloc(port->length , GFP_KERNEL);
+	if(port->read_buffer == NULL) {
+		dev_err(&func->dev, "failed to allocate %s RX buffer\n", ucom_pdata.port_name);
+		return -ENOMEM;
+	}
+	port->write_buffer = kzalloc(port->length , GFP_KERNEL);
+	if(port->write_buffer == NULL) {
+		dev_err(&func->dev, "failed to allocate %s TX buffer\n", ucom_pdata.port_name);
+		return -ENOMEM;
+	}
+
+	if(skw_cp_ver == SKW_SDIO_V20){
+		/*
+		*	create BTISOC device
+		*/
+		pdev = platform_device_alloc(pdev_name, PLATFORM_DEVID_AUTO);
+		if(!pdev)
+			return -ENOMEM;
+		pdev->dev.parent = &func->dev;
+		pdev->dev.dma_mask = &port_dmamask;
+		pdev->dev.coherent_dma_mask = port_dmamask;
+		ucom_pdata.port_name = "BTISOC";
+		ucom_pdata.data_port = SDIO2_BT_ISOC_PORT;
+		ret = platform_device_add_data(pdev, &ucom_pdata, sizeof(ucom_pdata));
+		if(ret) {
+			dev_err(&func->dev, "failed to add platform data \n");
+			platform_device_put(pdev);;
+			return ret;
+		}
+		port = &sdio_ports[ucom_pdata.data_port];
+		port->state = PORT_STATE_IDLE;
+		ret = platform_device_add(pdev);
+		if(ret) {
+			dev_err(&func->dev, "failt to register platform device\n");
+			platform_device_put(pdev);
+			return ret;
+		}
+
+		port->pdev = pdev;
+		port->channel = ucom_pdata.data_port;
+		port->length = SDIO_BUFFER_SIZE >> 2;
+		port->read_buffer = kzalloc(port->length , GFP_KERNEL);
+		if(port->read_buffer == NULL) {
+			dev_err(&func->dev, "failed to allocate %s RX buffer\n", ucom_pdata.port_name);
+			return -ENOMEM;
+		}
+		port->write_buffer = kzalloc(port->length , GFP_KERNEL);
+		if(port->write_buffer == NULL) {
+			dev_err(&func->dev, "failed to allocate %s TX buffer\n", ucom_pdata.port_name);
+			return -ENOMEM;
+		}
+
+		/*
+		*	create BTLOG device
+		*/
+		pdev = platform_device_alloc(pdev_name, PLATFORM_DEVID_AUTO);
+		if(!pdev)
+			return -ENOMEM;
+		pdev->dev.parent = &func->dev;
+		pdev->dev.dma_mask = &port_dmamask;
+		pdev->dev.coherent_dma_mask = port_dmamask;
+		ucom_pdata.port_name = "BTLOG";
+		ucom_pdata.data_port = SDIO2_BT_LOG_PORT;
+		ret = platform_device_add_data(pdev, &ucom_pdata, sizeof(ucom_pdata));
+		if(ret) {
+			dev_err(&func->dev, "failed to add platform data \n");
+			platform_device_put(pdev);;
+			return ret;
+		}
+		port = &sdio_ports[ucom_pdata.data_port];
+		port->state = PORT_STATE_IDLE;
+		ret = platform_device_add(pdev);
+		if(ret) {
+			dev_err(&func->dev, "failt to register platform device\n");
+			platform_device_put(pdev);
+			return ret;
+		}
+
+		port->pdev = pdev;
+		port->channel = ucom_pdata.data_port;
+		port->length = SDIO_BUFFER_SIZE >> 2;
+		port->read_buffer = kzalloc(port->length , GFP_KERNEL);
+		if(port->read_buffer == NULL) {
+			dev_err(&func->dev, "failed to allocate %s RX buffer\n", ucom_pdata.port_name);
+			return -ENOMEM;
+		}
+		port->write_buffer = kzalloc(port->length , GFP_KERNEL);
+		if(port->write_buffer == NULL) {
+			dev_err(&func->dev, "failed to allocate %s TX buffer\n", ucom_pdata.port_name);
+			return -ENOMEM;
+		}
+	}
+	return ret;
+}
+#endif
+
+static int skw_sdio_unbind_sdio_port_driver(struct sdio_func *func, int portno )
+{
+	int i;
+	void *pdev;
+	struct sdio_port *port;
+
+	for(i=portno; i<max_ch_num;) {
+		port = &sdio_ports[i];
+		pdev = port->pdev;
+		port->pdev = NULL;
+		if(port->read_buffer)
+			kfree(port->read_buffer);
+		if(port->write_buffer)
+			kfree(port->write_buffer);
+		if(port->sg_rx)
+			kfree(port->sg_rx);
+		if(pdev)
+			platform_device_unregister(pdev);
+		port->sg_rx = NULL;
+		port->read_buffer = NULL;
+		port->write_buffer = NULL;
+		port->pdev = NULL;
+		port->rx_wp = 0;
+		port->rx_rp = 0;
+		port->sg_index = 0;
+		port->state = 0;
+		break;
+	}
+	return 0;
+}
+
+int skw_sdio_unbind_platform_driver(struct sdio_func *func)
+{
+	int ret;
+
+	ret = skw_sdio_unbind_sdio_port_driver(func, 0);
+	if(skw_cp_ver == SKW_SDIO_V20) {
+		ret |= skw_sdio_unbind_sdio_port_driver(func, SDIO2_BSP_LOG_PORT);
+		ret |= skw_sdio_unbind_sdio_port_driver(func, SDIO2_LOOPCHECK_PORT);
+	} else {
+		ret |= skw_sdio_unbind_sdio_port_driver(func, 1);
+		ret |= skw_sdio_unbind_sdio_port_driver(func, 7);
+	}
+	return ret;
+}
+
+int skw_sdio_unbind_WIFI_driver(struct sdio_func *func)
+{
+	int ret;
+
+	ret = skw_sdio_unbind_sdio_port_driver(func, SDIO2_WIFI_CMD_PORT);
+	return ret;
+}
+
+int skw_sdio_unbind_BT_driver(struct sdio_func *func)
+{
+	int ret = 0;
+
+	if (skw_cp_ver == SKW_SDIO_V20) {
+		ret = skw_sdio_unbind_sdio_port_driver(func, SDIO2_BT_LOG_PORT);
+		ret |= skw_sdio_unbind_sdio_port_driver(func, 5);
+	}
+	ret |= skw_sdio_unbind_sdio_port_driver(func, 2);
+	ret |= skw_sdio_unbind_sdio_port_driver(func, 3);
+	ret |= skw_sdio_unbind_sdio_port_driver(func, 4);
+	return ret;
+}
diff --git a/drivers/misc/seekwaveplatform_v20/skwutil/Kconfig b/drivers/misc/seekwaveplatform_v20/skwutil/Kconfig
new file mode 100755
index 000000000000..a01841ff6805
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/skwutil/Kconfig
@@ -0,0 +1,20 @@
+#
+# SEEKWAVE Platfrom Device Drivers (NEW )Configuration
+#
+config SKW_BSP_UCOM
+	tristate "SeekWave BSP Drivers util For SeekWave Chip"
+	depends on SEEKWAVE_BSP_DRIVERS_V20
+	default m
+	help
+	  This is support seekwave chip for incard board.
+	  if you want to buildin bsp driver.
+	  please say "y".
+		Thanks.
+config SKW_BSP_BOOT
+	tristate "Seekwave Platform SKW BOOT Driver Support"
+        depends on SEEKWAVE_BSP_DRIVERS_V20
+	default m
+	help
+	  Enable this module for seekwave.
+	  if you want to use this driver,please insmod skw_boot.ko.
+	  Thanks.
diff --git a/drivers/misc/seekwaveplatform_v20/skwutil/README.md b/drivers/misc/seekwaveplatform_v20/skwutil/README.md
new file mode 100755
index 000000000000..a0a46100b2de
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/skwutil/README.md
@@ -0,0 +1 @@
+#seekwave platform the skwutil demo
diff --git a/drivers/misc/seekwaveplatform_v20/skwutil/boot_config.h b/drivers/misc/seekwaveplatform_v20/skwutil/boot_config.h
new file mode 100755
index 000000000000..bf62f21648a5
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/skwutil/boot_config.h
@@ -0,0 +1,86 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2020-2030  Seekwave Corporation.
+ *
+ *****************************************************************************/
+#ifndef __BOOT_CONFIG_H__
+#define __BOOT_CONFIG_H__
+#include <linux/types.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include "skw_boot.h"
+
+#define  MODEM_ENABLE_GPIO   	-1
+#define  HOST_WAKEUP_GPIO_IN 	-1
+#define  MODEM_WAKEUP_GPIO_OUT  -1
+//#define CONFIG_NO_GKI
+#define CONFIG_SKW_MSI_AS_LEGACY
+//#define CONFIG_SKW_HOST_SUPPORT_SDMA
+
+//#define CONFIG_SEEKWAVE_FIRMWARE_LOAD
+#define  SKW_IRAM_FILE_PATH  "/data/ROM_EXEC_KERNEL_IRAM.bin"
+#define  SKW_DRAM_FILE_PATH  "/data/RAM_RW_KERNEL_DRAM.bin"
+#define  SEEKWAVE_NV_NAME   "/data/SEEKWAVE_NV_SWT6652.bin"
+//#define  STR_MODE_REINITBUS  1
+
+#if defined(CONFIG_SKW_HOST_SUPPORT_SDMA)
+#define TX_DMA_TYPE		TX_SDMA
+#else
+#define TX_DMA_TYPE		TX_ADMA
+#endif
+
+#if defined(CONFIG_SKW_HOST_PLATFORM_AMLOGIC)
+extern void extern_wifi_set_enable(int is_on);
+#elif defined(CONFIG_SKW_HOST_PLATFORM_ALLWINER)
+extern void sunxi_wlan_set_power(int on);
+#elif defined(CONFIG_SKW_HOST_PLATFORM_ROCKCHIP)
+extern int rockchip_wifi_power(int on);
+#else
+static inline int skw_chip_power_ops(int on){
+    if(on){
+		printk("skw self controll chip power on !!\n");
+    }else{
+		printk("skw self controll chip power down !!\n");
+    }
+	return 0;
+}
+#endif
+
+static inline void skw_chip_set_power(int on)
+{
+#if defined(CONFIG_SKW_HOST_PLATFORM_AMLOGIC)
+	extern_wifi_set_enable(on);
+#elif defined(CONFIG_SKW_HOST_PLATFORM_ALLWINER)
+	sunxi_wlan_set_power(on);
+#elif defined(CONFIG_SKW_HOST_PLATFORM_ROCKCHIP)
+	rockchip_wifi_power(on);
+#else
+	skw_chip_power_ops(on);
+#endif
+
+}
+static inline void skw_chip_power_reset(void)
+{
+#if defined(CONFIG_SKW_HOST_PLATFORM_AMLOGIC)
+	printk("amlogic skw chip power reset !!\n");
+	extern_wifi_set_enable(0);
+	msleep(50);
+	extern_wifi_set_enable(1);
+#elif defined(CONFIG_SKW_HOST_PLATFORM_ALLWINER)
+	printk("allwinner skw chip power reset !!\n");
+	sunxi_wlan_set_power(0);
+	msleep(50);
+	sunxi_wlan_set_power(1);
+#elif defined(CONFIG_SKW_HOST_PLATFORM_ROCKCHIP)
+	printk("rockchip skw chip power reset !!\n");
+	rockchip_wifi_power(0);
+	msleep(50);
+	rockchip_wifi_power(1);
+#else
+	printk("self skw chip power reset !!\n");
+	skw_chip_power_ops(0);
+	msleep(50);
+	skw_chip_power_ops(1);
+#endif
+}
+#endif /* __BOOT_CONFIG_H__ */
diff --git a/drivers/misc/seekwaveplatform_v20/skwutil/skw_boot.c b/drivers/misc/seekwaveplatform_v20/skwutil/skw_boot.c
new file mode 100755
index 000000000000..68660ab4be7a
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/skwutil/skw_boot.c
@@ -0,0 +1,1150 @@
+/*****************************************************************
+ *Copyright (C) 2021 Seekwave Tech Inc.
+ *Filename : skw_boot.c
+ *Authors:seekwave platform
+ *
+ * This software is licensed under the terms of the the GNU
+ * General Public License version 2, as published by the Free
+ * Software Foundation, and may be copied, distributed, and
+ * modified under those terms.
+ *
+ * This program is distributed in the hope that it will be usefull,
+ * but without any warranty;without even the implied warranty of
+ * merchantability or fitness for a partcular purpose. See the
+ * GUN General Public License for more details.
+ * **************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/of_gpio.h>
+#include <linux/completion.h>
+#include <linux/moduleparam.h>
+#include <linux/workqueue.h>
+#include <linux/of.h>
+#include <linux/device.h>
+#include <linux/version.h>
+#include <linux/debugfs.h>
+#include <linux/fs.h>
+#include <linux/ctype.h>
+#include <linux/errno.h>
+#include <linux/firmware.h>
+#include <linux/mmc/sdio_func.h>
+#include <linux/dma-mapping.h>
+#include <linux/cdev.h>
+#include <linux/uaccess.h>
+#include <linux/workqueue.h>
+#include <linux/scatterlist.h>
+#include <linux/platform_device.h>
+#include "skw_mem_map.h"
+#include "skw_boot.h"
+#include "boot_config.h"
+/**************************sdio boot start******************************/
+/*
+ *add the little endian
+ * */
+#define _LITTLE_ENDIAN  1
+
+#define CP_IMG_HEAD0	"kees"		 //"6B656573"
+#define CP_IMG_HEAD1	"0616"		//"30363136"
+#define CP_IMG_TAIL0	"evaw"		//"65766177"
+#define CP_IMG_TAIL1	"0616"		//"30363136" //ASCII code 36 31 36 30
+#define CP_NV_HEAD	  "TSVN"		//"5453564E" //ASCII code 36 31 36 30
+#define CP_NV_TAIL		 "DEVN"		//"4445564E" //ASCII code 36 31 36 30
+
+#define IMG_HEAD_OPS_LEN	4
+#define RAM_ADDR_OPS_LEN	8
+#define MODULE_INFO_LEN		12
+#define IMG_HEAD_INFOR_RANGE	0x200  //10K Byte
+
+extern int cp_exception_sts;
+int test_debug = 0;
+module_param(test_debug, int, S_IRUGO);
+unsigned char dl_signal_acount=0;
+struct platform_device *btboot_pdev;
+static u64 port_dmamask = DMA_BIT_MASK(32);
+static struct mutex boot_mutex;
+
+//#define SDIO_BUFFER_SIZE	 (16*1024)
+enum skw_sub_sys {
+	SKW_BSP =1,
+	SKW_WIFI,
+	SKW_BLUETOOTH,
+	SKW_ALL,
+};
+
+static unsigned int EndianConv_32(unsigned int value);
+/***********sdio drv extern interface **************/
+/* driect mode,reg access.etc */
+//extern int skw_get_chipid(char *chip_id);
+extern int skw_boot_loader(struct seekwave_device *boot_data);
+extern void *skw_get_bus_dev(void);
+extern int skw_reset_bus_dev(void);
+static int skw_first_boot(struct seekwave_device *boot_data);
+static int skw_boot_init(struct seekwave_device *boot_data);
+static int skw_download_signal_ops(void);
+static int get_sleep_status(int portno, char *buffer, int size);
+static int set_sleep_status(int portno, char *buffer, int size);
+static int skw_start_bt_service(void);
+static int skw_stop_bt_service(void);
+/**************************sdio boot end********************************/
+
+struct seekwave_device *boot_data;
+/***************************************************************************
+ *Description:
+ *Seekwave tech LTD
+ *Author:
+ *Date:
+ *Modify:
+ **************************************************************************/
+#if !defined(CONFIG_SEEKWAVE_FIRMWARE_LOAD)
+static unsigned int crc_16_l_calc(char *buf_ptr,unsigned int len)
+{
+	unsigned int i;
+	unsigned short crc=0;
+
+	while(len--!=0)
+	{
+		for(i= CRC_16_L_SEED;i!=0;i=i>>1)
+		{
+			if((crc &CRC_16_L_POLYNOMIAL)!=0)
+			{
+				crc= crc<<1;
+				crc= crc ^ CRC_16_POLYNOMIAL;
+			}else{
+				crc = crc <<1;
+			}
+
+			if((*buf_ptr &i)!=0)
+			{
+				crc = crc ^ CRC_16_POLYNOMIAL;
+			}
+		}
+		buf_ptr++;
+	}
+	return (crc);
+}
+static int skw_request_firmwares(struct seekwave_device *boot_data,
+	const char *dram_image_name, const char *iram_image_name, const char *nv_mem_name)
+{
+	int ret;
+	const struct firmware *fw;
+
+	skwboot_log("firmware: %s %s \n", dram_image_name, iram_image_name);
+	ret = request_firmware(&fw, dram_image_name, NULL);
+	if (ret) {
+		pr_err("request_firmware %s fail\n", dram_image_name);
+		goto ret;
+	}
+
+	if (fw->size <= 0) {
+		ret = -EINVAL;
+		goto relese_fw;
+	}
+
+	boot_data->dram_img_data = (char *)kzalloc(fw->size, GFP_KERNEL);
+	if (boot_data->dram_img_data == NULL) {
+		pr_err("alloc dram memory failed\n");
+		ret = -ENOMEM;
+		goto relese_fw;
+	}
+	skwboot_log("boot data dram_img_data %p\n",boot_data->dram_img_data);
+	memcpy(boot_data->dram_img_data, fw->data, fw->size);
+	boot_data->dram_dl_size = fw->size;
+	release_firmware(fw);
+	//dram crc16
+	boot_data->dram_crc_en = 1;
+	boot_data->dram_crc_offset=0;
+	boot_data->dram_crc_val = crc_16_l_calc(boot_data->dram_img_data + boot_data->dram_crc_offset, boot_data->dram_dl_size);
+
+	ret = request_firmware(&fw, iram_image_name, NULL);
+	if (ret) {
+		pr_err("request_firmware %s fail ret %d\n", iram_image_name, ret);
+		if (fw == NULL) {
+			kfree(boot_data->dram_img_data);
+			boot_data->dram_img_data = NULL;
+			boot_data->dram_dl_size = 0;
+			return ret;
+		}
+	}
+
+	if (fw->size <= 0) {
+		ret = -EINVAL;
+		goto relese_fw;
+	}
+
+	boot_data->iram_img_data = (char *)kzalloc(fw->size, GFP_KERNEL);
+	if (boot_data->iram_img_data == NULL) {
+		pr_err("alloc iram memory failed\n");
+		ret = -ENOMEM;
+		goto relese_fw;
+	}
+	memcpy(boot_data->iram_img_data, fw->data, fw->size);
+	boot_data->iram_dl_size = fw->size;
+	release_firmware(fw);
+	ret = 0;
+	//iram crc16
+	boot_data->iram_crc_en = 1;
+	boot_data->iram_crc_offset=0;
+	boot_data->iram_crc_val = crc_16_l_calc(boot_data->iram_img_data + boot_data->iram_crc_offset, boot_data->iram_dl_size);
+
+	skwboot_log("boot data iram_img_data %p\n",boot_data->iram_img_data);
+
+	ret = request_firmware(&fw, nv_mem_name, NULL);
+	if (ret) {
+		skwboot_err("request_firmware %s fail\n", nv_mem_name);
+		ret = 0;
+		goto ret;
+	}
+
+	boot_data->nv_mem_data = (char *)kzalloc(fw->size, GFP_KERNEL);
+	if (boot_data->nv_mem_data == NULL) {
+		skwboot_err("alloc nv memory failed\n");
+		goto relese_fw;
+	}
+	memcpy(boot_data->nv_mem_data, fw->data, fw->size);
+	boot_data->nv_mem_size = fw->size;
+	ret=0;
+	boot_data->nvmem_crc_en = 1;
+	boot_data->nvmem_crc_offset=0;
+	boot_data->nvmem_crc_val = crc_16_l_calc(boot_data->nv_mem_data + boot_data->nvmem_crc_offset, boot_data->nv_mem_size);
+
+relese_fw:
+	release_firmware(fw);
+ret:
+	return ret;
+}
+#endif
+
+static int seekwave_boot_parse_dt(struct platform_device *pdev, struct seekwave_device *boot_data)
+{
+	int ret = 0;
+	enum of_gpio_flags flags;
+	struct device_node *np = pdev->dev.of_node;
+	/*add the dma type dts config*/
+	if (of_property_read_u32(np, "bt_antenna", &(boot_data->bt_antenna))){
+		skwboot_warn("no BT_antenna setting\n");
+		boot_data->bt_antenna = 0;
+	} else
+		skwboot_log("BT_antenna setting: %d\n", boot_data->bt_antenna);
+
+	if (of_property_read_u32(np, "dma_type", &(boot_data->dma_type))){
+		boot_data->dma_type = ADMA;
+		boot_data->chip_en = MODEM_ENABLE_GPIO; 
+		boot_data->host_gpio =  HOST_WAKEUP_GPIO_IN;
+		boot_data->chip_gpio =  MODEM_WAKEUP_GPIO_OUT;
+		boot_data->skw_nv_name =  SEEKWAVE_NV_NAME;
+		boot_data->iram_file_path =  SKW_IRAM_FILE_PATH;
+		boot_data->dram_file_path =  SKW_DRAM_FILE_PATH;
+
+		skwboot_warn("no DTS setting\n");
+	} else {
+        /*-add the iram img file path dts-*/
+        ret = of_property_read_string(np, "skw_iram_path",(const char **)&(boot_data->iram_file_path));
+        if(ret < 0){
+            skwboot_err("%s:iram path fail ret=%d\n", __func__, ret);
+        }
+        /*-add the dram img file path dts-*/
+        ret = of_property_read_string(np, "skw_dram_path",(const char **)&(boot_data->dram_file_path));
+        if(ret < 0){
+            skwboot_err("%s: dram path fail ret=%d\n",__func__,ret);
+        }
+
+        boot_data->host_gpio = of_get_named_gpio_flags(np, "gpio_host_wake", 0, &flags);
+		boot_data->chip_gpio = of_get_named_gpio_flags(np, "gpio_chip_wake",0, &flags);
+		boot_data->chip_en = of_get_named_gpio_flags(np, "gpio_chip_en",0, &flags);
+		ret = of_property_read_string(np, "seekwave_nv_name",(const char **)&(boot_data->skw_nv_name));
+		if(ret < 0){
+			skwboot_err("%s:nv name get fail ret=%d\n",__func__, ret);
+		}
+	}
+	if (boot_data->host_gpio >= 0) {
+		ret = devm_gpio_request_one(&pdev->dev, boot_data->host_gpio, GPIOF_IN, "HOST_WAKE" );
+		if(ret < 0){
+			gpio_free(boot_data->host_gpio);
+			devm_gpio_request_one(&pdev->dev, boot_data->host_gpio, GPIOF_IN, "HOST_WAKE" );
+		}
+		if (boot_data->chip_gpio >= 0) {
+			ret = devm_gpio_request_one(&pdev->dev, boot_data->chip_gpio, GPIOF_OUT_INIT_HIGH,"CHIP_WAKE");
+			if (ret < 0)
+				skwboot_err("%s:gpio_chip request fail ret=%d\n",__func__, ret);
+			else
+				gpio_set_value(boot_data->host_gpio, 1);
+
+		}
+	}
+
+	if(test_debug==1){//test debug inband irq and nosleep en
+		boot_data->chip_gpio= -1;
+		boot_data->host_gpio= -1;
+	}
+	if(boot_data->chip_gpio >= 0 && boot_data->host_gpio >=0){
+		boot_data->slp_disable = 0;
+	}else{
+		boot_data->slp_disable = 1;
+	}
+	if (boot_data->chip_en >= 0)
+		ret = devm_gpio_request_one(&pdev->dev, boot_data->chip_en, GPIOF_OUT_INIT_HIGH,"CHIP_EN");
+
+	skwboot_log("%s, chipen:%d gpio_out:%d gpio_in:%d ret=%d\n", __func__,boot_data->chip_en,
+		boot_data->chip_gpio,boot_data->host_gpio, ret);
+
+	return ret;
+}
+
+/************************************************************************/
+//Description: BT start service
+//Func: BT start service
+//Call
+//Author:junwei.jiang
+//Date:2021-110
+//Modify:
+/************************************************************************/
+static int bt_start_service(int id, void *callback, void *data)
+{
+	int ret=0;
+	if(cp_exception_sts)
+		return -1;
+
+	ret = skw_start_bt_service();
+	if(ret < 0){
+		skwboot_err("%s boot bt fail \n", __func__);
+		return -1;
+	}
+	skwboot_log("%s line:%d  boot sucessfuly\n", __func__, __LINE__);
+	return 0;
+}
+
+/************************************************************************/
+//Description: BT stop service
+//Func: BT stop service
+//Call
+//Author:junwei.jiang
+//Date:2021-11-1
+//Modify:
+/************************************************************************/
+static int bt_stop_service(int id)
+{
+	int ret=0;
+
+	if(cp_exception_sts)
+		return 0;
+
+	ret = skw_stop_bt_service();
+	if(ret < 0){
+		skwboot_err("%s boot bt fail \n", __func__);
+		return -1;
+	}
+	skwboot_log("bt_stop_service OK\n");
+	return 0;
+}
+
+/****************************************************************
+ *Description:iram read the double img file
+ *Func:
+ *Calls:
+ *Call By:sdio_dloader
+ *Input:the file path
+ *Output:download data and the data size dl_data image_size
+ *Return0:pass other fail
+ *Others:
+ *AuthorJUNWEI.JIANG
+ *Date:2022-02-07
+ * **************************************************************/
+#if defined(CONFIG_SEEKWAVE_FIRMWARE_LOAD)
+static int skw_iram_img_read(struct seekwave_device *boot_data)
+{
+	struct file *filep=NULL ;
+
+	mm_segment_t old_fs;
+	int err = 0;
+
+	if(!boot_data->iram_file_path){
+		skwboot_err("iram_file_path NULL!!\n");
+		return -1;
+	}
+
+
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+	filep = filp_open(boot_data->iram_file_path, O_RDONLY, 0);
+	if (IS_ERR(filep)) {
+		skwboot_err("%s: Failed to open the file %s\n", __func__, boot_data->iram_file_path);
+		filep = filp_open(boot_data->iram_file_path, O_RDONLY, 0664);
+		if (IS_ERR(filep)) {
+			err = PTR_ERR(filep);
+			skwboot_err("open file error, err = %d\n", err);
+			goto fail;
+		}
+		skwboot_log("file bin path = %s\n", boot_data->iram_file_path);
+	}
+#if  LINUX_VERSION_CODE <= KERNEL_VERSION(4, 10, 0)
+	struct kstat stat;
+	err = vfs_stat(boot_data->iram_file_path, &stat);
+	if (err) {
+		skwboot_err("%s:%s vfs_stat fail !\n", __func__,boot_data->iram_file_path);
+		goto fail;
+	}
+	boot_data->iram_dl_size = (int)stat.size;
+	if (boot_data->iram_dl_size == 0) {
+		skwboot_err("%s:iram dl size fail ! imgsize=0x%x\n", __func__,
+				boot_data->iram_dl_size);
+		goto fail;
+	}
+#else
+	boot_data->iram_dl_size = filep->f_inode->i_size;
+	if (boot_data->iram_dl_size == 0) {
+		skwboot_err("%s:iram dl size fail ! imgsize=0x%x\n", __func__,
+				boot_data->iram_dl_size);
+		goto fail;
+	}
+	skwboot_log("file bin iram_dl_size = %d \n", boot_data->iram_dl_size);
+#endif
+
+	boot_data->iram_img_data = (char *)kzalloc(boot_data->iram_dl_size, GFP_KERNEL);
+	if (boot_data->iram_img_data == NULL) {
+		goto fail1;
+	}
+	if (skw_read_file(filep, boot_data->iram_img_data,boot_data->iram_dl_size, &filep->f_pos) != boot_data->iram_dl_size) {
+		goto fail1;
+	}
+#if 0 //DEBUG
+	print_hex_dump(KERN_ERR, "img data ", 0, 16, 1,
+			boot_data->img_data, boot_data->img_size, 1);
+#endif
+	set_fs(old_fs);
+	filp_close(filep, NULL);
+	return 0;
+fail:
+	if (!IS_ERR(filep) && filep != NULL) {
+		filp_close(filep, NULL);
+		skwboot_err("%s: analysis the done - '%s' \n",__func__, boot_data->iram_file_path);
+	}
+	set_fs(old_fs);
+	return -3;
+fail1:
+	if (!IS_ERR(filep)){
+		filp_close(filep, NULL);
+	}
+	set_fs(old_fs);
+	return -1;
+}
+#endif
+/****************************************************************
+ *Description:dram read the double img file
+ *Func:
+ *Calls:
+ *Call By:sdio_dloader
+ *Input:the file path
+ *Output:download data and the data size dl_data image_size
+ *Return0:pass other fail
+ *Others:
+ *AuthorJUNWEI.JIANG
+ *Date:2022-02-07
+ * **************************************************************/
+#if defined(CONFIG_SEEKWAVE_FIRMWARE_LOAD)
+static int skw_dram_img_read(struct seekwave_device *boot_data)
+{
+	struct file *filep=NULL ;
+	mm_segment_t old_fs;
+	int error = 0;
+
+	if(!boot_data->dram_file_path){
+		skwboot_err("dram_file_path NULL!!\n");
+		return -1;
+	}
+
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+
+	filep = filp_open(boot_data->dram_file_path, O_RDONLY, 0);
+	if (IS_ERR(filep)) {
+		skwboot_err("%s: Failed to open the file %s\n", __func__, boot_data->dram_file_path);
+		filep = filp_open(boot_data->dram_file_path, O_RDONLY, 0664);
+		if (IS_ERR(filep)) {
+			error = PTR_ERR(filep);
+			skwboot_err("open file error, err = %d\n", error);
+			goto fail;
+		}
+		skwboot_log("file bin path = %s\n", boot_data->dram_file_path);
+	}
+#if  LINUX_VERSION_CODE <= KERNEL_VERSION(4, 10, 0)
+	struct kstat stat;
+	error = vfs_stat(boot_data->dram_file_path, &stat);
+	if (error) {
+		skwboot_err("%s: get the img size fail the vfs_stat fail -- %s \n", __func__,boot_data->dram_file_path);
+		goto fail;
+	}
+	boot_data->dram_dl_size = (int)stat.size;
+	if (boot_data->dram_dl_size == 0) {
+		skwboot_err("%s:dram dl size fail ! imgsize=0x%x\n", __func__,
+				boot_data->dram_dl_size);
+		goto fail;
+	}
+#else
+	boot_data->dram_dl_size = filep->f_inode->i_size;
+	if (boot_data->dram_dl_size == 0) {
+		skwboot_err("%s:iram dl size fail ! imgsize=0x%x\n", __func__,
+				boot_data->dram_dl_size);
+		goto fail;
+	}
+#endif
+	skwboot_log("file bin dram_dl_size = %d \n", boot_data->dram_dl_size);
+	boot_data->dram_img_data = (char *)kzalloc(boot_data->dram_dl_size, GFP_KERNEL);
+	if (boot_data->dram_img_data == NULL) {
+		goto fail1;
+	}
+	if (skw_read_file(filep, boot_data->dram_img_data,boot_data->dram_dl_size, &filep->f_pos) != boot_data->dram_dl_size) {
+		goto fail1;
+	}
+#if 0 //DEBUG
+	print_hex_dump(KERN_ERR, "img data ", 0, 16, 1,
+			boot_data->img_data, boot_data->img_size, 1);
+#endif
+	set_fs(old_fs);
+	filp_close(filep, NULL);
+	return 0;
+fail:
+	if (!IS_ERR(filep) && filep != NULL) {
+		filp_close(filep, NULL);
+		skwboot_err("%s: analysis the done - '%s' \n",__func__, boot_data->dram_file_path);
+	}
+	set_fs(old_fs);
+	return -3;
+fail1:
+	if (!IS_ERR(filep)){
+		filp_close(filep, NULL);
+	}
+	set_fs(old_fs);
+	return -1;
+}
+#endif
+
+/***************************************************************************
+ *Description:
+ *Seekwave tech LTD
+ *Author:
+ *Date:
+ *Modify:
+ **************************************************************************/
+static int seekwave_boot_probe(struct  platform_device *pdev)
+{
+	int ret;
+	int time_count=0;
+	struct device *io_bus=NULL;
+
+	boot_data = devm_kzalloc(&pdev->dev, sizeof(struct seekwave_device), GFP_KERNEL);
+	if (!boot_data) {
+		skwboot_err("%s :kzalloc error !\n", __func__);
+		return -ENOMEM;
+	}
+	mutex_init(&boot_mutex);
+	seekwave_boot_parse_dt(pdev, boot_data);
+	io_bus = skw_get_bus_dev();
+	if (!io_bus &&(boot_data->chip_en >= 0)) {
+		skwboot_log("%s :CHIP_RESET AGAIN!\n", __func__);
+		gpio_set_value(boot_data->chip_en,0);
+		msleep(20);
+		gpio_set_value(boot_data->chip_en, 1);
+		do {
+			msleep(10);
+			io_bus = skw_get_bus_dev();
+		} while(!io_bus && time_count++ < 5);
+	}
+	if (!io_bus) {
+		skwboot_err("%s get bus dev fail !\n",__func__);
+		return -ENODEV;
+	}
+	if (!strncmp(io_bus->bus->name, "usb", 3)) {
+		boot_data->iram_file_path = "SWT6652_IRAM_USB.bin";
+		boot_data->dram_file_path = "SWT6652_DRAM_USB.bin";
+	} else if (!strncmp(io_bus->bus->name, "pci", 3)) {
+		boot_data->iram_file_path = "SWT6652_IRAM_PCIE.bin";
+		boot_data->dram_file_path = "SWT6652_DRAM_PCIE.bin";
+	} else {
+		boot_data->iram_file_path = "SWT6652_IRAM_SDIO.bin";
+		boot_data->dram_file_path = "SWT6652_DRAM_SDIO.bin";
+	}
+	skw_boot_init(boot_data);
+#ifdef STR_MODE_REINITBUS
+	boot_data->pdev = pdev;
+#endif
+	ret = skw_first_boot(boot_data);
+	printk("%s bus-name=%s\n", __func__, io_bus->bus->name);
+	if (strncmp(io_bus->bus->name, "usb", 3))
+		skw_bind_boot_driver(io_bus);
+	return ret;
+}
+/***************************************************************************
+ *Description:
+ *Seekwave tech LTD
+ *Author:
+ *Date:
+ *Modify:
+ **************************************************************************/
+static int seekwave_boot_remove(struct  platform_device *pdev)
+{
+	skwboot_log("%s the Enter \n", __func__);
+
+	if (btboot_pdev) {
+		platform_device_unregister(btboot_pdev);
+		btboot_pdev = NULL;
+	}
+	if(boot_data){
+		if(boot_data->iram_img_data){
+			kfree(boot_data->iram_img_data);
+			boot_data->iram_img_data = NULL;
+		}
+		if(boot_data->dram_img_data){
+			kfree(boot_data->dram_img_data);
+			boot_data->dram_img_data = NULL;
+		}
+		if(boot_data->dl_bin){
+			kfree(boot_data->dl_bin);
+			boot_data->dl_bin = NULL;
+		}
+		if(boot_data->img_data){
+			kfree(boot_data->img_data);
+			boot_data->img_data = NULL;
+		}
+		boot_data->iram_file_path = NULL;
+		boot_data->dram_file_path = NULL;
+		devm_kfree(&pdev->dev, boot_data);
+		boot_data=NULL;
+	}
+	mutex_destroy(&boot_mutex);
+	return 0;
+}
+extern void skw_modem_log_stop_rec(void);
+static void seekwave_boot_shutdown(struct platform_device *pdev)
+{
+	printk("%s enter ...\n", __func__);
+	skw_modem_log_stop_rec();
+	skw_reset_bus_dev();
+}
+static const struct of_device_id seekwave_match_table[] ={
+
+	{ .compatible = "seekwave,sv6160"},
+	{ },
+};
+
+static struct platform_driver seekwave_driver ={
+
+	.driver = {
+		.owner = THIS_MODULE,
+		.name  = "sv6160",
+		.of_match_table = seekwave_match_table,
+	},
+	.probe = seekwave_boot_probe,
+	.remove = seekwave_boot_remove,
+	.shutdown = seekwave_boot_shutdown,
+};
+
+/***********************************************************************
+ *Description:BT download boot pdata
+ *Seekwave tech LTD
+ *Author:junwei.jiang
+ *Date:2021-11-3
+ *Modify:
+ ***********************************************************************/
+static int get_sleep_status(int portno, char *buffer, int size)
+{
+	memcpy(buffer, "WAKE", 4);
+	if (boot_data->host_gpio >=0) {
+		if (gpio_get_value(boot_data->host_gpio) == 0)
+			memcpy(buffer, "DOWN", 4);
+	}
+	return 4;
+}
+static int set_sleep_status(int portno, char *buffer, int size)
+{
+	int i, count;
+
+	for(i=0; i<2; i++) {
+		if (gpio_get_value(boot_data->host_gpio))
+			return 1;
+		if(buffer && !strncmp(buffer, "WAKE", 4)) {
+			gpio_set_value(boot_data->chip_gpio, 0);
+			udelay(10);
+			gpio_set_value(boot_data->chip_gpio, 1);
+		}
+		count = 0;
+		do {
+			if (count++ < 100)
+				udelay(20);
+		} while(gpio_get_value(boot_data->host_gpio) ==0);
+		if (gpio_get_value(boot_data->host_gpio))
+			return 1;
+		udelay(100);
+	}
+	if (gpio_get_value(boot_data->host_gpio)==0)
+		skwboot_log("wakeup CHIP timeout!!! \n");
+	return 1;
+}
+struct sv6160_platform_data boot_pdata = {
+	.data_port = 8,
+	.bus_type = SDIO_LINK,
+	.max_buffer_size = 0x800,
+	.align_value = 4,
+	.hw_sdma_rx = get_sleep_status,
+	.hw_sdma_tx = set_sleep_status,
+	.open_port = bt_start_service,
+	.close_port = bt_stop_service,
+};
+
+/***************************************************************
+ *Description:BT bind boot driver
+ *Seekwave tech LTD
+ *Author:junwei.jiang
+ *Date:2021-11-3
+ *Modify:
+***************************************************************/
+int skw_bind_boot_driver(struct device *dev)
+{
+	struct platform_device *pdev;
+	char	pdev_name[32];
+	int ret = 0;
+	sprintf(pdev_name, "skw_ucom");
+	if(!dev){
+		skwboot_err("%s the dev fail \n", __func__);
+		return -1;
+	}
+	if(btboot_pdev)
+		return ret;
+	pdev = platform_device_alloc(pdev_name, PLATFORM_DEVID_AUTO);
+	if(!pdev)
+		return -ENOMEM;
+	pdev->dev.parent = dev;
+	pdev->dev.dma_mask = &port_dmamask;
+	pdev->dev.coherent_dma_mask = port_dmamask;
+	boot_pdata.port_name = "BTBOOT";
+	boot_pdata.data_port = 8;
+	ret = platform_device_add_data(pdev, &boot_pdata, sizeof(boot_pdata));
+	if(ret) {
+		dev_err(dev, "failed to add boot data \n");
+		platform_device_put(pdev);
+		return ret;
+	}
+	ret = platform_device_add(pdev);
+	if(ret) {
+		platform_device_put(pdev);
+		skwboot_err("%s,line:%d the device add fail \n",__func__,__LINE__);
+		return ret;
+	}
+	btboot_pdev = pdev;
+	return ret;
+}
+#ifndef CONFIG_OF
+static void seekwave_release(struct device *dev)
+{
+}
+static struct platform_device seekwave_device ={
+	.name = "sv6160",
+	.dev = {
+		.release = seekwave_release,
+	}
+};
+#endif
+int seekwave_boot_init(void)
+{
+	btboot_pdev = NULL;
+#ifndef CONFIG_OF
+	platform_device_register(&seekwave_device);
+#endif
+	platform_driver_register(&seekwave_driver);
+	return skw_ucom_init();
+}
+
+void seekwave_boot_exit(void)
+{
+	skw_ucom_exit();
+#ifndef CONFIG_OF
+	platform_device_unregister(&seekwave_device);
+#endif
+	platform_driver_unregister(&seekwave_driver);
+
+}
+
+/****************************************************************
+ *Description:the data Little Endian process interface
+ *Func:EndianConv_32
+ *Calls:None
+ *Call By:The img data process
+ *Input:value
+ *Output:the Endian data
+ *Returnvalue
+ *Others:
+ *AuthorJUNWEI.JIANG
+ *Date:2021-08-26
+ * **************************************************************/
+static unsigned int EndianConv_32(unsigned int value)
+{
+#ifdef _LITTLE_ENDIAN
+	unsigned int nTmp = (value >>24 | value <<24);
+	nTmp |= ((value >> 8) & 0x0000FF00);
+	nTmp |= ((value << 8) & 0x00FF0000);
+	return nTmp;
+#else
+	return value;
+#endif
+}
+
+/****************************************************************
+ *Description:dram read the double img file
+ *Func:
+ *Calls:
+ *Call By:
+ *Input:the file path
+ *Output:download data and the data size dl_data image_size
+ *Return0:pass other fail
+ *Others:
+ *AuthorJUNWEI.JIANG
+ *Date:2022-02-07
+ * **************************************************************/
+static int skw_download_signal_ops(void)
+{
+	unsigned int tmp_signal = 0;
+	//download done flag ++
+	boot_data->dl_done_signal ++;
+	tmp_signal = boot_data->dl_done_signal;
+	boot_data->dl_done_signal = 0xff&tmp_signal;
+	boot_data->dl_acount_addr = SKW_SDIO_PD_DL_AP2CP_BSP;
+
+	//gpio need set high or low power interrupt to cp wakeup
+	boot_data->gpio_out = boot_data->chip_gpio;
+	if(boot_data->gpio_val)
+		boot_data->gpio_val =0;
+	else
+		boot_data->gpio_val =1;
+	skwboot_log("%s line:%d download data ops done the dl_count=%d \n", __func__, __LINE__,boot_data->dl_done_signal);
+	return 0;
+}
+
+/****************************************************************
+ *Description:analysis the double img dram iram
+ *Func:
+ *Calls:
+ *Call By:
+ *Input:the file path
+ *Output:download data and the data size dl_data image_size
+ *Return0:pass other fail
+ *Others:
+ *AuthorJUNWEI.JIANG
+ *Date:2022-02-07
+ * **************************************************************/
+static int skw_boot_init(struct seekwave_device *boot_data)
+{
+	int i =0;
+	int k =0;
+	unsigned int head_offset=0;
+	unsigned int tail_offset=0;
+	int ret = 0;
+	struct img_head_data_t dl_data_info;
+	unsigned int *data=NULL;
+	unsigned int *nvdata=NULL;
+	unsigned int *dl_addr_data=NULL;
+#if defined(CONFIG_SEEKWAVE_FIRMWARE_LOAD)
+	//read the iram data from file
+	//boot_data->iram_file_path = "/vendor/etc/firmware/ROM_EXEC_KERNEL_IRAM.bin";
+	ret = skw_iram_img_read(boot_data);
+	if(ret !=0){
+		skwboot_err("%s:read iram file fail \n", __func__);
+		//return -1;
+		boot_data->iram_img_data = NULL;
+		boot_data->iram_dl_size = 0;
+	}
+	//read the dram data from file
+	//boot_data->dram_file_path = "/vendor/etc/firmware/RAM_RW_KERNEL_DRAM.bin";
+	ret = skw_dram_img_read(boot_data);
+	if(ret !=0){
+		skwboot_err("%s:read dram file fail \n", __func__);
+		boot_data->dram_img_data = NULL;
+		boot_data->dram_dl_size = 0;
+	}
+#else
+	ret = skw_request_firmwares(boot_data, boot_data->dram_file_path,
+		       	boot_data->iram_file_path, boot_data->skw_nv_name);
+	if (ret < 0) {
+		ret = skw_request_firmwares(boot_data, "RAM_RW_KERNEL_DRAM.bin",
+			       	"ROM_EXEC_KERNEL_IRAM.bin",boot_data->skw_nv_name);
+		if (ret < 0){
+			return ret;
+		}
+	}
+	skwboot_log("image_size=%d,%d, ret=%d\n", boot_data->iram_dl_size, boot_data->dram_dl_size, ret);
+#endif
+	boot_data->head_addr = 0;
+	boot_data->tail_addr = 0;
+	boot_data->bsp_head_addr = 0;
+	boot_data->bsp_tail_addr = 0;
+	boot_data->wifi_head_addr =0;
+	boot_data->wifi_tail_addr = 0;
+	boot_data->bt_head_addr = 0;
+	boot_data->bt_tail_addr = 0;
+	boot_data->nv_head_addr = 0;
+	boot_data->nv_tail_addr = 0;
+	boot_data->nv_data_size = 0;
+
+	if(boot_data->iram_img_data!=NULL){
+		/*analysis the img*/
+		for(i=0; i*IMG_HEAD_OPS_LEN<IMG_HEAD_INFOR_RANGE; i++)
+		{
+			if(!head_offset)
+			{
+				if((0==memcmp(CP_IMG_HEAD0, boot_data->iram_img_data+i*IMG_HEAD_OPS_LEN,IMG_HEAD_OPS_LEN))&&
+						(0==memcmp(CP_IMG_HEAD1,boot_data->iram_img_data+(i+1)*IMG_HEAD_OPS_LEN,IMG_HEAD_OPS_LEN)))
+					head_offset = (i+1)*IMG_HEAD_OPS_LEN;
+			}else if(!tail_offset){
+				if((0==memcmp(CP_IMG_TAIL0, boot_data->iram_img_data+i*IMG_HEAD_OPS_LEN, IMG_HEAD_OPS_LEN))&&
+						(0==memcmp(CP_IMG_TAIL1, boot_data->iram_img_data+(i+1)*IMG_HEAD_OPS_LEN, IMG_HEAD_OPS_LEN))){
+					tail_offset = (i-1)*IMG_HEAD_OPS_LEN;
+					break;
+				}
+			}
+		}
+
+		/*analysis the nv*/
+		for(k=0; k*IMG_HEAD_OPS_LEN<IMG_HEAD_INFOR_RANGE; k++)
+		{
+			if(!boot_data->nv_head_addr)
+			{
+				if(0==memcmp(CP_NV_HEAD, boot_data->iram_img_data+k*IMG_HEAD_OPS_LEN,IMG_HEAD_OPS_LEN))
+					boot_data->nv_head_addr = k*IMG_HEAD_OPS_LEN;
+			}else if(!boot_data->nv_tail_addr){
+				if((0==memcmp(CP_NV_TAIL, boot_data->iram_img_data+k*IMG_HEAD_OPS_LEN, IMG_HEAD_OPS_LEN))){
+					boot_data->nv_tail_addr = k*IMG_HEAD_OPS_LEN;
+					boot_data->nv_data_size = boot_data->nv_tail_addr - boot_data->nv_head_addr - IMG_HEAD_OPS_LEN;
+					nvdata = (u32 *) &boot_data->iram_img_data[boot_data->nv_head_addr];
+					print_hex_dump(KERN_ERR, "nv data ", 0, 16, 1,nvdata, boot_data->nv_data_size+8, 1);
+					break;
+				}
+			}
+		}
+		if(!tail_offset){
+			skwboot_err("%s,%d,the iram_img not need analysis!!! or Fail!! \n",__func__,__LINE__);
+			return -1;
+		}else{
+			//get the iram img addr and dram img addr
+			dl_addr_data = (unsigned int *)(boot_data->iram_img_data+head_offset+IMG_HEAD_OPS_LEN);
+			boot_data->iram_dl_addr = dl_addr_data[0];
+			boot_data->dram_dl_addr = dl_addr_data[1];
+			head_offset = head_offset+RAM_ADDR_OPS_LEN;//jump the ram addr data;
+
+			skwboot_log("%s line:%d,the tail_offset ---0x%x, the head_offset --0x%x ,iram_addr=0x%x,dram_addr=0x%x, \
+					nv_head_addr:0x%x,nv_tail_addr:0x%x,nv_size=%d\n",__func__, __LINE__,tail_offset, head_offset,
+					boot_data->iram_dl_addr,boot_data->dram_dl_addr,boot_data->nv_head_addr,boot_data->nv_tail_addr,
+					boot_data->nv_data_size);
+		}
+		/*need download the img bin for WIFI or BT service dl_module >0*/
+		head_offset = head_offset +IMG_HEAD_OPS_LEN;
+		/*get the img head tail offset*/
+		boot_data->head_addr = head_offset;
+		boot_data->tail_addr = tail_offset;
+
+		skwboot_log("%s line:%d analysis the img module\n", __func__, __LINE__);
+		for(i=0; i*MODULE_INFO_LEN<=(tail_offset-head_offset); i++)
+		{
+			data = (unsigned int *)(boot_data->iram_img_data +head_offset+i*MODULE_INFO_LEN);
+			dl_data_info.dl_addr=data[0];
+			dl_data_info.write_addr =data[2];
+			dl_data_info.index = 0x000000FF&EndianConv_32(data[1]);
+			dl_data_info.data_size = 0x00FFFFFF&data[1];
+			skwboot_log("%s line:%d dl_addr=0x%x, write_addr=0x%x, index=0x%x,data_size=0x%x\n", __func__,
+					__LINE__, dl_data_info.dl_addr,dl_data_info.write_addr,dl_data_info.index,dl_data_info.data_size);
+
+		}
+		if(boot_data->nv_mem_size && (boot_data->nv_mem_size <= boot_data->nv_data_size)){
+			memcpy((boot_data->iram_img_data+boot_data->nv_head_addr+4),boot_data->nv_mem_data,boot_data->nv_mem_size);
+			kfree(boot_data->nv_mem_data);
+			boot_data->nv_mem_data = NULL;
+		}
+
+	 }
+	 return 0;
+}
+
+/***************************************************************************
+ *Description:
+ *Seekwave tech LTD
+ *Author:
+ *Date:
+ *Modify:
+ **************************************************************************/
+static int skw_start_wifi_service(void)
+{
+	int ret =0;
+
+	skwboot_log("%s Enter cp_state =%d \n",__func__, cp_exception_sts);
+	mutex_lock(&boot_mutex);
+	boot_data->service_ops = SKW_WIFI_START;
+	boot_data->dl_module = SKW_WIFI_BOOT;
+	boot_data->first_dl_flag = 1;
+	//download done flag ++
+	skw_download_signal_ops();
+	ret = skw_boot_loader(boot_data);
+	mutex_unlock(&boot_mutex);
+	if(ret !=0)
+	{
+		skwboot_err("%s,line:%d boot fail \n", __func__,__LINE__);
+		return -1;
+	}
+
+	skwboot_log("%s wifi boot sucessfull\n", __func__);
+	return 0;
+}
+
+/***************************************************************************
+ *Description:
+ *Seekwave tech LTD
+ *Author:
+ *Date:
+ *Modify:
+ **************************************************************************/
+static int skw_stop_wifi_service(void)
+{
+	int ret =0;
+	skwboot_log("%s Enter cp_state =%d \n",__func__, cp_exception_sts);
+	mutex_lock(&boot_mutex);
+	boot_data->service_ops = SKW_WIFI_STOP;
+	boot_data->dl_module = 0;
+	boot_data->first_dl_flag = 1;
+	//download done flag ++
+	//gpio need set high or low power interrupt to cp wakeup
+	boot_data->gpio_out = boot_data->chip_gpio;
+	if(boot_data->gpio_val)
+		boot_data->gpio_val =0;
+	else
+		boot_data->gpio_val =1;
+	ret = skw_boot_loader(boot_data);
+	mutex_unlock(&boot_mutex);
+	if(ret !=0)
+	{
+		skwboot_err("dload the img fail \n");
+		return -1;
+	}
+	skwboot_log("seekwave boot stop done:%s\n",__func__);
+	return 0;
+}
+
+/***************************************************************************
+ *Description:
+ *Seekwave tech LTD
+ *Author:
+ *Date:
+ *Modify:
+ **************************************************************************/
+static int skw_start_bt_service(void)
+{
+	int ret=0;
+	skwboot_log("%s Enter cp_state =%d \n",__func__, cp_exception_sts);
+	mutex_lock(&boot_mutex);
+	boot_data->service_ops = SKW_BT_START;
+	boot_data->first_dl_flag = 1;
+	boot_data->dl_module = SKW_BT_BOOT;
+	//download done flag ++
+	skw_download_signal_ops();
+	ret = skw_boot_loader(boot_data);
+	mutex_unlock(&boot_mutex);
+	if(ret !=0)
+	{
+		skwboot_err("%s boot fail \n", __func__);
+		return -1;
+	}
+	skwboot_log("%s line:%d , boot bt sucessfully!\n", __func__,__LINE__);
+	return 0;
+}
+
+/***************************************************************************
+ *Description:
+ *Seekwave tech LTD
+ *Author:
+ *Date:
+ *Modify:
+ **************************************************************************/
+static int skw_stop_bt_service(void)
+{
+	int ret =0;
+	skwboot_log("%s Enter cp_state =%d \n",__func__, cp_exception_sts);
+	mutex_lock(&boot_mutex);
+	boot_data->service_ops = SKW_BT_STOP;
+	boot_data->first_dl_flag = 1;
+	//download done flag ++
+	boot_data->dl_module = 0;
+	//gpio need set high or low power interrupt to cp wakeup
+	boot_data->gpio_out = boot_data->chip_gpio;
+	if(boot_data->gpio_val)
+		boot_data->gpio_val =0;
+	else
+		boot_data->gpio_val =1;
+	ret = skw_boot_loader(boot_data);
+	mutex_unlock(&boot_mutex);
+	if(ret < 0)
+	{
+		skwboot_err("dload the img fail \n");
+		return -1;
+	}
+	skwboot_log("seekwave boot stop done:%s\n",__func__);
+	return 0;
+}
+
+/****************************************************************
+ *Description:double iram dram img first boot cp
+ *Func:
+ *Calls:
+ *Call By:skw_first_boot
+ *Input:the file path
+ *Output:download data and the data size dl_data image_size
+ *Return0:pass other fail
+ *Others:
+ *AuthorJUNWEI.JIANG
+ *Date:2022-02-07
+ * **************************************************************/
+static int skw_first_boot(struct seekwave_device *boot_data)
+{
+	int ret =0;
+	//get the img data
+#ifdef DEBUG_SKWBOOT_TIME
+	ktime_t cur_time,last_time;
+	cur_time = ktime_get();
+#endif
+	//set download the value;
+	boot_data->service_ops = SKW_NO_SERVICE;
+	boot_data->save_setup_addr = SKW_SDIO_PD_DL_AP2CP_BSP; //160
+	boot_data->gpio_out = boot_data->chip_gpio;
+	boot_data->gpio_val = 0;
+	boot_data->dl_module = 0;
+	boot_data->first_dl_flag =0;
+	boot_data->gpio_in  = boot_data->host_gpio;
+	boot_data->dma_type_addr = SKW_SDIO_PLD_DMA_TYPE;
+	boot_data->slp_disable_addr = SKW_SDIO_CP_SLP_SWITCH;
+	boot_data->wifi_start = skw_start_wifi_service;
+	boot_data->wifi_stop = skw_stop_wifi_service;
+	boot_data->bt_start = skw_start_bt_service;
+	boot_data->bt_stop = skw_stop_bt_service;
+	ret = skw_boot_loader(boot_data);
+	if(ret < 0){
+		skwboot_err("%s firt boot cp fail \n", __func__);
+		return -1;
+	}
+	//download done set the download flag;
+	boot_data->first_dl_flag =1;
+
+	//download done tall cp acount;
+	boot_data->dl_done_signal &= 0xFF;
+	boot_data->dl_done_signal +=1;
+	skwboot_log("%s first boot pass\n", __func__);
+#ifdef DEBUG_SKWBOOT_TIME
+	last_time = ktime_get();
+	skwboot_log("%s,the download time start time %llu and the over time %llu \n",
+			__func__, cur_time, last_time);
+#endif
+	return ret;
+}
+
+//module_init(seekwave_boot_init);
+//module_exit(seekwave_boot_exit);
+//MODULE_LICENSE("GPL");
diff --git a/drivers/misc/seekwaveplatform_v20/skwutil/skw_boot.h b/drivers/misc/seekwaveplatform_v20/skwutil/skw_boot.h
new file mode 100755
index 000000000000..df50d38794d8
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/skwutil/skw_boot.h
@@ -0,0 +1,259 @@
+/*****************************************************************
+ *Copyright (C) 2021 Seekwave Tech Inc.
+ *Filename : skw_sdio.h
+ *Authors:seekwave platform
+ *
+ * This software is licensed under the terms of the the GNU
+ * General Public License version 2, as published by the Free
+ * Software Foundation, and may be copied, distributed, and
+ * modified under those terms.
+ *
+ * This program is distributed in the hope that it will be usefull,
+ * but without any warranty;without even the implied warranty of
+ * merchantability or fitness for a partcular purpose. See the
+ * GUN General Public License for more details.
+ * **************************************************************/
+#ifndef __SKW_BOOT_H__
+#define __SKW_BOOT_H__
+
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/completion.h>
+#include <linux/workqueue.h>
+#include <linux/vmalloc.h>
+#if  KERNEL_VERSION(4, 13, 0) <= LINUX_VERSION_CODE
+#include <uapi/linux/sched/types.h>
+#else
+#include <linux/sched.h>
+#endif
+
+#ifdef SKW_EXT_INC
+#include "skw_platform_data.h"
+#else
+#include <linux/platform_data/skw_platform_data.h>
+#endif
+
+#ifdef CONFIG_WAKELOCK
+#include <linux/wakelock.h>
+#else
+#include <linux/pm_wakeup.h>
+#endif
+#include "boot_config.h"
+
+#if KERNEL_VERSION(4, 14, 0) <= LINUX_VERSION_CODE
+#define skw_read_file	kernel_read
+#define skw_write_file  kernel_write
+#else
+#define skw_read_file	vfs_read
+#define skw_write_file  vfs_write
+#endif
+
+#if KERNEL_VERSION(5, 4, 0) <= LINUX_VERSION_CODE
+#define skw_wakeup_source_register(x, y)		  wakeup_source_register(x,y)
+#else
+#define skw_wakeup_source_register(x, y)		  wakeup_source_register(y)
+#endif
+
+#if KERNEL_VERSION(4, 4, 0) <= LINUX_VERSION_CODE
+#define skw_reinit_completion(x)	  reinit_completion(&x)
+#define SKW_MIN_NICE					  MIN_NICE
+#else
+#define skw_reinit_completion(x)	  INIT_COMPLETION(x)
+#define SKW_MIN_NICE					  -20
+#endif
+
+#ifdef CONFIG_NO_GKI
+MODULE_IMPORT_NS(VFS_internal_I_am_really_a_filesystem_and_am_NOT_a_driver);
+#endif
+
+#if KERNEL_VERSION(5, 0, 0) <= LINUX_VERSION_CODE
+  MODULE_IMPORT_NS(VFS_internal_I_am_really_a_filesystem_and_am_NOT_a_driver);
+#endif
+/****************************************************************
+ *Description:the skwsdio log define and the skwsdio data debug,
+ *Func: skwsdio_log, skwsdio_err, skwsdio_data_pr;
+ *Calls:
+ *Call By:
+ *Input: skwsdio log debug informations
+ *Output:
+ *Return
+ *Others:
+ *AuthorJUNWEI.JIANG
+ *Date:2021-08-25
+ * **************************************************************/
+#define skwboot_log(fmt, args...) \
+	pr_info("[SKWBOOT]:" fmt, ## args)
+
+#define skwboot_err(fmt, args...) \
+	pr_err("[SKWBOOT_ERR]:" fmt, ## args)
+
+#define skwboot_warn(fmt, args...) \
+	pr_warn("[SKWBOOT_WARN]:" fmt, ## args)
+
+#define skwboot_data_pr(level, prefix_str, prefix_type, rowsize,\
+		groupsize, buf, len, asscii)\
+		do{if(loglevel) \
+			print_hex_dump(level, prefix_str, prefix_type, rowsize,\
+					groupsize, buf, len, asscii);\
+		}while(0)
+
+/**********************sdio boot interface start******************/
+
+#define SKW_BOOT_START_ADDR			0x100000
+#define SKW_CHIP_ID					0x40000000  //SV6160 chip id
+/*add the 32bit*4 128bit */
+struct img_head_data_t
+{
+	 unsigned int index;
+	 unsigned int dl_addr;
+	 unsigned int data_size;
+	 unsigned int write_addr;
+};
+/*add the 32bit*4 128bit */
+struct img_dl_data
+{
+	 unsigned int dl_addr;
+	 unsigned int dl_info; /*type and the size*/
+	 unsigned int write_addr;
+};
+
+#define CRC_16_L_SEED	0x80
+#define CRC_16_L_POLYNOMIAL  0x8000
+#define CRC_16_POLYNOMIAL  0x1021
+#define IRAM_CRC_OFFSET	 0
+#define DRAM_CRC_OFFSET	 0
+
+#define SKW_FIRST_BOOT  0
+#define SKW_BSP_BOOT	 1
+#define SKW_WIFI_BOOT	2
+#define SKW_BT_BOOT	  3
+#define RECOVERY_BOOT	4
+
+/*slp reg add the ap send the irq to cp reg*/
+#define SKW_SDIO_PD_DL_AP2CP_BSP		0x160 //download done  or first boot setup addrn
+#define SKW_SDIO_AP2CP_EXTI_SETVAL 		0x161 //External Interrupt set val 1 or 2 ;3 is fail
+#define SDIOHAL_PD_DL_AP2CP_BT			0x162
+#define SDIOHAL_PD_DL_ALL				0x163
+#define SKW_SDIO_DL_POWERON_MODULE		0x164 //Poweron CP Moudle  1 WIFI 2:BT
+#define SKW_SDIO_PLD_DMA_TYPE			0x165
+#define SDIOHAL_CPLOG_TO_AP_SWITCH		0x166
+#define SKW_SDIO_CP_SLP_SWITCH  		0x167 //Turn on/off the CP slp feature 1:dis slp 0:enb slp
+#define SKW_SDIO_CREDIT_TO_CP			0x168
+
+// CP signal 3
+#define SKW_SDIO_RX_CHANNEL_FTL0		0x16C
+#define SKW_SDIO_RX_CHANNEL_FTL1		0x16D
+
+/*slp reg get the cp dl state reg*/
+#define SKW_SDIO_DL_CP2AP_BSP			0x180 //poweron OK ? 1: WIFI 2:BT
+#define SKW_SDIO_CP2AP_FIFO_IND			0x181 //CP_RX FIFO Empty Indiacation.
+#define SKW_SDIO_CP2AP_EXTI_GETVAL		0x182 //sdio External Interrupt get val 1 or 2 ;3 is fail
+#define SDIOHAL_PD_DL_CP2AP_ALL			0x183
+#define SDIOHAL_PD_DL_CP2AP_SIG4		0x184
+#define SDIOHAL_PD_DL_CP2AP_SIG5		0x185
+#define SDIOHAL_PD_DL_CP2AP_SIG6		0x186
+#define SDIOHAL_PD_DL_CP2AP_SIG7		0x187
+
+#define SKWSDIO_AP2CP_IRQ				0x1b0  //AP to CP interrupt and used BIT4 set 1 :fifth bit
+enum dma_type_en{
+	ADMA=1,
+	SDMA,
+};
+
+enum skw_service_ops {
+	SKW_NO_SERVICE =0,
+	SKW_WIFI_START,
+	SKW_WIFI_STOP,
+	SKW_BT_START,
+	SKW_BT_STOP,
+};
+
+struct seekwave_device {
+	char *file_path;
+	char *skw_nv_name;
+	char *iram_file_path;
+	char *dram_file_path;
+	char *img_data;
+	int  img_size;
+	int host_gpio;/*GPIO0_A3*/
+	int chip_gpio;/*GPIO2_D2*/
+	int chip_en;/*GPIO0_B1*/
+	char *iram_img_data;
+	char *dram_img_data;
+	char *nv_mem_data;
+	void *dl_bin;//load the img
+	int  (*wifi_start)(void);
+	int  (*bt_start)(void);
+	int  (*wifi_stop)(void);
+	int  (*bt_stop)(void);
+	unsigned int iram_dl_addr;
+	unsigned int iram_dl_size;
+	unsigned int dram_dl_addr;
+	unsigned int dram_dl_size;
+	unsigned int nv_mem_addr;
+	unsigned int nv_mem_size;
+	unsigned int setup_addr;//setup address
+	unsigned int save_setup_addr;//send the setup address register
+	unsigned int dl_addr;//
+	unsigned int dl_acount_addr;
+	unsigned int dl_size;
+	unsigned int first_dl_flag;
+	unsigned int dl_module;
+	unsigned int dma_type_addr;//1:ADMA,2:SDMA
+	unsigned int dma_type;//1:ADMA,2:SDMA
+	unsigned int slp_disable;//0:disable,1:enable
+	unsigned int slp_disable_addr;
+	unsigned int head_addr;
+	unsigned int tail_addr;
+	unsigned int bsp_head_addr;
+	unsigned int bsp_tail_addr;
+	unsigned int wifi_head_addr;
+	unsigned int wifi_tail_addr;
+	unsigned int bt_head_addr;
+	unsigned int bt_tail_addr;
+	unsigned int nv_head_addr;
+	unsigned int nv_tail_addr;
+	unsigned int nv_data_size;
+	int bt_service_state;
+	int wifi_service_state;
+	int service_ops;
+	int dl_done_signal;
+	int gpio_out;//host wakeup gpio0:/*GPIO0_A3*/,chip_wakeup gpio2:/*GPIO2_D2*/
+	int gpio_in;//host wakeup gpio 0
+	int gpio_val;
+	int gpio_next_val;
+	unsigned int chip_id;
+	unsigned int fpga_debug;
+	unsigned int iram_crc_offset;
+	unsigned int dram_crc_offset;
+	unsigned int nvmem_crc_offset;
+	unsigned short iram_crc_val;
+	unsigned short dram_crc_val;
+	unsigned short nvmem_crc_val;
+	unsigned int iram_crc_en;
+	unsigned int dram_crc_en;
+	unsigned int nvmem_crc_en;
+	unsigned int bt_antenna;
+	struct  platform_device *pdev;
+};
+int seekwave_boot_init(void);
+void seekwave_boot_exit(void);
+int skw_ucom_init(void);
+void skw_ucom_exit(void);
+int skw_bind_boot_driver(struct device *dev);
+#define SKW_CHIP_POWEROFF(gpiono) \
+{ \
+    if(gpiono >= 0) { \
+    	gpio_set_value(gpiono>>1, (gpiono&0x01)); \
+    } \
+}
+
+#define SKW_CHIP_POWERON(gpiono) \
+{ \
+    if(gpiono >= 0) { \
+  	gpio_set_value(gpiono>>1, 1-(gpiono&0x01)); \
+    } \
+}
+#endif
diff --git a/drivers/misc/seekwaveplatform_v20/skwutil/skw_log_to_file.c b/drivers/misc/seekwaveplatform_v20/skwutil/skw_log_to_file.c
new file mode 100755
index 000000000000..465f0f00e98a
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/skwutil/skw_log_to_file.c
@@ -0,0 +1,806 @@
+/*****************************************************************
+ *Copyright (C) 2021 Seekwave Tech Inc.
+ *Filename : skw_log_process.c
+ *Authors:seekwave platform
+ *
+ * This software is licensed under the terms of the the GNU
+ * General Public License version 2, as published by the Free
+ * Software Foundation, and may be copied, distributed, and
+ * modified under those terms.
+ *
+ * This program is distributed in the hope that it will be usefull,
+ * but without any warranty;without even the implied warranty of
+ * merchantability or fitness for a partcular purpose. See the
+ * GUN General Public License for more details.
+ * **************************************************************/
+
+/* #define DEBUG */
+/* #define VERBOSE_DEBUG */
+
+#include <linux/kernel.h>
+#include <linux/cdev.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/workqueue.h>
+#include <linux/scatterlist.h>
+#include <linux/platform_device.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/err.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/file.h>
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+#include "skw_boot.h"
+
+#include "skw_log_to_file.h"
+#include "skw_mem_map.h"
+extern int cp_exception_sts;
+static char *log_path = "/data";
+module_param(log_path, charp, 0644);
+
+int skw_log_num = 2;
+#ifdef MIN_LOG_SIZE
+int skw_log_size = (1*1024*1024);
+#else
+int skw_log_size = (100*1024*1024);
+#endif
+#define SKW_LOG_READ_BUFFER_SIZE (8*1024)
+//#define CONFIG_NO_GKI
+module_param(skw_log_size, int, 0644);
+module_param(skw_log_num, int, 0644);
+
+struct skw_log_data	{
+	spinlock_t lock;
+
+	int state;
+
+	/* synchronize access to our device file */
+	atomic_t open_excl;
+	/* to enforce only one ioctl at a time */
+	atomic_t ioctl_excl;
+
+
+	int rx_done;
+	/* for processing MTP_SEND_FILE, MTP_RECEIVE_FILE and
+	 * MTP_SEND_FILE_WITH_HEADER ioctls on a work queue
+	 */
+	struct workqueue_struct *wq;
+	struct work_struct log_to_file_work;
+	struct file *xfer_file;
+	loff_t xfer_file_offset;
+	int64_t xfer_file_length;
+	unsigned xfer_send_header;
+	uint16_t xfer_command;
+	uint32_t xfer_transaction_id;
+	int xfer_result;
+};
+
+struct log_com_dev	{
+	atomic_t open;
+	spinlock_t lock;
+	int 	rx_busy;
+	int	tx_busy;
+	int	devno;
+	int	portno;
+	struct sv6160_platform_data *pdata;
+	wait_queue_head_t wq;
+	struct cdev cdev;
+	char	*rx_buf;
+	char	*tx_buf;
+	struct notifier_block notifier;
+};
+struct skw_log_read_buffer	{
+	int 	lenth;
+	char	*buffer;
+};
+
+#ifdef CONFIG_NO_GKI
+static void skw_modem_log_to_file_work(struct work_struct *data);
+//extern int skw_cp_exception_reboot(void);
+#endif
+
+#ifdef CONFIG_NO_GKI
+static int skw_modem_save_dumpmem(void);
+static void skw_modem_dumpmodem_start_rec(void);
+static void skw_modem_dumpmodem_stop_rec(void);
+#endif
+static uint32_t record_flag = 0;
+#ifdef CONFIG_NO_GKI
+static uint32_t dumpmodem_flag = 0;
+#endif
+static uint32_t cp_assert_status = 0;
+#ifdef CONFIG_NO_GKI
+static struct file *log_fp = NULL;
+#endif
+struct log_com_dev *log_com = NULL;
+
+struct sv6160_platform_data *port_data = NULL;
+#ifdef CONFIG_NO_GKI
+static struct skw_log_data *skw_log_dev = NULL;
+#endif
+struct skw_log_read_buffer log_read_buffer;
+
+char *log0_file = "log000";
+char *log1_file = "log111";
+char *log_file;
+
+char* skw_code_mem = "code_mem_100000_7a000";
+char* skw_data_mem = "data_mem_20200000_40000";
+char* skw_cscb_mem = "cscb_mem_e000ed00_300";
+char* skw_wreg_mem = "wreg_mem_40820000_4000";
+char* skw_phyr_mem = "phyr_mem_40830000_4000";
+char* skw_smem_mem = "smem_mem_40a00000_58000";
+char* skw_umem_mem = "umem_mem_40b00000_c000";
+char* skw_modem_mem = "modem_mem_401e0000_800";
+char* skw_btdm_mem = "btdm_mem_41000000_400";
+char* skw_btbt_mem = "btbt_mem_41000400_400";
+char* skw_btle_mem = "btle_mem_41000800_400";
+char* skw_btem_mem = "btem_mem_41022000_c000";
+char* skw_edma_mem = "edma_mem_40188000_1080";
+char* skw_wfrf_mem = "wfrf_mem_40144000_5000";
+char* skw_rfglb_mem = "rfglb_mem_40150000_600";
+
+#ifdef CONFIG_NO_GKI
+static int modem_event_notifier(struct notifier_block *nb, unsigned long action, void *data)
+{
+	unsigned long flags;
+	//int ret = 0;
+	skwboot_log("%s event = %d\n", __func__, (int)action);
+	switch(action)
+	{
+		case DEVICE_ASSERT_EVENT:
+		{
+			struct log_com_dev *ucom = log_com;
+			skwboot_log("the BSPASSERT EVENT Comming in !!!!\n");
+			skw_modem_log_start_rec();
+			spin_lock_irqsave(&ucom->lock, flags);
+			if(ucom->tx_busy) {
+				spin_unlock_irqrestore(&ucom->lock, flags);
+				skwboot_err("%s error 0\n", __func__);
+				return NOTIFY_OK;
+			}
+			ucom->tx_busy = 1;
+			spin_unlock_irqrestore(&ucom->lock, flags);
+#if 0
+			*(ucom->tx_buf) = 0x33;
+			*(ucom->tx_buf + 1) = 0x0D;
+
+			if(!strncmp(ucom->pdata->port_name, "LOG", 3))
+				ret = ucom->pdata->hw_sdma_tx(ucom->portno, ucom->tx_buf, 2);
+#endif
+			skw_modem_log_set_assert_status(1);
+		}
+		break;
+		case DEVICE_BSPREADY_EVENT:
+		{
+			skwboot_log("the BSPREADY EVENT Comming in !!!!\n");
+			skw_modem_log_start_rec();
+			skw_modem_dumpmodem_stop_rec();
+		}
+		break;
+		case DEVICE_DUMPDONE_EVENT:
+		{
+			skwboot_log("the DUMPDONE EVENT Comming in !!!!\n");
+			skw_modem_log_stop_rec();
+			skw_modem_log_set_assert_status(0);
+		}
+		break;
+		case DEVICE_BLOCKED_EVENT:
+		{
+			skwboot_log("the BLOCKED EVENT Comming in !!!!\n");
+			skw_modem_dumpmodem_start_rec();
+		}
+		break;
+		case DEVICE_DUMPMEM_EVENT:
+		{
+			skwboot_log("the DUMP MEM EVENT Comming in !!!!\n");
+			skw_modem_dumpmodem_start_rec();
+			msleep(500);
+			skw_modem_dumpmodem_stop_rec();
+		}
+		break;
+		default:
+		{
+
+		}
+		break;
+
+	}
+	return NOTIFY_OK;
+}
+#endif
+
+#ifdef CONFIG_NO_GKI
+static void skw_modem_log_to_file_work(struct work_struct *data)
+{
+	//int log_len = 0;
+	struct file *fp = log_fp;
+	struct file *log_store_fp = NULL;
+	loff_t offset =0;
+	loff_t log_store_offset =0;
+	unsigned long flags;
+	uint32_t *rx_data;
+	size_t count = 0;
+	int ret = 0;
+	int i = 0;
+	int log_cnt = 0;
+	int sdma_rx_error_cnt = 0;
+	char *log_store;
+	int  log_path_len;
+	char rd_buff[4];
+
+	if(record_flag)
+		return;
+	record_flag = 1;
+
+	skwlog_log("log path = %s \n", log_path);
+	log_path_len = strlen(log_path);
+
+	log_file = kzalloc(log_path_len + 16, GFP_KERNEL);
+
+	if(log_file == NULL)
+		return;
+	log_store = kzalloc(log_path_len + 16, GFP_KERNEL);
+	if(log_store == NULL) {
+		kfree(log_file);
+		return;
+	}
+	log_read_buffer.lenth = 0;
+
+	sprintf(log_store, "%s/log_store", log_path);
+	log_store_fp = filp_open(log_store, O_RDWR, 0777);
+	while(IS_ERR(log_store_fp))
+	{
+		skwlog_err("open log_store %s failed:%d	\n", log_store, (int)PTR_ERR(log_store_fp));
+		msleep(1000);
+		i++;
+		if(i > 8) {
+			kfree(log_store);
+			kfree(log_file);
+			return;
+		}
+		if(i > 5){
+			skwlog_err("%s open log_store file failed, create file:%s\n",__func__, log_store);
+			log_store_fp = filp_open(log_store, O_CREAT | O_RDWR | O_TRUNC, 0777);
+		}
+		else{
+			log_store_fp = filp_open(log_store, O_RDWR, 0777);
+		}
+	}
+
+	ret = skw_read_file(log_store_fp, rd_buff, 1, &log_store_offset);
+	if(ret < 0){
+		skwlog_err("%s Read file:%s failed, err:%d \n",__func__, log_store, ret);
+	}
+
+	if(rd_buff[0] == '0') {
+		sprintf(log_file, "%s/%s", log_path, log1_file);
+		rd_buff[0] = '1';
+	} else {
+		sprintf(log_file, "%s/%s", log_path, log0_file);
+		rd_buff[0] = '0';
+	}
+	log_store_offset = 0;
+	ret = skw_write_file(log_store_fp, rd_buff, 1, &log_store_offset);
+	if(ret < 0){
+		skwlog_err("%s write file:%s failed, err:%d \n",__func__, log_store, ret);
+	}
+
+	log_fp = filp_open(log_file, O_CREAT | O_RDWR | O_TRUNC, 0777);
+	fp = log_fp;
+
+	while(IS_ERR(fp))
+	{
+		skwlog_err("open rec file %s failed :%d	\n",log_file, (int)PTR_ERR(fp));
+		msleep(500);
+		i++;
+		if(i > 10) {
+			kfree(log_store);
+			kfree(log_file);
+			return;
+		}
+
+		log_fp = filp_open(log_file, O_CREAT | O_RDWR | O_TRUNC, 0777);
+		fp = log_fp;
+	}
+	atomic_inc(&log_com->open);
+	spin_lock_init(&log_com->lock);
+
+	skwlog_log(" open %s for CP log record \n", log_file);
+	log_com->pdata->open_port(log_com->portno, NULL, NULL);
+	while(record_flag || cp_assert_status)
+	{
+		ret = 0;
+		if(log_com){
+check_rx_busy:
+			spin_lock_irqsave(&log_com->lock, flags);
+			if(log_com->rx_busy) {
+				spin_unlock_irqrestore(&log_com->lock, flags);
+				mdelay(5);
+				goto check_rx_busy;
+			}
+			log_com->rx_busy = 1;
+			count = log_com->pdata->max_buffer_size;
+			spin_unlock_irqrestore(&log_com->lock, flags);
+			ret = log_com->pdata->hw_sdma_rx(log_com->portno, (log_read_buffer.buffer + log_read_buffer.lenth), count);
+			if(ret > 0){
+				log_cnt++;
+				sdma_rx_error_cnt = 0;
+				log_read_buffer.lenth = log_read_buffer.lenth + ret;
+				//skwlog_log("hw_sdma_rx read len:%d buffer len:%d \n", ret, log_read_buffer.lenth);
+				if(ret >= 0x1000)
+					skwlog_err("%s get too long data , err:%d \n",__func__, ret);
+
+				if(log_cnt > 1000){
+					skwlog_log("%s log_file:%s offset:%lld data:0x%x 0x%x 0x%x 0x%x 0x%x	\n",__func__, log_file, offset, *(log_read_buffer.buffer),
+						*(log_read_buffer.buffer+1), *(log_read_buffer.buffer+2), *(log_read_buffer.buffer+3), *(log_read_buffer.buffer+4));
+					log_cnt = 0;
+				}
+			}
+			else{
+				skwlog_err("%s read log data err:%d \n",__func__, ret);
+				sdma_rx_error_cnt++;
+				if(sdma_rx_error_cnt > 5){
+					skwlog_err("%s sdma_rx_error_cnt over:%d, stop log work \n",__func__, sdma_rx_error_cnt);
+					skw_modem_log_set_assert_status(0);
+					skw_modem_log_stop_rec();
+				}
+			}
+
+			if (port_data->bus_type == USB_LINK) {
+				if(ret < 0){
+					skwlog_err("%s read log data err:%d, stop log work \n",__func__, ret);
+					skw_modem_log_set_assert_status(0);
+					skw_modem_log_stop_rec();
+				}
+			}
+			else if (port_data->bus_type == SDIO_LINK) {
+				if(ret == -ENOTCONN){
+					skw_modem_log_set_assert_status(0);
+					skw_modem_log_stop_rec();
+				}
+			}
+			//skwlog_log("read log from SDIO len:%d  ----- \n", log_read_buffer.lenth);
+			log_com->rx_busy = 0;
+			rx_data = (uint32_t *)log_read_buffer.buffer;	
+		}
+
+		if(((log_read_buffer.lenth > 0) && cp_assert_status) 
+			|| ((SKW_LOG_READ_BUFFER_SIZE - log_read_buffer.lenth) <= (log_com->pdata->max_buffer_size))){
+			//skwlog_log("skw_write_file:%s offset:%lld lenth:%d \n", skw_log, offset, log_read_buffer.lenth);
+			ret = skw_write_file(fp, log_read_buffer.buffer, log_read_buffer.lenth, &offset);
+			if(ret < 0){
+				skwlog_err("%s write file failed, err:%d \n",__func__, ret);
+			}
+
+			log_read_buffer.lenth = 0;
+			if(ret == -ENOSPC){
+				skwlog_err("%s no space, stop CP log record \n",__func__);
+				skw_modem_log_stop_rec();
+			}
+
+			if(offset > skw_log_size && (!cp_assert_status)){
+				if(!IS_ERR(fp))
+					filp_close(fp, NULL);
+
+				if(rd_buff[0] == '0'){
+					sprintf(log_file, "%s/%s", log_path, log1_file);
+					rd_buff[0] = '1';
+				}
+				else{
+					sprintf(log_file, "%s/%s", log_path, log0_file);
+					rd_buff[0] = '0';
+				}
+				log_store_offset = 0;
+				ret = skw_write_file(log_store_fp, rd_buff, 1, &log_store_offset);
+				if(ret < 0){
+					skwlog_err("%s write file:%s failed, err:%d \n",__func__, log_store, ret);
+				}
+
+				log_fp = filp_open(log_file, O_CREAT | O_RDWR | O_TRUNC, 0777);
+				fp = log_fp;
+				if(IS_ERR(fp)){
+					skwlog_err("%s switch record file to:%s failed: %d \n",__func__, log_file, (int)PTR_ERR(fp));
+					return;
+				}
+				else{
+					skwlog_err("%s switch record file to:%s sucess \n",__func__, log_file);
+				}
+
+				offset = 0;
+			}
+#if 0
+			ret = vfs_fssync(fp, 0);
+			if(ret < 0){
+				skwlog_err("%s fssync file failed, err:%d	\n",__func__, ret);
+			}
+#endif
+		}
+	}
+	atomic_dec(&log_com->open);
+	log_com->pdata->close_port(log_com->portno);
+
+	if(!IS_ERR(fp)){
+		filp_close(fp, NULL);
+		skwlog_log("%s close file %s before stop work.\n",__func__, log_file);
+		log_fp = NULL;
+		fp = log_fp;
+	}
+
+	if(!IS_ERR(log_store_fp)){
+		filp_close(log_store_fp, NULL);
+		skwlog_log("%s close file %s before stop work.\n",__func__, log_store);
+		log_store_fp = NULL;
+	}
+	kfree(log_file);
+	kfree(log_store);
+	skwlog_log("%s work exit\n",__func__);
+
+	return;
+}
+#endif
+
+/***************************************************************************
+ *Description:dump modem memory
+ *Seekwave tech LTD
+ *Author:JunWei Jiang
+ *Date:2022-11-14
+ *Modify:
+ **************************************************************************/
+#ifdef CONFIG_NO_GKI
+static int skw_modem_save_mem(char *mem_path,unsigned int mem_len, unsigned int mem_addr)
+{
+	int ret =0;
+
+	char dump_mem_file[128];
+	//dump code data
+	char *data_mem = NULL;
+	struct file *fp =NULL;
+	loff_t pos = 0;
+	int nwrite = 0;
+	unsigned int read_len=0;
+	unsigned int mem_size = mem_len;
+
+	memset(dump_mem_file, 0, sizeof(dump_mem_file));
+	sprintf(dump_mem_file,"%s/%s", log_path, mem_path);
+	data_mem = kzalloc(SKW_MAX_BUF_SIZE, GFP_KERNEL);
+	if(!data_mem){
+		skwlog_log("the kzalloc dump buffer fail");
+		return -2;
+	}
+	/* open file to write */
+	fp = filp_open(dump_mem_file, O_CREAT | O_RDWR | O_TRUNC, 0777);
+	if (IS_ERR(fp)) {
+		skwlog_log("open file %s fail try again!!!\n", dump_mem_file);
+		fp = filp_open(mem_path, O_CREAT | O_RDWR | O_TRUNC, 0777);
+		if(IS_ERR(fp)){
+			skwlog_log("open file error\n");
+			ret = -1;
+			goto exit;
+		}
+	}
+
+	while(mem_size)
+	{
+		if(mem_size<SKW_MAX_BUF_SIZE)
+		{
+			read_len = mem_size;
+		}else{
+			read_len = SKW_MAX_BUF_SIZE;
+		}
+		//skwlog_log("the read_len =0x%x mem_size= 0x%x\n", read_len, mem_size);
+		ret = log_com->pdata->skw_dump_mem(mem_addr+(mem_len-mem_size),(void *)data_mem,read_len);
+		if(ret< 0)
+			break;
+
+		//print_hex_dump(KERN_ERR, "img data ", 0, 16, 1,data_mem, 32, 1);
+		//pos=(unsigned long)offset;
+		/* Write buf to file */
+		nwrite=skw_write_file(fp, data_mem,read_len, &pos);
+		//offset +=nwrite;
+
+		if(mem_size>=SKW_MAX_BUF_SIZE)
+		{
+			mem_size=mem_size-SKW_MAX_BUF_SIZE;
+		}else{
+			mem_size =0;
+		}
+	}
+	skwlog_log("Dump %s memory done !!\n", mem_path);
+	if(fp)
+	{
+		filp_close(fp,NULL);
+		skwlog_log("the file close!!!\n");
+	}
+exit:
+	kfree(data_mem);
+
+	return ret;
+}
+#endif
+
+/***************************************************************************
+ *Description:dump modem memory
+ *Seekwave tech LTD
+ *Author:JunWei Jiang
+ *Date:2022-11-14
+ *Modify:
+ **************************************************************************/
+#ifdef CONFIG_NO_GKI
+static int skw_modem_save_dumpmem(void)
+{
+	int ret =0;
+	skwlog_log("The ------Enter ----\n");
+	//DATA MEM
+	ret = skw_modem_save_mem(skw_data_mem,DATA_MEM_SIZE, DATA_MEM_BASE_ADDR);
+	if(ret !=0)
+	{
+		skwlog_log("dump %s mem fail ret: %d\n", skw_data_mem, ret);
+		return -1;
+	}
+	//CODE MEM
+	ret = skw_modem_save_mem(skw_code_mem,CODE_MEM_SIZE, CODE_MEM_BASE_ADDR);
+	if(ret !=0)
+	{
+		skwlog_log("dump %s mem fail ret: %d\n", skw_code_mem,ret);
+		return -1;
+	}
+	//CSCB MEM
+	ret = skw_modem_save_mem(skw_cscb_mem,CSCB_MEM_SIZE, CSCB_MEM_BASE_ADDR);
+	if(ret !=0)
+	{
+		skwlog_log("dump %s mem fail ret: %d\n", skw_cscb_mem,ret);
+		return -1;
+	}
+	//WREG MEM
+	ret = skw_modem_save_mem(skw_wreg_mem,WREG_MEM_SIZE, WREG_MEM_BASE_ADDR);
+	if(ret !=0)
+	{
+		skwlog_log("dump %s mem fail ret: %d\n", skw_wreg_mem,ret);
+		return -1;
+	}
+	//PHYR MEM
+	ret = skw_modem_save_mem(skw_phyr_mem,PHYR_MEM_SIZE, PHYR_MEM_BASE_ADDR);
+	if(ret !=0)
+	{
+		skwlog_log("dump %s mem fail ret: %d\n", skw_phyr_mem,ret);
+		return -1;
+	}
+	//SMEM MEM
+	ret = skw_modem_save_mem(skw_smem_mem,SMEM_MEM_SIZE, SMEM_MEM_BASE_ADDR);
+	if(ret !=0)
+	{
+		skwlog_log("dump %s mem fail ret: %d\n", skw_smem_mem,ret);
+		return -1;
+	}
+	//UMEM MEM
+	ret = skw_modem_save_mem(skw_umem_mem,UMEM_MEM_SIZE, UMEM_MEM_BASE_ADDR);
+	if(ret !=0)
+	{
+		skwlog_log("dump %s mem fail ret: %d\n", skw_umem_mem,ret);
+		return -1;
+	}
+	//SDIO MEM
+	ret = skw_modem_save_mem(skw_modem_mem,SDIO_MEM_SIZE, SDIO_MEM_BASE_ADDR);
+	if(ret !=0)
+	{
+		skwlog_log("dump %s mem fail ret: %d\n",skw_modem_mem,ret);
+		return -1;
+	}
+	//BTDM MEM
+	ret = skw_modem_save_mem(skw_btdm_mem,BTDM_MEM_SIZE, BTDM_MEM_BASE_ADDR);
+	if(ret !=0)
+	{
+		skwlog_log("dump %s mem fail ret: %d\n", skw_btdm_mem,ret);
+		return -1;
+	}
+	//BTBT MEM
+	ret = skw_modem_save_mem(skw_btbt_mem,BTBT_MEM_SIZE, BTBT_MEM_BASE_ADDR);
+	if(ret !=0)
+	{
+		skwlog_log("dump %s mem fail ret: %d\n", skw_btbt_mem,ret);
+		return -1;
+	}
+	//BTLE MEM
+	ret = skw_modem_save_mem(skw_btle_mem,BTLE_MEM_SIZE, BTLE_MEM_BASE_ADDR);
+	if(ret !=0)
+	{
+		skwlog_log("dump %s mem fail ret: %d\n", skw_btle_mem,ret);
+		return -1;
+	}
+	//BTEM MEM
+	ret = skw_modem_save_mem(skw_btem_mem,BTEM_MEM_SIZE, BTEM_MEM_BASE_ADDR);
+	if(ret !=0){
+		skwlog_log("dump %s mem fail ret: %d\n",skw_btem_mem,ret);
+		return -1;
+	}
+	//EDMA MEM
+	ret = skw_modem_save_mem(skw_edma_mem,HIF_EDMA_SIZE, HIF_EDMA_BASE_ADDR);
+	if(ret !=0){
+		skwlog_log("dump %s mem fail ret: %d\n",skw_edma_mem,ret);
+		return -1;
+	}
+	//WFRF MEM
+	ret = skw_modem_save_mem(skw_wfrf_mem,WFRF_MEM_SIZE, WFRF_BASE_ADDR);
+	if(ret !=0){
+		skwlog_log("dump %s mem fail ret: %d\n",skw_wfrf_mem,ret);
+		return -1;
+	}
+	//RFGLB MEM
+	ret = skw_modem_save_mem(skw_rfglb_mem,RFGLB_MEM_SIZE, RFGLB_BASE_ADDR);
+	if(ret !=0){
+		skwlog_log("dump %s mem fail ret: %d\n",skw_rfglb_mem,ret);
+		return -1;
+	}
+	return ret;
+}
+#endif
+
+int skw_modem_log_init(struct sv6160_platform_data *p_data, struct file *fp, void *ucom)
+{
+
+	int ret = 0;
+#ifdef CONFIG_NO_GKI
+	skwlog_log("%s enter  \n",__func__);
+	if (skw_log_dev)
+		return 0;
+	log_fp = fp;
+	log_com = ucom;
+	port_data = p_data;
+
+	log_read_buffer.lenth = 0;
+	log_read_buffer.buffer = kzalloc(SKW_LOG_READ_BUFFER_SIZE, GFP_KERNEL);
+	if(!log_read_buffer.buffer){
+		ret = -ENOMEM;
+		skwlog_err("%s can't malloc log_read_buffer,%d\n", __func__, __LINE__);
+		goto err1;
+	}
+	skw_log_dev = (struct skw_log_data *)kzalloc(sizeof(*skw_log_dev), GFP_KERNEL);
+	if (!skw_log_dev){
+		ret = -ENOMEM;
+		skwlog_err("%s can't malloc skw_log_dev,%d\n", __func__, __LINE__);
+		goto err1;
+	}
+
+	spin_lock_init(&skw_log_dev->lock);
+	atomic_set(&skw_log_dev->open_excl, 0);
+	atomic_set(&skw_log_dev->ioctl_excl, 0);
+	//INIT_LIST_HEAD(&skw_log_dev->tx_idle);
+
+	skw_log_dev->wq = create_singlethread_workqueue("skw_log");
+	if (!skw_log_dev->wq) {
+		ret = -ENOMEM;
+		goto err1;
+	}
+	INIT_WORK(&skw_log_dev->log_to_file_work, skw_modem_log_to_file_work);
+
+	if (log_com->pdata->modem_register_notify) {
+		if(log_com->notifier.notifier_call == NULL){
+			log_com->notifier.notifier_call = modem_event_notifier;
+			log_com->pdata->modem_register_notify(&log_com->notifier);
+		}
+	}
+
+	if (ret)
+		goto err2;
+
+	skw_modem_log_start_rec();
+	return 0;
+
+err2:
+	destroy_workqueue(skw_log_dev->wq);
+err1:
+	kfree(skw_log_dev);
+	printk(KERN_ERR "mtp gadget driver failed to initialize\n");
+#endif
+	return ret;
+}
+
+void skw_modem_log_set_assert_status(uint32_t cp_assert)
+{
+	cp_assert_status = cp_assert;
+	if(cp_assert_status){
+		skwlog_log("%s CP in ASSERT, dump log in %s \n",__func__, log_file);
+	}
+}
+
+void skw_modem_log_start_rec(void)
+{
+	skwlog_log("%s enter  \n",__func__);
+#ifdef CONFIG_NO_GKI
+	if(!log_com) return;
+	if(atomic_read(&log_com->open) > 1){
+		skwlog_log("log port is busy\n");
+		return;
+	}
+	if(!skw_log_dev){
+		skwlog_log("%s no mem ready, can't start \n",__func__);
+		return;
+	}
+	if(record_flag){
+		skwlog_log("%s lof2file already start \n",__func__);
+		return;
+	}
+	cp_assert_status = 0;
+	queue_work(skw_log_dev->wq, &skw_log_dev->log_to_file_work);
+#endif
+
+}
+
+/***************************************************************************
+ *Description:dump modem memory
+ *Seekwave tech LTD
+ *Author:JunWei Jiang
+ *Date:2022-11-14
+ *Modify:
+ **************************************************************************/
+#ifdef CONFIG_NO_GKI
+static void skw_modem_dumpmodem_start_rec(void)
+{
+	skwlog_log("%s enter  \n",__func__);
+	if(!skw_log_dev){
+		skwlog_log("%s no mem ready, can't start \n",__func__);
+		return;
+	}
+	if(dumpmodem_flag){
+		skwlog_log("%s dump modem mem already start \n",__func__);
+		return;
+	}
+	dumpmodem_flag = 1;
+	skw_modem_save_dumpmem();
+}
+#endif
+/***************************************************************************
+ *Description:dump modem memory
+ *Seekwave tech LTD
+ *Author:JunWei Jiang
+ *Date:2022-11-14
+ *Modify:
+ **************************************************************************/
+#ifdef CONFIG_NO_GKI
+static void skw_modem_dumpmodem_stop_rec(void)
+{
+	skwlog_log("%s enter %d  \n",__func__, cp_assert_status);
+
+	if(dumpmodem_flag)
+		dumpmodem_flag = 0;
+
+	return;
+}
+#endif
+
+void skw_modem_log_stop_rec(void)
+{
+	skwlog_log("%s enter %d \n",__func__, cp_assert_status);
+
+	if(record_flag)
+		record_flag = 0;
+	if(log_com && log_com->pdata && log_com->pdata->close_port)
+		log_com->pdata->close_port(log_com->portno);
+	return;
+}
+
+void skw_modem_log_exit(void)
+{
+	skwlog_log("%s -----line %d ---enter  \n",__func__, __LINE__);
+#ifdef CONFIG_NO_GKI
+	if(!log_com) return;
+	log_com->pdata->modem_unregister_notify(&log_com->notifier);
+	skw_modem_log_stop_rec();
+	skw_modem_dumpmodem_stop_rec();
+	destroy_workqueue(skw_log_dev->wq);
+	skwlog_log("%s -----line %d ---enter  \n",__func__, __LINE__);
+	kfree(skw_log_dev);
+	skw_log_dev = NULL;
+	log_com = NULL;
+	if(log_read_buffer.buffer)
+		kfree(log_read_buffer.buffer);
+#endif
+}
+
+//DECLARE_USB_FUNCTION_INIT(mtp, mtp_alloc_inst, mtp_alloc);
+MODULE_LICENSE("GPL");
diff --git a/drivers/misc/seekwaveplatform_v20/skwutil/skw_log_to_file.h b/drivers/misc/seekwaveplatform_v20/skwutil/skw_log_to_file.h
new file mode 100755
index 000000000000..f0ad90966363
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/skwutil/skw_log_to_file.h
@@ -0,0 +1,49 @@
+/*****************************************************************
+ *Copyright (C) 2021 Seekwave Tech Inc.
+ *Filename : skw_sdio.h
+ *Authors:seekwave platform
+ *
+ * This software is licensed under the terms of the the GNU
+ * General Public License version 2, as published by the Free
+ * Software Foundation, and may be copied, distributed, and
+ * modified under those terms.
+ *
+ * This program is distributed in the hope that it will be usefull,
+ * but without any warranty;without even the implied warranty of
+ * merchantability or fitness for a partcular purpose. See the
+ * GUN General Public License for more details.
+ * **************************************************************/
+#ifndef __SKW_LOG_H__
+#define __SKW_LOG_H__
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/workqueue.h>
+
+/****************************************************************
+ *Description:the skwsdio log define and the skwsdio data debug,
+ *Func: skwsdio_log, skwsdio_err, skwsdio_data_pr;
+ *Calls:
+ *Call By:
+ *Input: skwsdio log debug informations
+ *Output:
+ *Return
+ *Others:
+ *AuthorJUNWEI.JIANG
+ *Date:2022-07-18
+ * **************************************************************/
+#define skwlog_log(fmt, args...) \
+    pr_info("[SKWLOG]:" fmt, ## args)
+
+#define skwlog_err(fmt, args...) \
+    pr_err("[SKWLOG_ERR]:" fmt, ## args)
+
+
+int skw_modem_log_init(struct sv6160_platform_data *p_data, struct file *fp, void *ucom);
+void skw_modem_log_set_assert_status(uint32_t cp_assert);
+void skw_modem_log_start_rec(void);
+void skw_modem_log_stop_rec(void);
+void skw_modem_log_exit(void);
+
+#endif
diff --git a/drivers/misc/seekwaveplatform_v20/skwutil/skw_mem_map.h b/drivers/misc/seekwaveplatform_v20/skwutil/skw_mem_map.h
new file mode 100755
index 000000000000..e0e083a04055
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/skwutil/skw_mem_map.h
@@ -0,0 +1,116 @@
+/*
+ * skw_mem_map.h
+ * Copyright (C) 2022 cfig <junwei.jiang@seekwavetech.com>
+ *
+ * Distributed under terms of the MIT license.
+ */
+
+#ifndef SKW_MEM_MAP_H
+#define SKW_MEM_MAP_H
+
+//#define SKW_MAX_BUF_SIZE    0x400 //1K
+#define SKW_MAX_BUF_SIZE    0x100 //256B
+
+/*---------------CODE MEM SECTION-------------------------*/
+#define CODE_MEM_BASE_ADDR		  0x100000
+#define CODE_MEM_SIZE			   0x7A000//488K
+/*-------------------------------------------------------*/
+
+/*----------------DATA MEM SECTION-----------------------*/
+#define DATA_MEM_BASE_ADDR		  0x20200000
+#define DATA_MEM_SIZE			   0x40000//256K
+/*-------------------------------------------------------*/
+
+/*----------------CSCB MEM SECTION-----------------------*/
+#define CSCB_MEM_BASE_ADDR		  0xE000ED00
+#define CSCB_MEM_SIZE			   0x300//0.75K
+/*-------------------------------------------------------*/
+
+
+/*----------------WREG MEM SECTION-----------------------*/
+#define WREG_MEM_BASE_ADDR		  0x40820000
+#define WREG_MEM_SIZE			   0x4000//16K
+/*-------------------------------------------------------*/
+
+
+/*----------------PHYR MEM SECTION-----------------------*/
+#define PHYR_MEM_BASE_ADDR		  0x40830000
+#define PHYR_MEM_SIZE			   0x4000//16K
+/*-------------------------------------------------------*/
+
+
+/*----------------SMEM MEM SECTION-----------------------*/
+#define SMEM_MEM_BASE_ADDR		  0x40A00000
+#define SMEM_MEM_SIZE			   0x58000//352K
+/*-------------------------------------------------------*/
+
+
+/*----------------UMEM MEM SECTION-----------------------*/
+#define UMEM_MEM_BASE_ADDR		  0x40B00000
+#define UMEM_MEM_SIZE			   0xC000//48K
+/*-------------------------------------------------------*/
+
+
+/*----------------SDIO MEM SECTION-----------------------*/
+#define SDIO_MEM_BASE_ADDR		  0x401E0000
+#define SDIO_MEM_SIZE			   0x800//2K
+/*-------------------------------------------------------*/
+
+
+/*----------------BTDM MEM SECTION-----------------------*/
+#define BTDM_MEM_BASE_ADDR		  0x41000000
+#define BTDM_MEM_SIZE			   0x400//1K
+/*-------------------------------------------------------*/
+
+
+/*----------------BTBT MEM SECTION-----------------------*/
+#define BTBT_MEM_BASE_ADDR		  0x41000400
+#define BTBT_MEM_SIZE			   0x400//1K
+/*-------------------------------------------------------*/
+
+
+/*----------------BTLE MEM SECTION-----------------------*/
+#define BTLE_MEM_BASE_ADDR		  0x41000800
+#define BTLE_MEM_SIZE			   0x400//1K
+/*-------------------------------------------------------*/
+
+
+/*----------------BTEM MEM SECTION-----------------------*/
+#define BTEM_MEM_BASE_ADDR		  0x41010000
+#define BTEM_MEM_SIZE			   0xC000//48K
+/*-------------------------------------------------------*/
+
+
+/*----------------BTGB MEM SECTION-----------------------*/
+#define BTGB_MEM_BASE_ADDR		  0x41022000
+#define BTGB_MEM_SIZE			   0x40//64B
+/*-------------------------------------------------------*/
+
+
+/*----------------BTRF MEM SECTION-----------------------*/
+#define BTRF_MEM_BASE_ADDR		  0x41024000
+#define BTRF_MEM_SIZE			   0x510//1K 272B
+/*-------------------------------------------------------*/
+
+/*-------------------------------------------------------*/
+//SV6316
+/*-------------------------------------------------------*/
+#define HIF_EDMA_BASE_ADDR      0x40188000
+#define HIF_EDMA_SIZE           0x1080
+/*-------------------------------------------------------*/
+
+/*-------------------------------------------------------*/
+#define WFRF_BASE_ADDR      0x40144000
+#define WFRF_MEM_SIZE           0x5000
+/*-------------------------------------------------------*/
+
+/*-------------------------------------------------------*/
+#define RFGLB_BASE_ADDR      0x40150000
+#define RFGLB_MEM_SIZE           0x600
+/*-------------------------------------------------------*/
+
+/*-------------------------------------------------------*/
+
+
+
+#endif /* !SKW_MEM_MAP_H */
diff --git a/drivers/misc/seekwaveplatform_v20/skwutil/skw_user_com.c b/drivers/misc/seekwaveplatform_v20/skwutil/skw_user_com.c
new file mode 100755
index 000000000000..b6dcb833c402
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/skwutil/skw_user_com.c
@@ -0,0 +1,561 @@
+#include <linux/kernel.h>
+#include <linux/cdev.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/compat.h>
+#include <linux/uaccess.h>
+#include <linux/workqueue.h>
+#include <linux/scatterlist.h>
+ #include <linux/notifier.h>
+#include <linux/platform_device.h>
+#include "skw_boot.h"
+#include "skw_log_to_file.h"
+#define UCOM_PORTNO_MAX		13
+#define UCOM_DEV_PM_OPS NULL
+int cp_exception_sts=0;
+unsigned int tmp_chipid = 0;
+extern int skw_reset_bootloader_cp(void);
+//extern int skw_get_chipid(char *chip_id);
+static int	skw_major = 0;
+static struct class *skw_com_class = NULL;
+struct ucom_dev	{
+	atomic_t open;
+	spinlock_t lock;
+	int 	rx_busy;
+	int	tx_busy;
+	int	devno;
+	int	portno;
+	struct sv6160_platform_data *pdata;
+	wait_queue_head_t wq;
+	struct cdev cdev;
+	char	*rx_buf;
+	char	*tx_buf;
+	struct notifier_block notifier;
+};
+static struct ucom_dev *ucoms[UCOM_PORTNO_MAX];
+
+static int bt_state_event_notifier(struct notifier_block *nb, unsigned long action, void *data)
+{
+	//int ret = 0;
+	skwboot_log("%s event = %d\n", __func__, (int)action);
+	switch(action)
+	{
+		case DEVICE_ASSERT_EVENT:
+		{
+			skwboot_log("BT BSPASSERT EVENT Comming in !!!!\n");
+			cp_exception_sts = 1;
+		}
+		break;
+		case DEVICE_BSPREADY_EVENT:
+		{
+			cp_exception_sts = 0;
+			skwboot_log("BT BSPREADY EVENT Comming in !!!!\n");
+		}
+		break;
+		case DEVICE_DUMPDONE_EVENT:
+		{
+			cp_exception_sts = 2;
+			skwboot_log("BT DUMPDONE EVENT Comming in !!!!\n");
+		}
+		break;
+		case DEVICE_BLOCKED_EVENT:
+		{
+			cp_exception_sts = 3;
+			skwboot_log("BT BLOCKED EVENT Comming in !!!!\n");
+		}
+		break;
+		default:
+		{
+			cp_exception_sts = action;
+		}
+		break;
+
+	}
+	return NOTIFY_OK;
+}
+
+static int skw_bt_state_event_init(struct ucom_dev *ucom)
+{
+	int ret = 0;
+	skwlog_log("%s enter  \n",__func__);
+	if (ucom->pdata->modem_register_notify && ucom->notifier.notifier_call == NULL) {
+		ucom->notifier.notifier_call = bt_state_event_notifier;
+		ucom->pdata->modem_register_notify(&ucom->notifier);
+	}else{
+		skwlog_log("%s have registered !! %d  \n",__func__,__LINE__);
+	}
+
+	return ret;
+}
+
+static int skw_bt_state_event_deinit(struct ucom_dev *ucom)
+{
+	int ret = 0;
+	skwlog_log("%s enter  \n",__func__);
+	if(ucom) {
+		if((ucom->notifier.notifier_call)){
+			skwboot_log("%s :%d release the notifier \n", __func__,__LINE__);
+			ucom->notifier.notifier_call = NULL;
+			ucom->pdata->modem_unregister_notify(&ucom->notifier);
+		}
+	}
+	return ret;
+}
+
+static int user_boot_open(struct inode *ip, struct file *fp)
+{
+	struct cdev *char_dev;
+	int ret = -EIO, i;
+	struct ucom_dev *ucom=NULL;
+	int count=100;
+	while(cp_exception_sts &&count--)
+		msleep(10);
+
+	char_dev = ip->i_cdev;
+	for(i=0; i< UCOM_PORTNO_MAX; i++) {
+		if(ucoms[i] && (ucoms[i]->devno == char_dev->dev)) {
+			ucom = ucoms[i];
+			ret = 0;
+			break;
+		}
+	}
+
+	if(ucom && !cp_exception_sts) {
+		if(atomic_read(&ucom->open))
+			return -EBUSY;
+		atomic_inc(&ucom->open);
+		fp->private_data = ucom;
+		if(!cp_exception_sts)
+			ret=ucom->pdata->open_port(ucom->portno, NULL, NULL);
+
+		printk("Open user_boot device: 0x%x task %d\n", char_dev->dev, (int)current->pid);
+	}
+	skwboot_log("%s line:%d the Enter \n", __func__,__LINE__);
+
+	return ret;
+}
+
+static int user_boot_release(struct inode *ip, struct file *fp)
+{
+	struct ucom_dev *ucom = fp->private_data;
+	int count=100;
+	unsigned long arg=0;
+	while(cp_exception_sts &&count--)
+		msleep(10);
+
+	if(ucom){
+		if(!strncmp((char *)ucom->pdata->chipid,"SV6160",6))
+			arg = 0x6160;
+		else if(!strncmp((char *)ucom->pdata->chipid,"SV6316", 6))
+			arg = 0x6316;
+		if(!cp_exception_sts)
+			ucom->pdata->close_port(ucom->portno);
+
+		atomic_dec(&ucom->open);
+	}
+
+	return 0;
+}
+
+static int ucom_open(struct inode *ip, struct file *fp)
+{
+	struct cdev *char_dev;
+	int ret = -EIO, i;
+	struct ucom_dev *ucom=NULL;
+	unsigned long arg=0;
+	if(cp_exception_sts){
+		skwboot_log("%s line:%d the modem assert \n", __func__,__LINE__);
+		return ret;
+	}
+	char_dev = ip->i_cdev;
+	for(i=0; i< UCOM_PORTNO_MAX; i++) {
+		if(ucoms[i] && (ucoms[i]->devno == char_dev->dev)) {
+			ucom = ucoms[i];
+			ret = 0;
+			break;
+		}
+	}
+
+	if(ucom) {
+		if(atomic_read(&ucom->open) > 1){
+			printk("%s ,%d\n", __func__, __LINE__);
+			return -EBUSY;
+		}
+		atomic_inc(&ucom->open);
+		init_waitqueue_head(&ucom->wq);
+		spin_lock_init(&ucom->lock);
+		ucom->pdata->open_port(ucom->portno, NULL, NULL);
+		fp->private_data = ucom;
+		printk("%s: ucom[%d] %s(0x%x)\n", __func__, i, ucom->pdata->port_name, ucom->portno);
+
+		if(!strncmp((char *)ucom->pdata->chipid,"SV6160",6))
+			arg = 0x6160;
+		else if(!strncmp((char *)ucom->pdata->chipid,"SV6316", 6))
+			arg = 0x6316;
+	}
+	tmp_chipid = arg;
+	skwboot_log("the portno=%d - chipid = 0x%lx \n",ucom->portno, arg);
+
+	return ret;
+}
+
+static int ucom_release(struct inode *ip, struct file *fp)
+{
+	struct ucom_dev *ucom = fp->private_data;
+	int i;
+
+	for(i=0; i< UCOM_PORTNO_MAX; i++) {
+		if(ucoms[i] == ucom)
+			break;
+	}
+	fp->private_data = NULL;
+	if(ucom && (i<UCOM_PORTNO_MAX)) {
+		printk("%s: ucom%p %s(0x%x)\n", __func__, ucom, ucom->pdata->port_name, ucom->devno);
+		if (atomic_read(&ucom->open)) {
+			atomic_dec(&ucom->open);
+			if(strncmp(ucom->pdata->port_name, "LOG", 3) && strncmp(ucom->pdata->port_name, "ATC", 3))
+				ucom->pdata->close_port(ucom->portno);
+			wake_up(&ucom->wq);
+		} else
+			kfree(ucom);
+	}
+	return 0;
+}
+
+static ssize_t ucom_read(struct file *fp, char __user *buf, size_t count, loff_t *pos)
+{
+	struct ucom_dev *ucom = fp->private_data;
+	ssize_t r = count;
+	int ret;
+	unsigned long flags;
+	uint32_t *data;
+
+	if(cp_exception_sts || atomic_read(&ucom->open)==0)
+		return -EIO;
+	spin_lock_irqsave(&ucom->lock, flags);
+	if(ucom->rx_busy) {
+		spin_unlock_irqrestore(&ucom->lock, flags);
+		return -EAGAIN;
+	}
+	ucom->rx_busy = 1;
+	if(count > ucom->pdata->max_buffer_size)
+		count = ucom->pdata->max_buffer_size;
+	spin_unlock_irqrestore(&ucom->lock, flags);
+	ret = ucom->pdata->hw_sdma_rx(ucom->portno, ucom->rx_buf, count);
+	ucom->rx_busy = 0;
+	data = (uint32_t *)ucom->rx_buf;
+
+	if(ret > 0) {
+		r = ret;
+		if(ret > count)
+			ret = copy_to_user(buf, ucom->rx_buf, count);
+		else
+			ret = copy_to_user(buf, ucom->rx_buf, ret);
+		if(ret > 0)
+			return -EFAULT;
+	} else	r = ret;
+	pr_debug("%s %s ret = %d\n", __func__,current->comm, (int)r);
+	return r;
+}
+
+static ssize_t ucom_write(struct file *fp, const char __user *buf, size_t count, loff_t *pos)
+{
+	struct ucom_dev *ucom = fp->private_data;
+	int ret = 0;
+	ssize_t r = count;
+	ssize_t size;
+	unsigned long flags;
+
+	if(cp_exception_sts || atomic_read(&ucom->open)==0)
+		return -EIO;
+	spin_lock_irqsave(&ucom->lock, flags);
+	if(ucom->tx_busy) {
+		spin_unlock_irqrestore(&ucom->lock, flags);
+		printk("%s error 0\n", __func__);
+		return -EAGAIN;
+	}
+	ucom->tx_busy = 1;
+	spin_unlock_irqrestore(&ucom->lock, flags);
+	while(count){
+		if(count > ucom->pdata->max_buffer_size)
+			size =  ucom->pdata->max_buffer_size;
+		else
+			size = count;
+		if(copy_from_user(ucom->tx_buf, buf, size))
+			return -EFAULT;
+
+		if(!strncmp(ucom->pdata->port_name, "LOG", 3)){
+			if(!strncmp(ucom->tx_buf, "START", 5)){
+				skwboot_log("%s START log to file \n", __func__);
+				skw_modem_log_init(ucom->pdata, NULL, (void *)ucom);
+			}
+			else if(!strncmp(ucom->tx_buf, "STOP", 4)){
+				skwboot_log("%s STOP log to file \n", __func__);
+				skw_modem_log_exit();
+			}
+			else
+				skwboot_log("%s LOG write string:%s \n", __func__, ucom->tx_buf);
+			ucom->tx_busy = 0;
+			return r;
+		}
+		if (ucom->pdata->port_name && !strncmp(ucom->pdata->port_name, "ATC", 3)) {
+			 ucom->tx_buf[size++] = 0x0D;
+			 ucom->tx_buf[size++] = 0x0A;
+			 count += 2;
+		}
+		ret = ucom->pdata->hw_sdma_tx(ucom->portno, ucom->tx_buf, size);
+
+		if(ret < 0){
+			printk("the close the ucom tx_busy=0");
+			ucom->tx_busy=0;
+			return ret;
+		}
+		count -= ret;
+		buf += ret;
+	}
+	ucom->tx_busy = 0;
+	pr_debug("%s %s ret = %d\n", __func__,current->comm,(int)r);
+	return r;
+}
+
+static long ucom_ioctl(struct file *fp, unsigned int cmd, unsigned long arg)
+{
+	struct ucom_dev *ucom = fp->private_data;
+	int i;
+
+	for(i=0; i< UCOM_PORTNO_MAX; i++) {
+		if(ucoms[i] == ucom)
+			break;
+	}
+	if((i<UCOM_PORTNO_MAX) && atomic_read(&ucom->open)) {
+		printk("%s ucom_%p rx_busy=%d\n", __func__, ucom, ucom->rx_busy);
+		if (ucom->pdata)
+			ucom->pdata->close_port(ucom->portno);
+	}
+	return 0;
+}
+#ifdef CONFIG_COMPAT
+static long ucom_compat_ioctl(struct file *fp, unsigned int cmd, unsigned long arg)
+{
+	return ucom_ioctl(fp, cmd, (unsigned long)compat_ptr(arg));
+}
+#endif
+static ssize_t boot_read(struct file *fp, char __user *buf, size_t count, loff_t *pos)
+{
+	u32 status;
+	struct ucom_dev *ucom = fp->private_data;
+	int ret = 0;
+
+	ret = ucom->pdata->hw_sdma_rx(ucom->portno, (char *)&status, 4);
+	if (ret > 0)
+		ret = copy_to_user(buf, &status, ret);
+	return ret;
+}
+
+
+static ssize_t boot_write(struct file *fp, const char __user *buf, size_t count, loff_t *pos)
+{
+	struct ucom_dev *ucom = fp->private_data;
+	int ret = 0;
+	ret = ucom->pdata->hw_sdma_tx(ucom->portno, "WAKE", 4);
+	if(ret > 0)
+		return count;
+
+	return ret;
+}
+static long boot_ioctl(struct file *fp, unsigned int cmd, unsigned long arg)
+{
+	struct ucom_dev *ucom = fp->private_data;
+	unsigned char cp_log_state = 0;
+	int ret = 0;
+	switch (cmd) {
+		case 0:
+			ret = copy_to_user((char*)arg, (char*)&tmp_chipid, 4);
+			skwboot_log("the orgchip = %s ,the chipid = 0x%x\n",(char *)ucom->pdata->chipid, tmp_chipid);
+			break;
+		case _IOWR('S', 1, uint8_t *):
+			break;
+		case _IOWR('S', 2, uint8_t *):
+#ifdef CONFIG_SEEKWAVE_PLD_RELEASE
+			cp_log_state =1; //close log
+			//skw_sdio_cp_log(1);
+#else
+			cp_log_state = 2;//open log
+#endif
+			ret = copy_to_user((char*)arg, (char*)&cp_log_state, 1);
+			skwboot_log("the cp_log_state = %d \n", cp_log_state);
+			break;
+	}
+	return 0;
+}
+
+#ifdef CONFIG_COMPAT
+static long boot_compat_ioctl(struct file *fp, unsigned int cmd, unsigned long arg)
+{
+	return boot_ioctl(fp, cmd, (unsigned long)compat_ptr(arg));
+}
+#endif
+
+static const struct file_operations skw_ucom_ops = {
+	.owner	= THIS_MODULE,
+	.open	= ucom_open,
+	.read	= ucom_read,
+	.write	= ucom_write,
+	.unlocked_ioctl = ucom_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = ucom_compat_ioctl,
+#endif
+	.release= ucom_release,
+};
+static const struct file_operations skw_user_boot_ops = {
+	.owner	= THIS_MODULE,
+	.open	= user_boot_open,
+	.read	= boot_read,
+	.write	= boot_write,
+	.unlocked_ioctl = boot_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = boot_compat_ioctl,
+#endif
+	.release= user_boot_release,
+};
+
+static int skw_ucom_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct sv6160_platform_data *pdata = dev->platform_data;
+	struct ucom_dev	*ucom;
+	int ret = 0;
+
+	if(skw_com_class == NULL) {
+		skw_com_class = class_create(THIS_MODULE, "btcom");
+		if(IS_ERR(skw_com_class)) {
+			ret =  PTR_ERR(skw_com_class);
+			skw_com_class = NULL;
+			return ret;
+		}
+	}
+	if (pdata) {
+		ucom = kzalloc(sizeof(struct ucom_dev), GFP_KERNEL);
+		if(!ucom)
+			return -ENOMEM;
+		if (strncmp(pdata->port_name, "BTBOOT", 6)) {
+			ucom->rx_buf = kzalloc(pdata->max_buffer_size, GFP_KERNEL);
+			if(ucom->rx_buf) {
+				ucom->tx_buf = kzalloc(pdata->max_buffer_size, GFP_KERNEL);
+				if(!ucom->tx_buf) {
+					kfree(ucom->rx_buf);
+					kfree(ucom);
+					return -ENOMEM;
+				}
+			}else{
+				kfree(ucom);
+				return -ENOMEM;
+			}
+			ret =__register_chrdev(skw_major, pdata->data_port+1, 1, pdata->port_name, &skw_ucom_ops);
+		} else {
+			pdata->data_port = UCOM_PORTNO_MAX - 1;
+			ret =__register_chrdev(skw_major, UCOM_PORTNO_MAX, 1,
+					pdata->port_name, &skw_user_boot_ops);
+		}
+		if(ret < 0) {
+			kfree(ucom->rx_buf);
+			kfree(ucom->tx_buf);
+			kfree(ucom);
+			return ret;
+		}
+		if(skw_major == 0)
+			skw_major = ret;
+		ucom->devno = MKDEV(skw_major, pdata->data_port+1);
+		skwlog_log("register char device:%s:%s %d:%d\n",
+				pdata->port_name, dev_name(&pdev->dev), skw_major, pdata->data_port+1);
+		ucom->pdata = pdata;
+		ucom->portno = pdata->data_port;
+		atomic_set(&ucom->open, 0);
+		platform_set_drvdata(pdev, ucom);
+		ucoms[ucom->portno] = ucom;
+		device_create(skw_com_class, NULL, ucom->devno, NULL, "%s", pdata->port_name);
+		if(ucom){
+			if(!strncmp(ucom->pdata->port_name, "BTCMD", 5)){
+				skw_bt_state_event_init(ucom);
+			}
+		}
+		return 0;
+	}
+	return -EINVAL;
+}
+
+static int skw_ucom_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct sv6160_platform_data *pdata = dev->platform_data;
+	struct ucom_dev *ucom;
+	int ret, i;
+	int devno;
+
+	ucom = platform_get_drvdata(pdev);
+	if(!strncmp(ucom->pdata->port_name, "LOG", 3))
+		skw_modem_log_exit();
+
+	if(ucom) {
+		if(!strncmp(ucom->pdata->port_name, "BTCMD", 5)) {
+			if (ucom->rx_busy && ucom->pdata) {
+				ucom->pdata->close_port(ucom->portno);
+			}
+			skw_bt_state_event_deinit(ucom);
+		}
+		ret = wait_event_interruptible_timeout(ucom->wq,
+				(!atomic_read(&ucom->open)),
+				msecs_to_jiffies(1000));
+
+		printk("%s: ucom%p %s(0x%x) -- open_count=%d \n", __func__, ucom, ucom->pdata->port_name, ucom->devno,atomic_read(&ucom->open));
+
+		ucom->pdata = NULL;
+		devno = ucom->devno;
+		device_destroy(skw_com_class, devno);
+		ucoms[ucom->portno] = NULL;
+		kfree(ucom->rx_buf);
+		ucom->rx_buf = NULL;
+		kfree(ucom->tx_buf);
+		ucom->tx_buf = NULL;
+		if (!atomic_read(&ucom->open))
+			kfree(ucom);
+		else
+			atomic_set(&ucom->open, 0);
+		__unregister_chrdev(MAJOR(devno), MINOR(devno), 1,  pdata->port_name);
+		platform_set_drvdata(pdev, NULL);
+	}
+	for(i=0; i<UCOM_PORTNO_MAX; i++) {
+		if(ucoms[i])
+			break;
+	}
+	if(i>=UCOM_PORTNO_MAX) {
+		class_destroy(skw_com_class);
+		skw_com_class = NULL;
+	}
+	return 0;
+}
+
+static struct platform_driver skw_ucom_driver = {
+	.driver = {
+		.name	= (char*)"skw_ucom",
+		.bus	= &platform_bus_type,
+		.pm	= UCOM_DEV_PM_OPS,
+	},
+	.probe = skw_ucom_probe,
+	.remove = skw_ucom_remove,
+};
+
+int skw_ucom_init(void)
+{
+
+	platform_driver_register(&skw_ucom_driver);
+	return 0;
+}
+
+void skw_ucom_exit(void)
+{
+	cp_exception_sts=0;
+	platform_driver_unregister(&skw_ucom_driver);
+}
diff --git a/drivers/misc/seekwaveplatform_v20/usb/Kconfig b/drivers/misc/seekwaveplatform_v20/usb/Kconfig
new file mode 100755
index 000000000000..9649a5bf1b21
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/usb/Kconfig
@@ -0,0 +1,10 @@
+config SKW_USB
+	tristate "SeekWave USB Support"
+	depends on USB ||COMPILE_TEST ||SEEKWAVE_BSP_DRIVERS_V20
+	default n
+	help
+	  Enable this module for WCN_USB
+	  chip usb interface bus Support.
+	  Please insmod this module before any other
+	  WCN subsystems. Thanks.
+
diff --git a/drivers/misc/seekwaveplatform_v20/usb/README.md b/drivers/misc/seekwaveplatform_v20/usb/README.md
new file mode 100755
index 000000000000..8d12f18c5e3d
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/usb/README.md
@@ -0,0 +1,2 @@
+#seekwave tech usb drivers
+
diff --git a/drivers/misc/seekwaveplatform_v20/usb/skw_usb.h b/drivers/misc/seekwaveplatform_v20/usb/skw_usb.h
new file mode 100755
index 000000000000..d229374dfe22
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/usb/skw_usb.h
@@ -0,0 +1,37 @@
+#ifndef WCN_USB_H
+#define WCN_USB_H
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kref.h>
+#include <linux/uaccess.h>
+#include <linux/usb.h>
+#include <linux/mutex.h>
+#include <linux/bitops.h>
+#include <linux/kthread.h>
+#include <linux/notifier.h>
+#include "../skwutil/skw_boot.h"
+
+#define skwusb_log(fmt, args...) \
+	pr_info("[SKW_USB]:" fmt, ## args)
+
+#define skwusb_err(fmt, args...) \
+	pr_err("[SKW_USB_ERR]:" fmt, ## args)
+
+#define skwusb_data_pr(level, prefix_str, prefix_type, rowsize,\
+		groupsize, buf, len, asscii)\
+		do{if(loglevel) \
+			print_hex_dump(level, prefix_str, prefix_type, rowsize,\
+					groupsize, buf, len, asscii);\
+		}while(0)
+
+
+#define USB_RX_TASK_PRIO 90
+#define SKW_CHIP_ID_LENGTH			16  //SV6160 chip id lenght
+
+int skw_usb_recovery_debug(int disable);
+int skw_usb_recovery_debug_status(void);
+void reboot_to_change_bt_uart1(char *mode);
+#endif
diff --git a/drivers/misc/seekwaveplatform_v20/usb/skw_usb_debugfs.c b/drivers/misc/seekwaveplatform_v20/usb/skw_usb_debugfs.c
new file mode 100755
index 000000000000..25ca5c6e2372
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/usb/skw_usb_debugfs.c
@@ -0,0 +1,60 @@
+/*****************************************************************************
+ * Copyright(c) 2020-2030  Seekwave Corporation.
+ * SEEKWAVE TECH LTD..CO
+ *Seekwave Platform the usb log debug fs
+ *FILENAME:skw_usb_debugfs.c
+ *DATE:2022-04-11
+ *MODIFY:
+ *
+ **************************************************************************/
+
+#include "skw_usb_debugfs.h"
+#include "skw_usb_log.h"
+#include "skw_usb.h"
+
+static struct dentry *skw_usb_root_dir;
+
+static ssize_t skw_usb_default_read(struct file *fp, char __user *buf, size_t len,
+				loff_t *offset)
+{
+	return 0;
+}
+
+static ssize_t skw_usb_state_write(struct file *fp, const char __user *buffer,
+				size_t len, loff_t *offset)
+{
+	return len;
+}
+
+static const struct file_operations skw_usb_state_fops = {
+	.open = skw_usb_default_open,
+	.read = skw_usb_default_read,
+	.write = skw_usb_state_write,
+};
+
+struct dentry *skw_usb_add_debugfs(const char *name, umode_t mode, void *data,
+			       const struct file_operations *fops)
+{
+	skw_usb_dbg("%s:name: %s\n",__func__,name);
+
+	return debugfs_create_file(name, mode, skw_usb_root_dir, data, fops);
+}
+
+int skw_usb_debugfs_init(void)
+{
+	skw_usb_root_dir = debugfs_create_dir("skwusb", NULL);
+	if (IS_ERR(skw_usb_root_dir))
+		return PTR_ERR(skw_usb_root_dir);
+
+	// skw_usb_add_debugfs("state", 0666, wiphy, &skw_usb_state_fops);
+	// skw_usb_add_debugfs("log_level", 0444, wiphy, &skw_usb_log_fops);
+
+	return 0;
+}
+
+void skw_usb_debugfs_deinit(void)
+{
+	skw_usb_dbg("%s :traced\n", __func__);
+
+	debugfs_remove_recursive(skw_usb_root_dir);
+}
diff --git a/drivers/misc/seekwaveplatform_v20/usb/skw_usb_debugfs.h b/drivers/misc/seekwaveplatform_v20/usb/skw_usb_debugfs.h
new file mode 100755
index 000000000000..e5a6161ee442
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/usb/skw_usb_debugfs.h
@@ -0,0 +1,29 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2020-2030  Seekwave Corporation.
+ *
+ *****************************************************************************/
+#ifndef __SKW_USB_DEBUGFS_H__
+#define __SKW_USB_DEBUGFS_H__
+
+#include <linux/fs.h>
+#include <linux/debugfs.h>
+
+static inline int skw_usb_default_open(struct inode *node, struct file *fp)
+{
+	fp->private_data = node->i_private;
+	return 0;
+}
+
+static inline void  skw_usb_remove_debugfs(struct dentry *dentry)
+{
+	debugfs_remove(dentry);
+}
+
+struct dentry *skw_usb_add_debugfs(const char *name, umode_t mode, void *data,
+			       const struct file_operations *fops);
+
+int skw_usb_debugfs_init(void);
+void skw_usb_debugfs_deinit(void);
+
+#endif
diff --git a/drivers/misc/seekwaveplatform_v20/usb/skw_usb_io.c b/drivers/misc/seekwaveplatform_v20/usb/skw_usb_io.c
new file mode 100755
index 000000000000..213ff1b850a1
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/usb/skw_usb_io.c
@@ -0,0 +1,2639 @@
+/************************************************************************
+ *Copyright(C) 2020-2021: Seekwave tech LTD 		China
+ *Decription:
+ *Author:jiayong.yang
+ *Date:2021-05-27
+ *Modfiy:
+ *
+ ********************************************************************* */
+#include <linux/platform_device.h>
+#include <linux/scatterlist.h>
+#include <linux/dma-mapping.h>
+#include <linux/version.h>
+#include <linux/notifier.h>
+#include <linux/semaphore.h>
+#include <linux/pm_runtime.h>
+#include <linux/kthread.h>
+#include <linux/module.h>
+#include <linux/list.h>
+#include <linux/err.h>
+#include <linux/wait.h>
+#include <linux/gpio.h>
+#include "skw_usb.h"
+#include "skw_usb_log.h"
+#include "skw_usb_debugfs.h"
+#ifdef CONFIG_SV6160_LITE_FPGA
+#define MAX_BUFFER_SIZE 12*1024
+#else
+#define MAX_BUFFER_SIZE 23*1024
+#endif
+#define MAX_MSG_SIZE	MAX_BUFFER_SIZE
+
+#define VENDOR_MSG_MODEM_ASSERT 0xA5
+#define VENDOR_MSG_SERVICE_CTRL 0xA6
+#define VENDOR_MSG_PACKET_COUNT 0xA7
+#define VENDOR_MSG_LOG_SWITCH	0xA8
+#define VENDOR_MSG_MODEM_RESET  0xA9
+#define	WIFI_SERVICE	0
+#define BT_SERVICE	  1
+
+#define SERVICE_START	0
+#define SERVICE_STOP	1
+
+#define MODEM_OFF		0
+#define MODEM_ON		1
+#define MODEM_HALT		2
+
+#define WIFI_PORT_SHARE_FLAG	0x4000
+#define USB_HOST_RESUME_SUPPORT 0x20
+
+#define MAX_USB_PORT MAX_PORT_COUNT
+#define MAX_PACKET_COUNT 20
+static struct delayed_work skw_except_work;
+static struct work_struct add_device_work;
+static struct platform_device *wifi_data_pdev;
+static u64 port_dmamask = DMA_BIT_MASK(32);
+static u32 service_state_map = 0;
+static int cp_log_status = 0;
+static char *firmware_data;
+static int	firmware_size;
+static int	firmware_addr;
+static struct seekwave_device *usb_boot_data;
+static struct completion download_done;
+static struct completion loop_completion;
+static BLOCKING_NOTIFIER_HEAD(modem_notifier_list);
+static int chip_en_gpio;
+static int host_wake_gpio;
+static int modem_status;
+static int usb_speed_switching;
+static int cls_recovery_mode_en;
+static char *skw_chipid;
+static u32 last_sent_wifi_cmd[3];
+static u32 last_recv_wifi_evt[3];
+static u32 last_recv_wifi_ack[3];
+static u64 last_sent_time, last_ack_time;
+static struct scatterlist *sgs;
+static int nr_sgs;
+static int start_service_flag = 0;
+/************************************************************************
+ *Decription:
+ *Author:jiayong.yang
+ *Date:2021-05-27
+ *Modfiy:
+ *
+ ********************************************************************* */
+
+static const struct usb_device_id skw_usb_io_id_table[] = {
+	{USB_VENDOR_AND_INTERFACE_INFO(0x3607, 0x02, 0x02, 0)},
+	{ USB_DEVICE(0x0483, 0x5720) },
+	{ USB_DEVICE(0x0483, 0x5721) },
+	{ USB_DEVICE(0x3607, 0x6316) },
+	{ USB_DEVICE(0x3607, 0x6160) },
+	{}	/* Terminating entry */
+};
+/************************************************************************
+ *Decription:
+ *Author:jiayong.yang
+ *Date:2021-05-27
+ *Modfiy:
+ *
+ ********************************************************************* */
+static struct recovery_data{
+	struct mutex except_mutex;
+	int cp_state;
+} g_recovery_data;
+
+#ifdef CONFIG_SKW_DL_TIME_STATS
+	ktime_t cur_time,last_time;
+#endif
+
+#define SKW_USB_GET_RECOVERY_DATA() &g_recovery_data
+
+struct usb_port_struct {
+	struct work_struct work;
+	struct platform_device *pdev;
+	int	portno;
+	struct usb_interface *interface;
+	struct usb_device *udev;
+	struct urb *read_urb;
+	struct usb_endpoint_descriptor *epin;
+	struct urb *write_urb;
+	struct usb_endpoint_descriptor *epout;
+	char *read_buffer;
+	char	*write_buffer;
+	int		buffer_size;
+	struct usb_anchor read_submitted;
+	struct usb_anchor write_submitted;
+	struct task_struct *thread;
+	rx_submit_fn rx_submit;
+	adma_callback adma_tx_callback;
+	sdma_callback sdma_tx_callback;
+	void *rx_data;
+	void *tx_data;
+	int	state;
+	int  ep_mps;
+	int  max_packet_count;
+	struct semaphore sem;
+	int	is_dloader;
+	int	sent_packet_count;
+	int	req_tx_packet;
+	wait_queue_head_t	rx_wait;
+	wait_queue_head_t	tx_wait;
+	struct tasklet_struct tasklet;
+	struct list_head rx_urb_list;
+	struct list_head tx_urb_list;
+	struct list_head rx_done_urb_list;
+	struct list_head suspend_urb_list;
+	spinlock_t rx_urb_lock;
+	spinlock_t tx_urb_lock;
+	int	tx_urb_count;
+	int	rx_packet_count;
+	int     suspend;
+	u64     rx_complete_time;
+	u64     parser_time[4];
+	u64     tx_time[2];
+} *usb_ports[MAX_USB_PORT];
+
+static int modem_assert(void);
+static int skw_recovery_mode(void);
+static struct usb_port_struct *log_port;
+extern void kernel_restart(char *cmd);
+static int bulkin_read_timeout(int portno, char *buffer, int size, int *actual, int timeout);
+static int bulkout_write_timeout(int portno, char *buffer, int size, int *actual, int timeout);
+static void bulkout_async_complete(struct urb *urb);
+static void bulkin_async_complete(struct urb *urb);
+static int assert_info_print;
+#ifdef CONFIG_WAKELOCK
+static	struct wake_lock usb_wakelock;
+#else
+static	struct wakeup_source *usb_wakelock;
+#endif
+static int    wakelocked;
+static int usb_bt_rx_entry(void *para);
+char firmware_version[128];
+int	bt_audio_port;
+struct platform_device *bluetooth_pdev;
+static int wifi_port_share;
+static int bulk_async_read;
+
+void skw_get_port_statistic(char *buffer, int size)
+{
+	int ret = 0;
+	int i;
+
+	if(!buffer)
+		return;
+
+	for(i=0; i<2; i++) {
+		if(ret >= size)
+			break;
+
+		ret += sprintf(&buffer[ret],
+			"port%d: req_tx %d tx_done %d, rx %d\n",
+			i, usb_ports[i]->req_tx_packet,
+			usb_ports[i]->sent_packet_count,
+			usb_ports[i]->rx_packet_count);
+	}
+}
+
+#include "usb_boot.c"
+void modem_register_notify(struct notifier_block *nb)
+{
+	blocking_notifier_chain_register(&modem_notifier_list, nb);
+}
+void modem_unregister_notify(struct notifier_block *nb)
+{
+	blocking_notifier_chain_unregister(&modem_notifier_list, nb);
+}
+static void modem_notify_event(int event)
+{
+	blocking_notifier_call_chain(&modem_notifier_list, event, NULL);
+}
+static void skw_usb_wakeup_source_init(void)
+{
+#ifdef CONFIG_WAKELOCK
+	wake_lock_init(&usb_wakelock, WAKE_LOCK_SUSPEND,"skw_usb_wakelock");
+#else
+	usb_wakelock =  skw_wakeup_source_register(NULL, "skw_usb_wakelock");
+#endif
+	wakelocked = 0;
+}
+static void skw_usb_wakeup_source_destroy(void)
+{
+#ifdef CONFIG_WAKELOCK
+	wake_lock_destroy(&usb_wakelock);
+#else
+	wakeup_source_unregister(usb_wakelock);
+#endif
+}
+static void skw_usb_wake_lock(void)
+{
+	if (wakelocked)
+		return;
+	wakelocked = 1;
+#ifdef CONFIG_WAKELOCK
+	__pm_stay_awake(&usb_wakelock.ws);
+#else
+	__pm_stay_awake(usb_wakelock);
+#endif
+}
+static void skw_usb_wake_unlock(void)
+{
+	if (!wakelocked)
+		return;
+	wakelocked = 0;
+#ifdef CONFIG_WAKELOCK
+	__pm_relax(&usb_wakelock.ws);
+#else
+	__pm_relax(usb_wakelock);
+#endif
+}
+
+void skw_usb_exception_work(struct work_struct *work)
+{
+	struct recovery_data *recovery = SKW_USB_GET_RECOVERY_DATA();
+	skw_usb_info(" enter cp_state=%d...\n", recovery->cp_state);
+	mutex_lock(&recovery->except_mutex);
+	if(recovery->cp_state!=1)
+	{
+		mutex_unlock(&recovery->except_mutex);
+		return;
+	}
+	skw_usb_wake_lock();
+	recovery->cp_state = DEVICE_BLOCKED_EVENT;
+	mutex_unlock(&recovery->except_mutex);
+	modem_notify_event(DEVICE_BLOCKED_EVENT);
+	service_state_map=0;
+	skw_recovery_mode();
+}
+
+int skw_usb_recovery_debug(int disable)
+{
+	cls_recovery_mode_en = disable;
+	skw_usb_info("the recovery status =%d\n", cls_recovery_mode_en);
+	return 0;
+}
+
+int skw_usb_recovery_debug_status(void)
+{
+	skw_usb_info("the recovery val =%d\n", cls_recovery_mode_en);
+	return cls_recovery_mode_en;
+}
+
+
+static void usb_setup_service_devices(void)
+{
+	struct usb_port_struct *bt_port;
+	int ret;
+
+	skw_bind_boot_driver(&usb_ports[0]->udev->dev);
+	if(usb_ports[1]->pdev){
+		if(wifi_data_pdev==NULL) {
+			wifi_data_pdev = usb_ports[1]->pdev;                  
+			ret = platform_device_add(usb_ports[1]->pdev);
+			if(ret) {
+				skw_usb_err("the fail to register WIFI device\n");
+				wifi_data_pdev = NULL;
+				platform_device_put(usb_ports[1]->pdev);
+			} else {
+				skw_usb_info("add WIFI devices done\n");
+			}
+		 }
+	} else
+		 skw_usb_err("NOT suppport WIFI service\n");
+
+	if (bluetooth_pdev) {
+		bt_port = usb_ports[bt_audio_port];
+		bt_port->pdev = bluetooth_pdev;
+		bluetooth_pdev = NULL;
+		ret = platform_device_add(bt_port->pdev);
+		if(ret) {
+			dev_err(&bt_port->udev->dev, "failt to register Bluetooth device\n");
+			platform_device_put(bt_port->pdev);
+			bt_port->pdev = NULL;
+		} else
+			skw_usb_info("add Bluetooth devices done\n");
+	}
+
+}
+void add_devices_work(struct work_struct *work)
+{
+	usb_setup_service_devices();
+}
+void skw_set_bt_suspend_flag(void)
+{
+}
+static void usb_port_alloc_recv_urbs(struct usb_port_struct *port, struct usb_endpoint_descriptor *epd, int count, int buffer_size)
+{
+	int i;
+	struct urb *urb;
+
+	for(i=0; i<count; i++) {
+		urb = usb_alloc_urb(0, GFP_KERNEL);
+		if(!urb)
+			break;
+		if(!buffer_size) {
+			urb->transfer_buffer = NULL;
+			urb->transfer_buffer_length = 0;
+		} else{
+			urb->transfer_buffer = kzalloc(buffer_size, GFP_KERNEL);
+			if(!urb->transfer_buffer) {
+				usb_free_urb(urb);
+				break;
+			}
+			urb->transfer_buffer_length = buffer_size;
+		}
+		usb_fill_bulk_urb(urb, port->udev,usb_rcvbulkpipe(port->udev, epd->bEndpointAddress),
+			urb->transfer_buffer, buffer_size, bulkin_async_complete, NULL);
+		list_add_tail(&urb->urb_list, &port->rx_urb_list);
+	}
+	skw_usb_dbg("%s urb cout %d\n", __func__, i);
+}
+
+static void usb_port_alloc_xmit_urbs(struct usb_port_struct *port, struct usb_endpoint_descriptor *epd, int count, int buffer_size)
+{
+	int i;
+	struct urb *urb;
+
+	for(i=0; i<count; i++) {
+		urb = usb_alloc_urb(0, GFP_KERNEL);
+		if(!urb)
+			break;
+		if(!buffer_size) {
+			urb->transfer_buffer = NULL;
+			urb->transfer_buffer_length = 0;
+		} else{
+			urb->transfer_buffer = kzalloc(buffer_size, GFP_KERNEL);
+			if(!urb->transfer_buffer) {
+				usb_free_urb(urb);
+				break;
+			}
+			urb->transfer_buffer_length = buffer_size;
+		}
+		usb_fill_bulk_urb(urb, port->udev,usb_sndbulkpipe(port->udev, epd->bEndpointAddress),
+			urb->transfer_buffer, buffer_size, bulkout_async_complete, NULL);
+		list_add_tail(&urb->urb_list, &port->tx_urb_list);
+	}
+	skw_usb_dbg("%s urb cout %d\n", __func__, i);
+}
+
+/************************************************************************
+ *Decription:
+ *Author:jiayong.yang
+ *Date:2021-05-27
+ *Modfiy:
+ *
+ ********************************************************************* */
+int open_usb_port(int id, void *callback, void *data)
+{
+	struct usb_port_struct *port;
+
+	if(id >= MAX_USB_PORT)
+		return -EINVAL;
+
+	port = usb_ports[id];
+	if(port->state==0)
+		return -EIO;
+	if (port->state==1) {
+		init_usb_anchor(&port->read_submitted);
+		init_usb_anchor(&port->write_submitted);
+	}
+	port->state = 2;
+	port->rx_submit = callback;
+	port->rx_data = data;
+	if(callback && data && !port->thread) {
+		sema_init(&port->sem, 0);
+		port->thread = kthread_create(usb_bt_rx_entry, port, port->interface->cur_altsetting->string);
+		if(port->thread)
+			wake_up_process(port->thread);
+	}
+	return 0;
+}
+/************************************************************************
+ *Decription:
+ *Author:jiayong.yang
+ *Date:2021-05-27
+ *Modfiy:
+ *
+ ********************************************************************* */
+static int  bulkin_read(struct usb_port_struct *port, void *buffer, int size)
+{
+	int retval = -1;
+	DECLARE_COMPLETION_ONSTACK(done);
+	if(port->state==0)
+		return -EIO;
+
+	if(port == log_port){
+		memset(buffer, 0 , size);
+	}
+
+	if(port->read_urb) {
+		port->read_urb->transfer_buffer = buffer;
+		port->read_urb->transfer_buffer_length = size;
+		port->read_urb->context = &done;
+		usb_anchor_urb(port->read_urb, &port->read_submitted);
+		retval = usb_submit_urb(port->read_urb,GFP_KERNEL);
+		if(retval==0) {
+			retval = wait_for_completion_interruptible(&done);
+			if(retval == -ERESTARTSYS)
+				usb_kill_urb(port->read_urb);
+			else if(port->read_urb->status)
+				retval = port->read_urb->status;
+			else if(retval==0)
+				retval = port->read_urb->actual_length;
+			port->read_urb->context = NULL;
+		} else {
+			 if (retval < 0)
+				 usb_unanchor_urb(port->read_urb);
+			port->read_urb->context = NULL;
+		}
+	}
+	if(port == log_port) {
+		if(assert_info_print && assert_info_print<28 && retval<100) {
+			assert_info_print++;
+			if(retval > 4)
+				printk("%s", (char *)buffer);
+		}
+		if(retval == 4)
+			assert_info_print = 28;
+	}
+	return retval;
+}
+int skw_bus_version(void)
+{
+	printk("USB bus Version1.0\n");
+	return 0;
+}
+int bulkin_read_async(struct usb_port_struct *port)
+{
+	int	 retval = -1;
+	unsigned long flags;
+	struct urb *urb;
+
+	spin_lock_irqsave(&port->rx_urb_lock, flags);
+	urb = list_first_entry(&port->rx_urb_list, struct urb, urb_list);
+	list_del_init(&urb->urb_list);
+	bulk_async_read++;
+	spin_unlock_irqrestore(&port->rx_urb_lock, flags);
+	if(urb->context) {
+		skw_usb_info("port is busy!!!\n");
+		return -EBUSY;
+	}
+
+	urb->complete = bulkin_async_complete;
+	urb->context = port;
+	if (port->suspend)
+		list_add_tail(&urb->urb_list, &port->suspend_urb_list);
+	else {
+		usb_anchor_urb(urb, &port->read_submitted);
+		retval = usb_submit_urb(urb, GFP_ATOMIC);
+		if (retval < 0) {
+			usb_unanchor_urb(urb);
+			dev_info(&port->pdev->dev, "%s is error!!! %d\n", __func__, retval);
+			list_add_tail(&urb->urb_list, &port->suspend_urb_list);
+		} else if (jiffies - port->rx_complete_time > 100)
+			dev_info(&port->pdev->dev, "%s warnings time:%llu-%llu-%llu-%llu-%llu-%llu\n", __func__,
+				(u64)jiffies, port->parser_time[3], port->parser_time[2], port->parser_time[1],
+				port->parser_time[0], port->rx_complete_time);
+	}
+	return retval;
+}
+/************************************************************************
+ *Decription:
+ *Author:jiayong.yang
+ *Date:2021-05-27
+ *Modfiy:
+ *
+ ********************************************************************* */
+static int bulkout_write(struct usb_port_struct *port, void *buffer, int size)
+{
+	int retval = -1;
+	DECLARE_COMPLETION_ONSTACK(done);
+
+	if (port->suspend) {
+		skw_usb_info("port%d is suspended\n", port->portno);
+		return -EOPNOTSUPP;
+	}
+	if (port && port->write_urb && !port->write_urb->context) {
+		port->write_urb->transfer_buffer = buffer;
+		port->write_urb->transfer_buffer_length = size;
+		if(size%port->ep_mps == 0)
+			port->write_urb->transfer_flags |= URB_ZERO_PACKET;
+		port->write_urb->context = &done;
+		usb_anchor_urb(port->write_urb, &port->write_submitted);
+		retval = usb_submit_urb(port->write_urb,GFP_KERNEL);
+		if(retval==0) {
+			retval = wait_for_completion_interruptible(&done);
+			if(retval==-ERESTARTSYS)
+				usb_kill_urb(port->write_urb);
+			else if (port->write_urb->status)
+				retval = port->write_urb->status;
+			else
+				retval = port->write_urb->actual_length;
+			port->write_urb->context = NULL;
+		} else {
+
+			if (retval < 0) {
+				usb_unanchor_urb(port->write_urb);
+				skw_usb_info("is error!!! %d\n", retval);
+			}
+			port->write_urb->context = NULL;
+		}
+	}
+	return retval;
+}
+
+int bulkout_write_async(struct usb_port_struct *port, void *buffer, int size)
+{
+	int retval = -1;
+	struct urb *urb;
+	unsigned long flags;
+
+	if (port->suspend) {
+		skw_usb_info("port%d is suspended\n", port->portno);
+		return -EOPNOTSUPP;
+	}
+	spin_lock_irqsave(&port->tx_urb_lock, flags);
+	if(list_empty(&port->tx_urb_list)) {
+		spin_unlock_irqrestore(&port->tx_urb_lock, flags);
+		retval = wait_event_interruptible(port->tx_wait, (!list_empty(&port->tx_urb_list)));
+		spin_lock_irqsave(&port->tx_urb_lock, flags);
+	}
+	urb = list_first_entry(&port->tx_urb_list, struct urb, urb_list);
+	list_del_init(&urb->urb_list);
+	port->tx_urb_count++;
+	spin_unlock_irqrestore(&port->tx_urb_lock, flags);
+
+	usb_fill_bulk_urb(urb, port->udev,usb_sndbulkpipe(port->udev, port->epout->bEndpointAddress),
+		buffer, size, bulkout_async_complete, port);
+	if(size%port->ep_mps == 0)
+		urb->transfer_flags |= URB_ZERO_PACKET;
+		
+	usb_anchor_urb(urb, &port->write_submitted);
+	retval = usb_submit_urb(urb,GFP_KERNEL);
+	if (retval < 0) {
+		usb_unanchor_urb(urb);
+		port->tx_urb_count--;
+		skw_usb_info("is error!!! %d\n",retval);
+	}
+	dev_dbg(&port->udev->dev,"%s %d wait done %d %d\n",__func__, port->portno, retval, port->tx_urb_count);
+	return retval;
+}
+void check_sgs_headers(struct scatterlist *sgs, int sg_num, int total)
+{
+	int i,size;
+	struct skw_packet2_header *header;
+
+	size = 0;
+	for (i=0; i<sg_num; i++) {
+		header = (struct skw_packet2_header *)sg_virt(sgs + i);
+		size += header->len;
+		if (header->len > 2048 || size > total)
+			skw_usb_err("invalid packet: (%d - %d):( %d-%d-%d)\n", total, sg_num, i, header->len, size);
+	}
+}
+
+int bulkout_write_sg_async(struct usb_port_struct *port, struct scatterlist *sgs, int sg_num, int total)
+{
+	struct urb *urb;
+	unsigned long flags;
+	int retval = -1;
+
+	check_sgs_headers(sgs, sg_num, total);
+	spin_lock_irqsave(&port->tx_urb_lock, flags);
+	if(list_empty(&port->tx_urb_list)) {
+		spin_unlock_irqrestore(&port->tx_urb_lock, flags);
+		retval = wait_event_interruptible(port->tx_wait, (!list_empty(&port->tx_urb_list)));
+		spin_lock_irqsave(&port->tx_urb_lock, flags);
+	}
+	urb = list_first_entry(&port->tx_urb_list, struct urb, urb_list);
+	port->tx_urb_count++;
+	list_del_init(&urb->urb_list);
+	port->req_tx_packet += sg_num;
+	spin_unlock_irqrestore(&port->tx_urb_lock, flags);
+	urb->transfer_buffer = NULL;
+	urb->transfer_buffer_length = 0;
+	usb_fill_bulk_urb(urb, port->udev,usb_sndbulkpipe(port->udev, port->epout->bEndpointAddress),
+		NULL, 0, bulkout_async_complete, port);
+	urb->sg = sgs;
+	urb->num_sgs = sg_num;
+	urb->transfer_buffer_length = total;
+	if(total%port->ep_mps == 0)
+		urb->transfer_flags |= URB_ZERO_PACKET;
+	usb_anchor_urb(urb, &port->write_submitted);
+	//dev_info(&port->udev->dev,"%s %d submit  %d\n",__func__, port->portno,  port->tx_urb_count);
+	retval = usb_submit_urb(urb,GFP_KERNEL);
+	if (retval < 0) {
+		port->tx_urb_count--;
+		usb_unanchor_urb(urb);
+	}
+	return retval;
+
+}
+/************************************************************************
+ *Decription:
+ *Author:jiayong.yang
+ *Date:2021-05-27
+ *Modfiy:
+ *
+ ********************************************************************* */
+static int bulkout_write_sg(struct usb_port_struct *port, struct scatterlist *sgs, int sg_num, int total)
+{
+	int	 retval = -1;
+	DECLARE_COMPLETION_ONSTACK(done);
+
+	if(!port->write_urb)
+		return -ENODEV;
+	if(port->write_urb->context) {
+		skw_usb_info("port is busy!!!\n");
+		return -EBUSY;
+	}
+	if(port->write_urb) {
+		port->write_urb->sg = sgs;
+		port->write_urb->num_sgs = sg_num;
+		port->write_urb->transfer_buffer_length = total;
+		if(total%port->ep_mps == 0)
+			port->write_urb->transfer_flags |= URB_ZERO_PACKET;
+		port->write_urb->context = &done;
+		port->req_tx_packet += port->write_urb->num_sgs;
+		usb_anchor_urb(port->write_urb, &port->write_submitted);
+		retval = usb_submit_urb(port->write_urb,GFP_KERNEL);
+		if(retval==0) {
+			retval = wait_for_completion_interruptible(&done);
+			if(retval==0)
+				retval = port->write_urb->actual_length;
+			port->write_urb->context = NULL;
+			port->sent_packet_count += sg_num;
+
+		} else {
+			skw_port_log(port->portno, "%s retval = %d\n", __func__, retval);
+			usb_unanchor_urb(port->write_urb);
+			port->write_urb->context = NULL;
+		}
+	}
+	if(retval > 0)
+		return 0;
+	return retval;
+}
+/************************************************************************
+ *Decription:
+ *Author:jiayong.yang
+ *Date:2021-05-27
+ *Modfiy:
+ *
+ ********************************************************************* */
+static int send_data(int portno, char *buffer, int total)
+{
+	struct usb_port_struct *port;
+
+	if(total==0)
+		return 0;
+	if (modem_status != MODEM_ON)
+		return -EIO;
+	port = usb_ports[portno];
+	if(!port || !port->state)
+		return -EIO;
+	if (port->suspend) {
+		skw_usb_info("port%d is suspended\n", portno);
+		return -EOPNOTSUPP;
+	}
+	return bulkout_write(port, buffer, total);
+}
+static int send_data_async(int portno, char *buffer, int total)
+{
+	struct usb_port_struct *port;
+
+	if(total==0)
+		return 0;
+	if (modem_status != MODEM_ON)
+		return -EIO;
+	port = usb_ports[portno];
+	if(!port || !port->state)
+		return -EIO;
+	return bulkout_write_async(port, buffer, total);
+}
+
+int recv_data(int portno, char *buffer, int total)
+{
+	struct usb_port_struct *port;
+
+	if(total==0)
+		return 0;
+
+	port = usb_ports[portno];
+	if(!port || !port->state)
+		return -EIO;
+	return bulkin_read(port, buffer, total);
+}
+
+int close_usb_port(int portno)
+{
+	struct usb_port_struct *port;
+
+	port = usb_ports[portno];
+
+	if (port) {
+		port->state = 1;
+		if(port->write_urb && port->write_urb->context)
+			usb_kill_urb(port->write_urb);
+		if(port->read_urb && port->read_urb->context)
+			usb_kill_urb(port->read_urb);
+		if(port->thread && down_interruptible(&port->sem))
+			skw_usb_info("port%d rx thread exit\n", portno);
+		port->thread = NULL;
+	}
+	return 0;
+}
+/************************************************************************
+ *Decription:
+ *Author:jiayong.yang
+ *Date:2021-05-27
+ *Modfiy:
+ *
+ ********************************************************************* */
+int wifi_send_cmd(int portno, struct scatterlist *sg, int sg_num, int total)
+{
+	struct usb_port_struct *port;
+	u32 *data;
+	int ret;
+
+	if(total==0)
+		return 0;
+	if (modem_status != MODEM_ON)
+		return -EIO;
+	if(portno >= MAX_USB_PORT)
+		return -EINVAL;
+	port = usb_ports[portno];
+	if(!port || !port->state)
+		return -EIO;
+	if (port->suspend) {
+		skw_usb_info("port%d is suspended\n", portno);
+		return -EOPNOTSUPP;
+	}
+	data = (u32 *)sg_virt(sg);
+	memcpy(last_sent_wifi_cmd, data, 12);
+	port->tx_time[0] = jiffies;
+	ret = bulkout_write_sg(port, sg, sg_num, total);
+	port->tx_time[1] = jiffies;
+	return ret;
+}
+/************************************************************************
+ *Decription:
+ *Author:jiayong.yang
+ *Date:2021-05-27
+ *Modfiy:
+ *
+ ********************************************************************* */
+int wifi_send_cmd_async(int portno, struct scatterlist *sg, int sg_num, int total)
+{
+	struct usb_port_struct *port;
+
+	if(total==0)
+		return 0;
+	if (modem_status != MODEM_ON)
+		return -EIO;
+	if(portno >= MAX_USB_PORT)
+		return -EINVAL;
+	port = usb_ports[portno];
+	if(!port || !port->state)
+		return -EIO;
+
+	if (port->suspend) {
+		skw_usb_info("port%d is suspended\n", portno);
+		return -EOPNOTSUPP;
+	}
+	return bulkout_write_sg_async(port, sg, sg_num, total);
+}
+
+/************************************************************************
+ *Decription: manual assert modem
+ *Author:jiayong.yang
+ *Date:2021-08-03
+ *Modfiy:
+ *Notes: this function must not be invoked in IRQ context.
+ ************************************************************************/
+static int modem_assert(void)
+{
+	struct usb_port_struct *port;
+	struct recovery_data *recovery = SKW_USB_GET_RECOVERY_DATA();
+	int ret = -1;
+	 u32 *cmd = last_sent_wifi_cmd;
+
+	if(modem_status == MODEM_HALT){
+		skw_usb_info("modem in recovery mode \n");
+		return 0;
+	}
+	port = usb_ports[0];
+	if(port && port->state) {
+		recovery->cp_state =1;
+		ret = usb_control_msg(port->udev, usb_sndctrlpipe(port->udev, 0),
+				VENDOR_MSG_MODEM_ASSERT, USB_DIR_OUT| USB_TYPE_VENDOR|USB_RECIP_DEVICE,
+				0,0,NULL,0,1000);
+		skw_usb_err("SND ASSERT CMD ret = %d cmd: 0x%x 0x%x 0x%x:%llu-%llu:%llu \n",
+				ret, cmd[0], cmd[1], cmd[2], port->tx_time[0],port->tx_time[1],last_ack_time);
+		modem_status = MODEM_HALT;
+#ifdef CONFIG_SEEKWAVE_PLD_RELEASE
+		schedule_delayed_work(&skw_except_work , msecs_to_jiffies(2000));
+#else
+		schedule_delayed_work(&skw_except_work , msecs_to_jiffies(6000));
+#endif
+	}
+	return ret;
+}
+
+int wifi_service_start(void)
+{
+	int ret = 0;
+
+	if(!usb_boot_data)
+		return -ENODEV;
+	ret=usb_boot_data->wifi_start();
+
+	return ret;
+}
+
+int wifi_service_stop(void)
+{
+	int ret = 0;
+	if(!usb_boot_data)
+		return -ENODEV;
+	ret=usb_boot_data->wifi_stop();
+	return ret;
+}
+
+int bt_service_start(void)
+{
+	int ret = 0;
+
+	if(!usb_boot_data)
+		return -ENODEV;
+	ret=usb_boot_data->bt_start();
+	return ret;
+}
+
+int bt_service_stop(void)
+{
+	int ret = 0;
+
+	if(!usb_boot_data)
+		return -ENODEV;
+	ret=usb_boot_data->bt_stop();
+	return ret;
+}
+static int send_modem_service_command(u16 service, u16 command)
+{
+	struct usb_port_struct *port;
+	int ret = -1;
+	int timeout = 1000;
+	port = usb_ports[1];
+	if(port)
+		skw_usb_info("(%d,%d) state= %d\n", service, command, port->state);
+	if(port && port->state) {
+		skw_reinit_completion(download_done);
+		ret = usb_control_msg(port->udev, usb_sndctrlpipe(port->udev, 0),
+				VENDOR_MSG_SERVICE_CTRL, USB_DIR_OUT| USB_TYPE_VENDOR|USB_RECIP_DEVICE,
+				service, command, NULL, 0, 1000);
+	}
+	if((command & 0xff) == SERVICE_START) {
+		skw_usb_info("ret = %d\n", ret);
+		complete(&loop_completion);
+		start_service_flag = 1;
+		wait_for_completion_interruptible_timeout(&download_done, msecs_to_jiffies(timeout + 1000*service));
+		service_state_map |= (1<<service);
+	} else {
+		if(service==BT_SERVICE && modem_status==MODEM_ON)
+			wait_for_completion_interruptible_timeout(&download_done, msecs_to_jiffies(1000));
+		service_state_map &= ~(1<<service);
+	}
+//	if(service_state_map==0)
+//		skw_usb_wake_unlock();
+	return ret;
+}
+
+static int skw_get_packet_count(u8 portno)
+{
+	struct usb_port_struct *port;
+	int ret = -1;
+	u16 *packet_count, size=2;
+
+	port = usb_ports[portno];
+	if(port && port->state) {
+		ret = usb_control_msg(port->udev, usb_rcvctrlpipe(port->udev, 0),
+				VENDOR_MSG_PACKET_COUNT, USB_DIR_IN| USB_TYPE_VENDOR|USB_RECIP_DEVICE,
+				portno, 0, port->read_buffer, size, 1000);
+
+		packet_count = (u16 *)port->read_buffer;
+		if(ret < 0)
+			skw_port_log(portno,"%s (%d,%d) ret = %d\n", __func__, portno, *packet_count, ret);
+		if(ret==size)
+			port->max_packet_count = *packet_count;
+		else
+			port->max_packet_count = MAX_PACKET_COUNT;
+	}
+	return ret;
+}
+
+
+void skw_usb_cp_log(int disable)
+{
+	struct usb_port_struct *port;
+	int ret = -1;
+
+	port = usb_ports[0];
+	if(port && port->state) {
+		ret = usb_control_msg(port->udev, usb_rcvctrlpipe(port->udev, 0),
+				VENDOR_MSG_LOG_SWITCH, USB_DIR_IN| USB_TYPE_VENDOR|USB_RECIP_DEVICE,
+				disable, 0, NULL, 0, 1000);
+		if(ret==0)
+			cp_log_status = disable;
+		skw_usb_info("%s (disable=%d) ret = %d\n", __func__, disable, ret);
+	}
+}
+int skw_usb_cp_log_status(void)
+{
+	return cp_log_status;
+}
+/************************************************************************
+ *Decription:send BT start command to modem.
+ *Author:jiayong.yang
+ *Date:2021-08-30
+ *Modfiy:
+ *
+ ********************************************************************* */
+static int skw_BT_service_start(void)
+{
+	if (!wifi_data_pdev)
+		return -ENODEV;
+
+	skw_usb_info("Enter modem_status=%d\n", modem_status);
+	if (service_state_map & (1<<BT_SERVICE))
+		return 0;
+#ifdef CONFIG_SEEKWAVE_PLD_RELEASE
+	skw_usb_cp_log(1);
+#endif
+	return send_modem_service_command(BT_SERVICE, SERVICE_START);
+}
+
+
+/************************************************************************
+ *Decription:send BT stop command to modem.
+ *Author:jiayong.yang
+ *Date:2021-08-30
+ *Modfiy:
+ *
+ ********************************************************************* */
+static int skw_BT_service_stop(void)
+{
+	skw_usb_info("Enter modem_status=%d\n", modem_status);
+	if (!wifi_data_pdev)
+		return -ENODEV;
+
+	if (service_state_map & (1<<BT_SERVICE)){
+		return send_modem_service_command(BT_SERVICE, SERVICE_STOP);
+	}
+	return 0;
+}
+/************************************************************************
+ *Decription:send WIFI start command to modem.
+ *Author:jiayong.yang
+ *Date:2021-08-30
+ *Modfiy:
+ *
+ ********************************************************************* */
+static int skw_WIFI_service_start(void)
+{
+	int count=90;
+	u16 cmd = SERVICE_START;
+	skw_usb_info("Enter STARTWIFI---modem_status=%d, 0x%x\n",
+			modem_status, service_state_map);
+	if (modem_status == MODEM_HALT) {
+		while(!usb_ports[1] && count--)
+			msleep(10);
+	}
+	if (service_state_map & (1<<WIFI_SERVICE))
+		return 0;
+	cmd |= WIFI_PORT_SHARE_FLAG;
+	if (usb_boot_data->pdev == NULL)
+		cmd |= USB_HOST_RESUME_SUPPORT;
+
+#ifdef CONFIG_SEEKWAVE_PLD_RELEASE
+	skw_usb_cp_log(1);
+#endif
+	return send_modem_service_command(WIFI_SERVICE, cmd);
+}
+
+/************************************************************************
+ *Decription: send WIFI stop command to modem.
+ *Author:jiayong.yang
+ *Date:2021-08-30
+ *Modfiy:
+ *
+ ********************************************************************* */
+static int skw_WIFI_service_stop(void)
+{
+	int count=70;
+	skw_usb_info("Enter,STOPWIFI--- modem status %d, 0x%x\n",
+			modem_status, service_state_map);
+	if (modem_status == MODEM_HALT) {
+		service_state_map &= ~(1<<WIFI_SERVICE);
+		while(!usb_ports[1] && count--)
+			msleep(10);
+		return 0;
+	}
+	if (service_state_map & (1<<WIFI_SERVICE))
+		return send_modem_service_command(WIFI_SERVICE, SERVICE_STOP);
+	return 0;
+}
+/************************************************************************
+ *Decription:
+ *Author:jiayong.yang
+ *Date:2021-08-30
+ *Modfiy:
+ *
+ ********************************************************************* */
+static void bulkin_complete(struct urb *urb)
+{
+	struct usb_port_struct *port;
+	int portno = usb_pipeendpoint(urb->pipe) - 1;
+
+	port = usb_ports[portno];
+	if(urb) {
+		if(urb->status) {
+			skw_usb_info("endpoint%d actual = %d status %d\n",
+				usb_pipeendpoint(urb->pipe), urb->actual_length, urb->status);
+		}
+		if(urb->status == -ENOENT && port && port!=log_port  && port->suspend)
+			list_add_tail(&urb->urb_list, &port->suspend_urb_list);
+		else if (urb->context)
+			complete(urb->context);
+	}
+}
+static void bulkin_async_complete(struct urb *urb)
+{
+	struct usb_port_struct *port = urb->context;
+
+	port->rx_complete_time = jiffies;
+	if(urb->status) {
+		skw_usb_info("endpoint%d actual = %d status %d\n",
+			usb_pipeendpoint(urb->pipe), urb->actual_length, urb->status);
+	}
+	if(urb->status == -ENOENT && port  && port->suspend)
+		list_add_tail(&urb->urb_list, &port->suspend_urb_list);
+	else if (port) {
+		urb->context = NULL;
+		spin_lock(&port->rx_urb_lock);
+		if (port->state)
+			list_add_tail(&urb->urb_list, &port->rx_done_urb_list);
+		else
+			list_add_tail(&urb->urb_list, &port->rx_urb_list);
+		spin_unlock(&port->rx_urb_lock);
+		bulk_async_read--;
+		if (port->state)
+		tasklet_hi_schedule(&port->tasklet);
+	}
+}
+/************************************************************************
+ *Decription:
+ *Author:jiayong.yang
+ *Date:2021-05-27
+ *Modfiy:
+ *
+ ********************************************************************* */
+static void bulkout_complete(struct urb *urb)
+{
+	if(urb->status)
+		skw_usb_info("endpoint%d actual = %d status %d\n",
+			usb_pipeendpoint(urb->pipe),  urb->actual_length, urb->status);
+
+	if (urb->context)
+		complete(urb->context);
+}
+
+static void bulkout_async_complete(struct urb *urb)
+{
+	struct usb_port_struct *port = urb->context;
+	//unsigned long flags;
+
+	if(urb->status) {
+		if(urb->sg && port->adma_tx_callback)
+			port->adma_tx_callback(port->portno, urb->sg, urb->num_sgs, port->tx_data, urb->status);
+		else if(urb->transfer_buffer && port->sdma_tx_callback)
+			port->sdma_tx_callback(port->portno, urb->transfer_buffer, urb->transfer_buffer_length, port->tx_data, urb->status);
+		skw_usb_info("port%d endpoint%d actual = %d status %d\n",
+			port->portno, usb_pipeendpoint(urb->pipe), urb->actual_length, urb->status);
+	} else if(urb->sg && port->adma_tx_callback) {
+		port->adma_tx_callback(port->portno, urb->sg, urb->num_sgs, port->tx_data, 0);
+		port->sent_packet_count += urb->num_sgs;
+	} else if(urb->transfer_buffer && port->sdma_tx_callback)
+		port->sdma_tx_callback(port->portno, urb->transfer_buffer, urb->transfer_buffer_length, port->tx_data, 0);
+	urb->context = NULL;
+	spin_lock(&port->tx_urb_lock);
+	list_add_tail(&urb->urb_list, &port->tx_urb_list);
+	port->tx_urb_count--;
+	if(port->tx_urb_count==0 && port->sent_packet_count!=port->req_tx_packet)
+		skw_usb_info("%s port[%d]= %d %d\n", __func__, port->portno, port->sent_packet_count, port->req_tx_packet);
+	spin_unlock(&port->tx_urb_lock);
+	wake_up_interruptible(&port->tx_wait);
+}
+/************************************************************************
+ *Decription:
+ *Author:jiayong.yang
+ *Date:2021-05-27
+ *Modfiy:
+ *
+ ********************************************************************* */
+int bulkin_read_timeout(int portno, char *buffer, int size, int *actual, int timeout)
+{
+	struct usb_port_struct *port;
+	unsigned int pipe;
+	int	ret;
+
+	if(portno >= MAX_USB_PORT || !buffer || !size)
+		return -EINVAL;
+	port = usb_ports[portno];
+	if(!port->state)
+		return -EIO;
+	if(actual)
+		*actual = 0;
+	pipe = usb_rcvbulkpipe(port->udev, port->epin->bEndpointAddress);
+	ret = usb_bulk_msg(port->udev, pipe, buffer, size, actual,timeout);
+
+	if(port == log_port && actual) {
+		if(assert_info_print && assert_info_print<28 && *actual<100) {
+			assert_info_print++;
+			if(*actual > 4)
+				printk("%s", (char *)buffer);
+		}
+		if(*actual == 4)
+			assert_info_print = 28;
+	}
+	if(ret)
+		return ret;
+
+	if(actual)
+		return *actual;
+	return ret;
+}
+/************************************************************************
+ *Decription:
+ *Author:jiayong.yang
+ *Date:2021-05-27
+ *Modfiy:
+ *
+ ********************************************************************* */
+int bulkout_write_timeout(int portno, char *buffer, int size, int *actual, int timeout)
+{
+	struct usb_port_struct *port;
+	unsigned int pipe;
+	int	ret;
+
+	if(portno >= MAX_USB_PORT || !buffer || !size)
+		return -EINVAL;
+	port = usb_ports[portno];
+	
+	if(!port->state)
+		return -EIO;
+	if(actual)
+		*actual = 0;
+	pipe = usb_sndbulkpipe(port->udev, port->epout->bEndpointAddress);
+	ret = usb_bulk_msg(port->udev, pipe, buffer, size, actual,timeout);
+	if(ret)
+		return ret;
+	if(actual)
+		return *actual;
+	return ret;
+}
+/************************************************************************
+ *Decription:
+ *Author:jiayong.yang
+ *Date:2021-05-27
+ *Modfiy:
+ *
+ ********************************************************************* */
+static int register_rx_callback(int id, void *func, void *para);
+static int skw_usb_dump_read(unsigned int address, void *buf, unsigned int len);
+static int register_tx_callback(int id, void *func, void *para);
+static struct sv6160_platform_data wifi_pdata = {
+	.data_port = 0,
+	.cmd_port = 1,
+#ifdef CONFIG_SEEKWAVE_PLD_RELEASE
+	.bus_type = USB_LINK|TX_DMA_TYPE|RX_SDMA|TX_ASYN|CP_RLS,
+#else
+	.bus_type = USB_LINK|TX_DMA_TYPE|RX_SDMA|TX_ASYN|CP_DBG,
+#endif
+	.max_buffer_size = MAX_BUFFER_SIZE,
+	.align_value = 512,
+	.hw_adma_tx = wifi_send_cmd,
+	.hw_sdma_tx = send_data,
+	.hw_adma_tx_async = wifi_send_cmd_async,
+	.hw_sdma_tx_async = send_data_async,
+	.callback_register = register_rx_callback,
+	.modem_assert = modem_assert,
+	.service_start = wifi_service_start,
+	.service_stop = wifi_service_stop,
+	.modem_register_notify = modem_register_notify,
+	.modem_unregister_notify = modem_unregister_notify,
+	.at_ops = {
+		.port = 2,
+		.open = open_usb_port,
+		.close = close_usb_port,
+		.read = recv_data,
+		.write = send_data,
+		.read_tm = bulkin_read_timeout,
+		.write_tm = bulkout_write_timeout,
+	},
+	.tx_callback_register = register_tx_callback,
+	.usb_speed_switch = reboot_to_change_USB_speed_mode,
+};
+
+void usb_handle(unsigned long tsk_data)
+{
+	int	size, read, ret;
+	int  transfer_count = 0, sg_count, offset;
+	u16  data_flag = 0x8000;
+	unsigned long flags;
+	char *buffer;
+	int  *data;
+	struct usb_port_struct *port = (struct usb_port_struct *) tsk_data;
+	struct scatterlist *sg;
+	struct urb *urb;
+
+	port->parser_time[0] = jiffies;
+	if (!strncmp(skw_chipid, "SV6316", 6) || !strlen(skw_chipid)
+            || !strncmp(skw_chipid, "SV6160LITE", 10))
+		data_flag = 2;
+
+	while(!list_empty(&port->rx_done_urb_list)) {
+
+		if (!port->state || port!=usb_ports[1])
+			break;
+		spin_lock_irqsave(&port->rx_urb_lock, flags);
+		urb = list_first_entry(&port->rx_done_urb_list, struct urb, urb_list);
+		list_del_init(&urb->urb_list);
+		list_add_tail(&urb->urb_list, &port->rx_urb_list);
+		spin_unlock_irqrestore(&port->rx_urb_lock, flags);
+
+		sg_init_table(sgs, nr_sgs);
+		read = urb->actual_length;
+		buffer = urb->transfer_buffer;
+		transfer_count++;
+		if(urb->status < 0 || !port->state) {
+			dev_err(&port->udev->dev, "%s bulkin read status=%d state=%d\n", __func__, urb->status, port->state);
+			return ;
+		}
+		if(port->rx_submit) {
+			int is_cmd;
+			u32 d32;
+
+			data = (int *)buffer;
+			d32 = data[0];
+			offset = 0;
+			sg_count = 0;
+			sg = sgs;
+			is_cmd = 0;
+			port->parser_time[1] = jiffies;
+			while (offset+12 < read) {
+				sg_count++;
+				if(sg_count > nr_sgs) {
+					skw_usb_warn("packet count is overflow %d : %d : %d : %d!!!\n",
+							offset, read, sg_count, nr_sgs);
+					sg_count--;
+					break;
+				}
+				size = data[2] >> 16;
+				size += 3;
+				size = size & 0xfffffffc;
+				if(data[2] & data_flag) {
+					if (sg_count > 1 && !is_cmd)
+						size = -1;
+					else
+						is_cmd = 1;
+				}
+				if (size + offset > read || size > 2048 || size <= 12) {
+					skw_usb_warn("Invalid packet size=%d: %d : %d :%d  0x%x:0x%x!!!\n",
+							size, offset, read, sg_count, d32, data[2]);
+					print_hex_dump(KERN_ERR, "PACKET1::", 0, 16, 1,
+							urb->transfer_buffer, offset+12, 1);
+					if (sg_count > 0)
+						sg_count--;
+					break;
+				}
+				sg_set_buf(sg,  &buffer[offset], size);
+				sg++;
+				offset  += size;
+				if (is_cmd) {
+					dev_dbg(&port->udev->dev, "rx_submit(%d): command: 0x%x 0x%x 0x%x 0x%x readlen=%d\n",
+							transfer_count, data[0], data[1], data[2], data[3], read);
+					if ((data[2] & 0xff) == 0x10)
+						memcpy(last_recv_wifi_ack, &data[2], 12);
+					else
+						memcpy(last_recv_wifi_evt, &data[2], 12);
+				}
+				data = (int *)&buffer[offset];
+			}
+			port->parser_time[2] = jiffies;
+			if(sg_count >15)
+				dev_info(&port->udev->dev, "rx_submit: port%d packet count %d\n",
+					port->portno, sg_count);
+			if(is_cmd)
+				port = usb_ports[wifi_pdata.cmd_port];
+			else
+				port = usb_ports[wifi_pdata.data_port];
+			port->rx_submit(port->portno, sgs, sg_count, port->rx_data);
+			port->parser_time[3] = jiffies;
+			port->rx_packet_count += sg_count;
+			if (modem_status != MODEM_ON)
+				return ;
+			port = usb_ports[wifi_pdata.data_port];
+			last_ack_time = jiffies;
+		}
+	}
+
+	while(!list_empty(&port->rx_urb_list)) {
+		if (port->state==0)
+			break;
+		ret = bulkin_read_async(port);
+	}
+}
+
+/**********************************************************************
+ *Decription:
+ *Author:jiayong.yang
+ *Date:2021-05-27
+ *Modfiy:
+ *
+ **********************************************************************/
+int usb_port_async_entry(void *para)
+{
+	struct usb_port_struct *port = para;
+	struct sched_param param;
+	unsigned long flags;
+	//int	size, read, ret;
+	int ret;
+	u16	mpc;
+	struct urb *urb;
+	u16  data_flag = 0x8000;
+
+	if(port->portno == 0) {
+		param.sched_priority = USB_RX_TASK_PRIO;
+#if KERNEL_VERSION(5, 9, 0) <= LINUX_VERSION_CODE
+		sched_set_fifo_low(current);
+#else
+		sched_setscheduler(current, SCHED_FIFO, &param);
+#endif
+	}
+	if(port->max_packet_count)
+		mpc = port->max_packet_count;
+	else
+		mpc = 2;
+
+	if (!strncmp(skw_chipid, "SV6316", 6) || !strlen(skw_chipid)
+            || !strncmp(skw_chipid, "SV6160LITE", 10))
+		data_flag = 2;
+
+	nr_sgs = mpc+1;
+	sgs = kzalloc((nr_sgs)*sizeof(struct scatterlist), GFP_KERNEL);
+	if (!sgs)
+		return -ENOMEM;
+	bulk_async_read = 0;
+	usb_port_alloc_recv_urbs(port, port->epin, 3, 32*1024);
+	usb_port_alloc_xmit_urbs(port, port->epout,10,0);
+	msleep(300);
+	skw_usb_info("%s %d running packet %d %s 0x%x...\n", __func__, port->portno, mpc, skw_chipid, data_flag);
+	while(!list_empty(&port->rx_urb_list)) {
+		ret = bulkin_read_async(port);
+		break;
+	}
+
+	wait_event_interruptible(port->rx_wait, (!port->state));
+	dev_info(&port->udev->dev, "%s-port%d is stopped\n", __func__, port->portno);
+	msleep(50);
+	kfree(sgs);
+
+	if(port->write_urb) {
+		usb_kill_anchored_urbs(&port->write_submitted);
+	}
+	if(port->read_urb) {
+		usb_kill_anchored_urbs(&port->read_submitted);
+	}
+
+	if(port->write_urb && port->write_urb->context)
+		wait_for_completion_interruptible(port->write_urb->context);
+
+	spin_lock_irqsave(&port->rx_urb_lock, flags);
+	while(!list_empty(&port->rx_urb_list)) {
+		urb = list_first_entry(&port->rx_urb_list, struct urb, urb_list);
+		list_del_init(&urb->urb_list);
+		if(urb->transfer_buffer)
+			kfree(urb->transfer_buffer);
+		usb_free_urb(urb);
+	}
+	spin_unlock_irqrestore(&port->rx_urb_lock, flags);
+	while(!list_empty(&port->tx_urb_list)) {
+		urb = list_first_entry(&port->tx_urb_list, struct urb, urb_list);
+		list_del_init(&urb->urb_list);
+		usb_free_urb(urb);
+	}
+	up(&port->sem);
+	return 0;
+}
+
+int usb_port_entry(void *para)
+{
+	struct usb_port_struct *port = para;
+	struct scatterlist *sgs, *sg;
+	struct sched_param param;
+	int	size, read, buf_size;
+	u16	mpc;
+	char *buffer;
+	int  transfer_count = 0;
+	u16  data_flag = 0x8000;
+
+	if(port->portno == 0) {
+		param.sched_priority = USB_RX_TASK_PRIO;
+#if KERNEL_VERSION(5, 9, 0) <= LINUX_VERSION_CODE
+		sched_set_fifo_low(current);
+#else
+		sched_setscheduler(current, SCHED_FIFO, &param);
+#endif
+	}
+
+	if(port->max_packet_count)
+		mpc = port->max_packet_count;
+	else
+		mpc = 2;
+
+	if (port->udev->descriptor.idProduct == 0x6316)
+		data_flag = 2;
+	sgs = kzalloc((mpc+1)*sizeof(struct scatterlist), GFP_KERNEL);
+	if (!sgs)
+		return -ENOMEM;
+	buf_size = 1568 * mpc;
+	buffer = kzalloc(buf_size, GFP_KERNEL);
+	if (!buffer)
+		return -ENOMEM;
+	skw_usb_info("the en_mps= %d------%s%d (MPC %d buffer_size 0x%x )is runninng\n",
+			port->ep_mps,__func__, port->portno, mpc, buf_size);
+	while(port->state){
+		int  *data, sg_count, offset;
+
+		sg_init_table(sgs, mpc+1);
+		read = 0;
+read_msg:
+		do{
+			if(port->state==0)
+				break;
+			read = bulkin_read(port, buffer, buf_size);
+
+		}while(!read);
+
+		if(read < 0 || !port->state) {
+			dev_err(&port->udev->dev, "bulkin read_len=%d state = %d\n", read, port->state);
+			break;
+		}
+		if (modem_status != MODEM_ON)
+			break;
+		transfer_count++;
+		if(port->rx_submit) {
+			int is_cmd;
+			data = (int *)buffer;
+			offset = 0;
+			sg_count = 0;
+			sg = sgs;
+			is_cmd = 0;
+			while(offset < read) {
+				sg_count++;
+				if(sg_count > mpc) {
+					skw_usb_warn("packet count is overflow %d : %d : %d : %d!!!\n",
+							offset, read, sg_count, mpc);
+					sg_count--;
+					break;
+				}
+				size = data[2] >> 16;
+				size += 3;
+				size = size & 0xfffffffc;
+				if(size + offset > read)
+					size = read  - offset;
+				dev_dbg(&port->udev->dev,"submit len=%d size =%d msg: 0x%x 0x%x 0x%x \n",
+					 read, size, data[0], data[1], data[2]);
+				if ((data[2] & 0xff) == 0x10)
+					memcpy(last_recv_wifi_ack, &data[2], 12);
+				else
+					memcpy(last_recv_wifi_evt, &data[2], 12);
+				last_ack_time = jiffies;
+				if(data[2] & data_flag)
+					is_cmd = 1;
+				sg_set_buf(sg,  &buffer[offset], size);
+				sg++;
+				offset  += size;
+				data = (int *)&buffer[offset];
+			}
+			if(sg_count >15)
+				dev_info(&port->udev->dev, "rx_submit: port%d packet count %d\n",
+					port->portno, sg_count);
+			if(is_cmd)
+				port = usb_ports[wifi_pdata.cmd_port];
+			port->rx_submit(port->portno, sgs, sg_count, port->rx_data);
+			port->rx_packet_count += sg_count;
+			port = para;
+		}
+		else if(port->state)
+			goto read_msg;
+	}
+	kfree(buffer);
+	dev_info(&port->udev->dev, "%s-port%d is stopped\n", __func__, port->portno);
+	kfree(sgs);
+	if(port->write_urb) {
+		usb_kill_anchored_urbs(&port->write_submitted);
+	}
+	if(port->read_urb) {
+		usb_kill_anchored_urbs(&port->read_submitted);
+	}
+	if(port->write_urb && port->write_urb->context)
+		wait_for_completion_interruptible(port->write_urb->context);
+
+	up(&port->sem);
+	return 0;
+}
+static void skw_usb_kill_wifi_threads(struct usb_port_struct *p)
+{
+	int i;
+	struct usb_port_struct *port;
+	for(i=0; i<3; i++) {
+		port = usb_ports[i];
+		if(port==NULL)
+			break;
+		if(port && port->thread) {
+			port->state = 0;
+			usb_kill_anchored_urbs(&port->write_submitted);
+			usb_kill_anchored_urbs(&port->read_submitted);
+		}
+	}
+}
+
+void show_assert_context(void)
+{
+	int read;
+
+	if(log_port && log_port->state!=2) {
+		char *buffer;
+		buffer = kzalloc(1024, GFP_KERNEL);
+		if (!buffer)
+			return;
+		open_usb_port(log_port->portno, 0, 0);
+		do {
+			read = bulkin_read_timeout(log_port->portno, buffer, 1024, &read, 1000);
+			if(read == 4 || read < 0) {
+				close_usb_port(log_port->portno);
+				break;
+			}
+		}while(assert_info_print<100);
+		kfree(buffer);
+	}
+}
+
+int usb_loopcheck_entry(void *para)
+{
+	struct usb_port_struct *port = para;
+	char *buffer;
+	int read, size;
+	int count= 0, timeout=300;
+	struct recovery_data *recovery = SKW_USB_GET_RECOVERY_DATA();
+	size = 512;
+	buffer = kzalloc(size, GFP_KERNEL);
+	while(port->state && buffer){
+		read = 0;
+		memset(buffer,0,512);
+		do{
+			if(port->state==0)
+				break;
+			read = bulkin_read(port, buffer, 256);
+		}while(!read);
+
+		if (port->suspend && !usb_boot_data->pdev) {
+			msleep(500);
+			continue;
+		}
+		if(read < 0 || !port->state) {
+			dev_err(&port->udev->dev, "bulkin read_len=%d\n",read);
+			break;
+		}
+		if(strncmp(buffer, "BSPREADY", read))
+			skw_usb_info("recv(%d): %s\n", read, buffer);
+		memcpy(buffer+256, "LOOPCHECK", 9);
+		if (read==8 && !strncmp(buffer, "BSPREADY", read)) {
+			if (start_service_flag)
+				continue;
+			bulkout_write(port, buffer+256, 9);
+			//bulkout_write_timeout(port->portno, buffer+256,9, &size, 300);
+		} else if (read==9 && !strncmp(buffer, "WIFIREADY", read)) {
+			start_service_flag = 0;
+			service_state_map |= (1<<WIFI_SERVICE);
+			complete(&download_done);
+			bulkout_write(port, buffer+256, 9);
+			//bulkout_write_timeout(port->portno, buffer+256,9, &size, 300);
+		} else if (read==6 && !strncmp(buffer, "BTEXIT", read)) {
+			complete(&download_done);
+			//bulkout_write(port, buffer+256, 9);
+			bulkout_write_timeout(port->portno, buffer+256,9, &size, 300);
+		} else if (read==7 && !strncmp(buffer, "BTREADY", read)) {
+			start_service_flag = 0;
+			service_state_map |= (1<<BT_SERVICE);
+			complete(&download_done);
+			bulkout_write(port, buffer+256, 9);
+			//bulkout_write_timeout(port->portno, buffer+256,9, &size, 300);
+		} else if (!strncmp(buffer, "BSPASSERT", 9)) {
+			skw_usb_err("cmd:0x%x 0x%x 0x%x ack:%x %x:%x event:0x%x:0x%x:0x%x time:0x%x:0x%x:0x%x\n",
+			       last_sent_wifi_cmd[0],last_sent_wifi_cmd[1],last_sent_wifi_cmd[2],
+			       last_recv_wifi_ack[0],last_recv_wifi_ack[1],last_recv_wifi_ack[2],
+			       last_recv_wifi_evt[0],last_recv_wifi_evt[1],last_recv_wifi_evt[2],
+			       (u32)jiffies,(u32)last_sent_time, (u32)last_ack_time);
+			if(recovery->cp_state==1)
+				cancel_delayed_work_sync(&skw_except_work);
+			skw_usb_wake_lock();
+
+			mutex_lock(&recovery->except_mutex);
+			if(recovery->cp_state==DEVICE_BLOCKED_EVENT){
+				mutex_unlock(&recovery->except_mutex);
+				break;
+			}
+			recovery->cp_state = 1;
+			mutex_unlock(&recovery->except_mutex);
+
+			assert_info_print = 1;
+			memset(buffer, 0, read);
+			skw_usb_kill_wifi_threads(port);
+			modem_status = MODEM_HALT;
+			if (!usb_speed_switching)
+				show_assert_context();
+			modem_notify_event(DEVICE_ASSERT_EVENT);
+#ifndef CONFIG_SEEKWAVE_PLD_RELEASE
+			if (!usb_speed_switching &&(log_port->state==2)){
+				read = bulkin_read(port, buffer, 256);
+				skw_usb_info("bspassert after recv(%d): %s\n", read, buffer);
+			}
+#endif
+			modem_notify_event(DEVICE_DUMPDONE_EVENT);
+			if (!usb_speed_switching)
+				msleep(10);
+			skw_recovery_mode();
+			service_state_map =0;
+
+			break;
+		} else if (!strncmp("trunk_W", buffer, 7)) {
+#ifdef CONFIG_SKW_DL_TIME_STATS
+			last_time = ktime_get();
+			skw_usb_info("%s,the download time start time %llu and lasttime %llu ,lose_time=%llu\n",
+				__func__, cur_time, last_time,(last_time-cur_time));
+#endif
+			cancel_delayed_work_sync(&skw_except_work);
+			recovery->cp_state = 0;
+
+			assert_info_print = 0;
+			modem_status = MODEM_ON;
+			memset(firmware_version, 0 , sizeof(firmware_version));
+			strncpy(firmware_version, buffer, read);
+
+			modem_notify_event(DEVICE_BSPREADY_EVENT);
+			count = 0;
+			service_state_map =0;
+			skw_usb_wake_unlock();
+			//usb_setup_service_devices();
+			schedule_work(&add_device_work);
+			bulkout_write_timeout(port->portno, buffer+256,9, &size, 300);
+		}
+		wait_for_completion_interruptible_timeout(&loop_completion, msecs_to_jiffies(timeout));
+		skw_reinit_completion(loop_completion);
+	}
+	dev_info(&port->udev->dev, "%s-port%d is stopped\n", __func__, port->portno);
+	if(port->read_urb && port->read_urb->context) {
+		usb_kill_anchored_urbs(&port->read_submitted);
+	}
+
+	if(port->write_urb && port->write_urb->context) {
+		usb_kill_anchored_urbs(&port->write_submitted);
+		if(port->write_urb->context)
+			wait_for_completion_interruptible(port->write_urb->context);
+	}
+	kfree(buffer);
+	up(&port->sem);
+	return 0;
+}
+
+static int usb_bt_rx_entry(void *para)
+{
+	struct usb_port_struct *port = para;
+	char *buffer;
+	int read, size;
+
+	size = 2048;
+	buffer = kzalloc(size, GFP_KERNEL);
+	while(port->state==2 && buffer){
+		read = 0;
+		memset(buffer,0,size);
+		do{
+			if(port->state != 2)
+				break;
+			read = bulkin_read(port, buffer, size);
+		}while(!read);
+
+		if(read < 0) {
+			dev_err(&port->udev->dev, "bulkin read_len=%d\n",read);
+			break;
+		}
+		if(port->rx_submit)
+			port->rx_submit(port->portno, port->rx_data, read, buffer);
+	}
+	dev_info(&port->udev->dev, "%s-port%d is stopped\n", __func__, port->portno);
+	if(port->write_urb && port->write_urb->context) {
+		usb_kill_anchored_urbs(&port->write_submitted);
+	}
+	if(port->read_urb && port->read_urb->context) {
+		usb_kill_anchored_urbs(&port->read_submitted);
+	}
+
+	if(buffer)
+		kfree(buffer);
+	up(&port->sem);
+	return 0;
+}
+
+
+/************************************************************************
+ *Decription:
+ *Author:jiayong.yang
+ *Date:2021-05-27
+ *Modfiy:
+ *
+ ********************************************************************* */
+static struct sv6160_platform_data ucom_pdata = {
+	.max_buffer_size =0x800,
+	.bus_type = USB_LINK,
+	.hw_sdma_tx = send_data,
+	.hw_sdma_rx = recv_data,
+	.open_port = open_usb_port,
+	.close_port = close_usb_port,
+	.modem_assert = modem_assert,
+	.service_start = bt_service_start,
+	.service_stop = bt_service_stop,
+	.modem_register_notify = modem_register_notify,
+	.modem_unregister_notify = modem_unregister_notify,
+	.skw_dump_mem = skw_usb_dump_read,
+};
+
+
+
+static int skw_usb_dump_read(unsigned int address, void *buf, unsigned int len)
+{
+	return 0;
+}
+/************************************************************************
+ *Decription:
+ *Author:jiayong.yang
+ *Date:2021-05-27
+ *Modfiy:
+ *
+ ********************************************************************* */
+
+static int register_rx_callback(int id, void *func, void *para)
+{
+	if(id >= MAX_USB_PORT)
+		return -EINVAL;
+
+	if(usb_ports[id] == NULL)
+		return -EIO;
+	if(func && !usb_ports[id]->rx_submit) {
+		usb_ports[id]->rx_submit = func;
+		usb_ports[id]->rx_data = para;
+		if(id==1)
+			skw_WIFI_service_start();
+		return 0;
+	} else if(!func && usb_ports[id]->rx_submit) {
+		if(id==1)
+			skw_WIFI_service_stop();
+
+		usb_ports[id]->rx_submit = func;
+		usb_ports[id]->rx_data = para;
+		return 0;
+	}
+	if(wifi_pdata.bus_type & TX_ASYN) {
+		if(wifi_pdata.bus_type & TX_SDMA)
+			usb_ports[id]->sdma_tx_callback = func;
+		else
+			usb_ports[id]->adma_tx_callback = func;
+	}
+	usb_ports[id]->tx_data = para;
+	return 0;
+}
+
+/************************************************************************
+ *Decription:
+ *Author:jiayong.yang
+ *Date:2021-05-27
+ *Modfiy:
+ *
+ ********************************************************************* */
+static int register_tx_callback(int id, void *func, void *para)
+{
+	if(id >= MAX_USB_PORT)
+		return -EINVAL;
+
+	if(usb_ports[id] == NULL)
+		return -EIO;
+	if(wifi_pdata.bus_type & TX_ASYN) {
+		if(wifi_pdata.bus_type & TX_SDMA)
+			usb_ports[id]->sdma_tx_callback = func;
+		else
+			usb_ports[id]->adma_tx_callback = func;
+	}
+	usb_ports[id]->tx_data = para;
+	return 0;
+}
+
+
+/************************************************************************
+ *Decription:
+ *Author:jiayong.yang
+ *Date:2021-05-27
+ *Modfiy:
+ *
+ ********************************************************************* */
+static int skw_usb_io_probe(struct usb_interface *interface,
+				const struct usb_device_id *id)
+{
+	struct usb_port_struct *port;
+	struct usb_host_interface *iface_desc;
+	struct usb_endpoint_descriptor *epd;
+	struct platform_device *pdev;
+	struct usb_device *udev = interface_to_usbdev(interface);
+	char	pdev_name[32], names[32];
+	int	i, ret, dloader=0;
+
+	memset(names, 0 ,sizeof(names));
+	iface_desc = interface->cur_altsetting;
+	if (iface_desc->string == NULL)
+		return -EINVAL;
+	sprintf(names, "%s", iface_desc->string);
+
+	if (!strncmp(names, "Boot", 4))
+		dloader = 1;
+
+#ifndef CONFIG_SV6160_LITE_FPGA
+	if ((udev->descriptor.idProduct != 0x6316) && !dloader
+		&& chip_en_gpio < 0 && modem_status == MODEM_OFF)
+		return -EINVAL;
+#endif
+	port = kzalloc(sizeof(*port), GFP_KERNEL);
+	if (!port)
+		return -ENOMEM;
+
+	pdev = NULL;
+	if (!strncmp(names, "WIFITCMD", 8))
+		wifi_port_share = 1;
+	usb_ports[iface_desc->desc.bInterfaceNumber] = port;
+	INIT_LIST_HEAD(&port->rx_urb_list);
+	INIT_LIST_HEAD(&port->tx_urb_list);
+	INIT_LIST_HEAD(&port->rx_done_urb_list);
+	INIT_LIST_HEAD(&port->suspend_urb_list);
+	spin_lock_init(&port->rx_urb_lock);
+	spin_lock_init(&port->tx_urb_lock);
+	port->tx_urb_count = 0;
+	init_waitqueue_head(&port->rx_wait);
+	init_waitqueue_head(&port->tx_wait);
+	if(dloader)
+		dloader = 1;
+	else if(iface_desc->desc.bInterfaceNumber == 1) {
+		if (!strncmp(skw_chipid, "SV6160", 6))
+			sprintf(pdev_name, "%s%d", SV6160_WIRELESS,
+				iface_desc->desc.bInterfaceNumber);
+		else
+			sprintf(pdev_name, "%s%d", SV6316_WIRELESS,
+				iface_desc->desc.bInterfaceNumber);
+
+		if(!wifi_data_pdev)
+			pdev = platform_device_alloc(pdev_name, PLATFORM_DEVID_AUTO);
+		else
+			pdev = wifi_data_pdev;
+		if(!pdev)
+			return -ENOMEM;
+	} else {
+#ifdef CONFIG_BT_SEEKWAVE
+		if (!strncmp(names, "DATA", 4)) {
+			ucom_pdata.data_port = 0;
+		} else if(!strncmp(names, "BTDATA", 6))
+			ucom_pdata.data_port = iface_desc->desc.bInterfaceNumber;
+		else if(!strncmp(names, "BTCMD", 5)){
+			ucom_pdata.cmd_port = iface_desc->desc.bInterfaceNumber;
+		else if(!strncmp(names, "BTISOC", 6)) {
+			ucom_pdata.audio_port = iface_desc->desc.bInterfaceNumber;
+			sprintf(pdev_name, "%s", "btseekwave");
+			ucom_pdata.port_name = "BTHCI";
+			bluetooth_pdev = platform_device_alloc(pdev_name, PLATFORM_DEVID_AUTO);
+			if (!bluetooth_pdev)
+				return -ENOMEM;
+			bluetooth_pdev->dev.parent = &udev->dev;
+			bluetooth_pdev->dev.dma_mask = &port_dmamask;
+			bluetooth_pdev->dev.coherent_dma_mask = port_dmamask;
+			bt_audio_port = iface_desc->desc.bInterfaceNumber;
+			memcpy(ucom_pdata.chipid, skw_chipid, SKW_CHIP_ID_LENGTH);
+			platform_device_add_data(bluetooth_pdev, &ucom_pdata, sizeof(ucom_pdata));
+		}else if(!strncmp(names, "AUDIO", 5)) {
+			ucom_pdata.audio_port = 0;
+			sprintf(pdev_name, "%s", "btseekwave");
+			ucom_pdata.port_name = "BTHCI";
+			bluetooth_pdev = platform_device_alloc(pdev_name, PLATFORM_DEVID_AUTO);
+			if (!bluetooth_pdev)
+				return -ENOMEM;
+			bluetooth_pdev->dev.parent = &udev->dev;
+			bluetooth_pdev->dev.dma_mask = &port_dmamask;
+			bluetooth_pdev->dev.coherent_dma_mask = port_dmamask;
+			bt_audio_port = iface_desc->desc.bInterfaceNumber;
+			memcpy(ucom_pdata.chipid, skw_chipid, SKW_CHIP_ID_LENGTH);
+			platform_device_add_data(bluetooth_pdev, &ucom_pdata, sizeof(ucom_pdata));
+		} else
+#endif
+		if (iface_desc->desc.bInterfaceNumber && strncmp(names, "LOOP", 4)) {
+			sprintf(pdev_name, "%s", "skw_ucom");
+			ucom_pdata.port_name = iface_desc->string;
+			ucom_pdata.data_port = iface_desc->desc.bInterfaceNumber;
+			memcpy(ucom_pdata.chipid, skw_chipid, SKW_CHIP_ID_LENGTH);
+			pdev = platform_device_alloc(pdev_name, PLATFORM_DEVID_AUTO);
+			if(!pdev)
+				return -ENOMEM;
+		}
+	}
+	if(!dloader) {
+		if (1==iface_desc->desc.bInterfaceNumber && wifi_data_pdev) {
+			struct sv6160_platform_data *pdata;
+			pdev = wifi_data_pdev;
+			//pdev->dev.parent = NULL;
+			pdata = pdev->dev.platform_data;
+			if (pdata) {
+				pdata->align_value = iface_desc->endpoint[0].desc.wMaxPacketSize;
+				wifi_pdata.align_value = iface_desc->endpoint[0].desc.wMaxPacketSize;
+			}
+			port->pdev = pdev;
+		} else if (iface_desc->desc.bInterfaceNumber && pdev) {
+			if (1==iface_desc->desc.bInterfaceNumber &&
+			    usb_boot_data && usb_boot_data->pdev) {
+				pdev->dev.parent = &usb_boot_data->pdev->dev;
+#ifdef REINIT_USB_STR
+				wifi_pdata.bus_type |= REINIT_USB_STR;
+#endif
+			} else
+				pdev->dev.parent = &udev->dev;
+			pdev->dev.dma_mask = &port_dmamask;
+			pdev->dev.coherent_dma_mask = port_dmamask;
+
+			if(iface_desc->desc.bInterfaceNumber == 1) {
+				wifi_pdata.align_value = iface_desc->endpoint[0].desc.wMaxPacketSize;
+				if(usb_boot_data && usb_boot_data->iram_dl_size >0x70000)
+					wifi_pdata.at_ops.port = 4;
+				else
+					wifi_pdata.at_ops.port = 2;
+				if(udev->config->string && !strncmp(udev->config->string, "ECOM", 4)) {
+					wifi_pdata.bus_type &= ~TYPE_MASK;
+					wifi_pdata.bus_type |= USB2_LINK;
+				}
+				ret = platform_device_add_data(pdev, &wifi_pdata, sizeof(wifi_pdata));
+				modem_status = MODEM_ON;
+			} else{
+				memcpy(ucom_pdata.chipid, skw_chipid, SKW_CHIP_ID_LENGTH);
+				ret = platform_device_add_data(pdev, &ucom_pdata, sizeof(ucom_pdata));
+			}
+			if(ret) {
+				dev_err(&udev->dev, "failed to add platform data \n");
+				platform_device_put(pdev);
+				kfree(port);
+				return ret;
+			}
+			if(iface_desc->desc.bInterfaceNumber>1){
+				ret = platform_device_add(pdev);
+				if(ret) {
+					dev_err(&udev->dev, "failt to register platform device\n");
+					platform_device_put(pdev);
+					kfree(port);
+					return ret;
+				}
+			}
+			port->pdev = pdev;
+		}
+	}
+	usb_set_intfdata(interface, port);
+
+	port->interface = usb_get_intf(interface);
+	port->udev = usb_get_dev(udev);
+	/* register struct wcn_usb_intf */
+	dev_dbg(&port->udev->dev, "intf[%x] is registerred: ep count %d %s\n",
+			iface_desc->desc.bInterfaceNumber,
+			iface_desc->desc.bNumEndpoints,
+			iface_desc->string);
+	ret = -ENOMEM;
+	for(i=0; i<iface_desc->desc.bNumEndpoints; i++) {
+
+		epd = &iface_desc->endpoint[i].desc;
+		port->buffer_size = MAX_BUFFER_SIZE;
+		port->ep_mps = epd->wMaxPacketSize;
+		if(usb_endpoint_is_bulk_in(epd)) {
+			port->epin = epd;
+			port->read_urb = usb_alloc_urb(0, GFP_KERNEL);
+			if(!port->read_urb)
+				goto err0;
+			if(iface_desc->desc.bInterfaceNumber > 1) {
+				port->read_buffer = NULL;
+				port->buffer_size = 0;
+			} else {
+				port->read_buffer = kzalloc(port->buffer_size , GFP_KERNEL);
+				if(!port->read_buffer)
+					goto err0;
+			}
+			usb_fill_bulk_urb(port->read_urb, udev,
+				usb_rcvbulkpipe(udev, epd->bEndpointAddress),
+				port->read_buffer, port->buffer_size,
+				bulkin_complete, port);
+			port->read_urb->context = NULL;
+			init_usb_anchor(&port->read_submitted);
+			dev_dbg(&pdev->dev, "BulkinEP = 0x%x rp=%p\n",
+					epd->bEndpointAddress, port->read_buffer);
+		} else if(usb_endpoint_is_bulk_out(epd)) {
+			port->epout = epd;
+			port->write_urb = usb_alloc_urb(0, GFP_KERNEL);
+			if(!port->write_urb)
+				goto err0;
+			if(iface_desc->desc.bInterfaceNumber > 1) {
+				port->write_buffer = NULL;
+				port->buffer_size = 0;
+			} else{
+				port->write_buffer = kzalloc(port->buffer_size, GFP_KERNEL);
+				if(!port->write_buffer)
+					goto err0;
+			}
+			usb_fill_bulk_urb(port->write_urb, udev,
+				usb_sndbulkpipe(udev, epd->bEndpointAddress),
+				port->write_buffer, port->buffer_size, bulkout_complete,port);
+			port->write_urb->context = NULL;
+			init_usb_anchor(&port->write_submitted);
+			dev_dbg(&pdev->dev, "BulkoutEP = 0x%x wp =%p context %p\n",
+					epd->bEndpointAddress, port->write_buffer, port->write_urb->context);
+		}
+	}
+	if(!dloader) {
+		port->portno = iface_desc->desc.bInterfaceNumber;
+		port->state = 1;
+		if (port->portno<=1) {
+			if (!strncmp(names, "WIFIDATA", 8)) {
+				skw_get_packet_count(port->portno);
+				wifi_pdata.cmd_port = 1 - port->portno;
+				wifi_pdata.data_port = port->portno;
+				port->thread = kthread_create(usb_port_async_entry, port, iface_desc->string);
+
+				tasklet_init(&port->tasklet, usb_handle, (unsigned long) port);
+			} else {
+				wifi_pdata.cmd_port = port->portno;
+				wifi_pdata.data_port = 1 - port->portno;
+				if(!strncmp(names, "WIFICMD", 7))
+					port->thread = kthread_create(usb_port_entry, port, iface_desc->string);
+			}
+			if(port->thread) {
+				sema_init(&port->sem, 0);
+				wake_up_process(port->thread);
+			} else
+				sema_init(&port->sem, 1);
+		} else if(!strncmp(names, "LOOP", 4)) {
+			sema_init(&port->sem, 0);
+			port->thread = kthread_create(usb_loopcheck_entry, port, iface_desc->string);
+			if(port->thread)
+				wake_up_process(port->thread);
+		} else	sema_init(&port->sem, 1);
+	} else {
+		port->state = 1;
+		assert_info_print = 0;
+		INIT_WORK(&port->work, dloader_work);
+		if (usb_boot_data &&
+		    usb_boot_data->iram_dl_size &&
+		    usb_boot_data->dram_dl_size) {
+			skw_usb_info("schedule boot-work: 0x%x:0x%x\n",
+				usb_boot_data->dram_dl_size,usb_boot_data->iram_dl_size);
+			schedule_work(&port->work);
+			modem_status = MODEM_ON;
+		}
+		port->is_dloader = 1;
+	}
+	if (!strncmp(names, "LOG", 3))
+		log_port = port;
+	return 0;
+err0:
+	dev_err(&udev->dev, "no memory  to register device\n");
+	if(port->write_buffer)
+		kfree(port->write_buffer);
+	if(port->read_buffer)
+		kfree(port->read_buffer);
+	if(port->write_urb)
+		usb_free_urb(port->write_urb);
+	if(port->read_urb)
+		usb_free_urb(port->read_urb);
+	if(port->pdev)
+		platform_device_unregister(port->pdev);
+	usb_ports[iface_desc->desc.bInterfaceNumber] = NULL;
+	kfree(port);
+	return ret;
+}
+
+/************************************************************************
+ *Decription:
+ *Author:jiayong.yang
+ *Date:2021-05-27
+ *Modfiy:
+ *
+ ********************************************************************* */
+static int launch_download_work(char *data, int size,int addr)
+{
+	int chk_ports =0;
+	firmware_size = size;//link to usb_download size
+	firmware_data	= data;//link to usb_download dl_data
+	firmware_addr = addr;
+	do{
+		if((usb_ports[0] !=NULL)&&(usb_ports[0]->state)) {
+			chk_ports = 1;
+			break;
+		}
+		msleep(10);
+	}while(!chk_ports);
+	schedule_work(&usb_ports[0]->work);
+	return 0;
+}
+
+static int skw_recovery_mode(void)
+{
+	if (chip_en_gpio > 0  &&
+	   (usb_speed_switching || !cls_recovery_mode_en)) {
+		gpio_set_value(chip_en_gpio, 0);
+		if (usb_ports[0])
+			usb_reset_device(usb_ports[0]->udev);
+
+		skw_usb_info("set chip enable reset\n");
+		msleep(30);
+		gpio_set_value(chip_en_gpio, 1);
+	}
+	usb_speed_switching = 0;
+	return 0;
+}
+
+void get_bt_antenna_mode(char *mode)
+{
+	struct seekwave_device *boot_data = usb_boot_data;
+	u32 bt_antenna = boot_data->bt_antenna;
+
+	if(bt_antenna==0)
+		return;
+	bt_antenna--;
+	if(!mode)
+		return;
+	if (bt_antenna)
+		sprintf(mode,"bt_antenna : alone\n");
+	else
+		sprintf(mode,"bt_antenna : share\n");
+}
+
+void reboot_to_change_bt_antenna_mode(char *mode)
+{
+	struct seekwave_device *boot_data = usb_boot_data;
+	u32 *data = (u32 *) &boot_data->iram_img_data[boot_data->nv_head_addr + 4];
+	u32 bt_antenna;
+
+	if(boot_data->bt_antenna == 0)
+		return;
+	bt_antenna = boot_data->bt_antenna - 1;
+	bt_antenna = 1 - bt_antenna;
+	data[0] &= ~0x01;
+		data[0] |= bt_antenna;
+	if (bt_antenna==1) {
+		boot_data->bt_antenna = 2;
+		sprintf(mode,"bt_antenna : alone\n");
+	} else {
+		boot_data->bt_antenna = 1;
+		sprintf(mode,"bt_antenna : share\n");
+	}
+	
+	modem_assert();
+
+}
+
+void get_USB_speed_mode(char *mode)
+{
+	if (wifi_pdata.align_value == 1024)
+		sprintf(mode,"MAX_SPEED=SUPER\n");
+	else
+		sprintf(mode,"MAX_SPEED=HIGH\n");
+}
+
+void reboot_to_change_USB_speed_mode(char *mode)
+{
+	struct seekwave_device *boot_data = usb_boot_data;
+	u32 *data = (u32 *) &boot_data->iram_img_data[boot_data->nv_head_addr + 4];
+
+	data[0] &= ~0x0C;
+	if (wifi_pdata.align_value == 1024) {
+		data[0] |= 0x04;
+		sprintf(mode,"MAX_SPEED=HIGH\n");
+	} else {
+		sprintf(mode,"MAX_SPEED=SUPER\n");
+	}
+	usb_speed_switching = 1;
+	skw_usb_info("offset %d : 0x%x\n", boot_data->nv_head_addr, data[0]);
+	modem_assert();
+}
+
+void reboot_to_change_bt_uart1(char *mode)
+{
+	struct seekwave_device *boot_data = usb_boot_data;
+	u32 *data = (u32 *) &boot_data->iram_img_data[boot_data->nv_head_addr + 4];
+
+	data[0] |= 0x0000002;
+	modem_assert();
+}
+static irqreturn_t skw_gpio_irq_handler(int irq, void *dev_id)
+{
+	int     value = gpio_get_value(host_wake_gpio);
+	skw_usb_info("wakeup_gpio_state = %d\n", value);
+	return IRQ_HANDLED;
+}
+/************************************************************************
+ *Decription:
+ *Author:JUNWEI.JIANG
+ *Date:2021-12-20
+ *Modfiy:
+ *
+ ********************************************************************* */
+int skw_boot_loader(struct seekwave_device *boot_data)
+{
+	int ret = 1;
+
+	if (usb_ports[0] && usb_ports[0]->suspend)
+		return -EOPNOTSUPP;
+	usb_boot_data= boot_data;
+	skw_usb_info("status:%d , the dma_type = 0x%08x ,chip_en_gpio=%d, gpio_in=%d", modem_status,
+		TX_DMA_TYPE,usb_boot_data->chip_en, usb_boot_data->gpio_in);
+
+	chip_en_gpio = usb_boot_data->chip_en;
+#ifdef CONFIG_SKW_DL_TIME_STATS
+	cur_time = ktime_get();
+#endif
+	if (host_wake_gpio < 0 && usb_boot_data->gpio_in>=0) {
+		int irq_num;
+		host_wake_gpio = usb_boot_data->gpio_in;
+		irq_num = gpio_to_irq(host_wake_gpio);
+		ret = request_irq(irq_num, skw_gpio_irq_handler,
+				IRQF_TRIGGER_RISING | IRQF_ONESHOT, "skw-gpio-irq", NULL);
+		skw_usb_info("request_gpio_irq ret=%d\n", ret);
+		if (ret == 0)
+			enable_irq_wake(irq_num);
+	}
+	if(!boot_data->first_dl_flag ){
+		if (usb_ports[0] && !usb_ports[0]->is_dloader) {
+			//usb_setup_service_devices();
+			schedule_work(&add_device_work);
+		} else if(boot_data->iram_img_data !=NULL && boot_data->dram_img_data!=NULL){
+			skw_usb_info("USB FIRST BOOT... \n");
+			ret=launch_download_work(boot_data->iram_img_data,boot_data->iram_dl_size,boot_data->iram_dl_addr);
+		}else{
+			skw_usb_info("The CPBOOT not download from AP!!!!\n");
+		}
+	}
+	if(boot_data->dl_module==RECOVERY_BOOT){
+		skw_recovery_mode();
+		return 0;
+	}
+	if(boot_data->service_ops==SKW_WIFI_START){
+		//skw_WIFI_service_start();
+		//skw_usb_info("----WIFI-SERVICE-----START!!!\n");
+	}else if(boot_data->service_ops== SKW_WIFI_STOP &&
+			(service_state_map & (1<<WIFI_SERVICE))){
+		skw_WIFI_service_stop();
+		//skw_usb_info("----WIFI-SERVICE-----STOP!!!\n");
+	}else if(boot_data->service_ops == SKW_BT_START){
+		skw_usb_info("----BT-SERVICE-----START!!!\n");
+		ret=skw_BT_service_start();
+	}else if(boot_data->service_ops==SKW_BT_STOP &&
+			(service_state_map & (1<<BT_SERVICE))){
+		skw_usb_info("----BT-SERVICE-----STOP!!!\n");
+		ret=skw_BT_service_stop();
+	}
+	if(ret < 0)
+		return -1;
+	else
+		return 0;
+}
+void *skw_get_bus_dev(void)
+{
+	int time_count=0;
+	if(modem_status == MODEM_OFF && !usb_ports[0]) {
+		skwusb_err("%s power on USB\n", __func__);
+		do{
+			msleep(10);
+			time_count++;
+		}while(!usb_ports[0] && time_count < 50);
+	}
+	if(!usb_ports[0] || !usb_ports[0]->state || !usb_ports[0]->udev){
+		skwusb_err("%s the port open device fail !!!\n", __func__);
+		return NULL;
+	}
+	return &usb_ports[0]->udev->dev;
+}
+
+/************************************************************************
+ *Decription:check dev ready for boot
+ *Author:junwei.jiang
+ *Date:2022-06-07
+ *Modfiy:
+ *
+ ********************************************************************* */
+int skw_reset_bus_dev(void)
+{
+	struct usb_port_struct *port;
+	int ret = -1;
+
+	port = usb_ports[0];
+	if (port == NULL)
+		return 0;
+
+	ret = usb_control_msg(port->udev, usb_sndctrlpipe(port->udev, 0),
+			VENDOR_MSG_MODEM_RESET, USB_DIR_OUT| USB_TYPE_VENDOR|USB_RECIP_DEVICE,
+			0,0,NULL,0,100);
+	return ret;
+}
+
+/************************************************************************
+ *Decription:
+ *Author:jiayong.yang
+ *Date:2021-05-27
+ *Modfiy:
+ *
+ ********************************************************************* */
+static int skw_usb_io_free_suspend_urbs(struct usb_interface *interface)
+{
+	struct usb_port_struct *port;
+	struct urb *urb;
+
+	port = usb_get_intfdata(interface);
+
+	port->suspend = 0;
+	while(!list_empty(&port->suspend_urb_list)) {
+		urb = list_first_entry(&port->suspend_urb_list, struct urb, urb_list);
+		list_del_init(&urb->urb_list);
+		if (!list_empty(&port->suspend_urb_list))
+			list_add_tail(&urb->urb_list, &port->rx_urb_list);
+		else {
+			urb->status = -EIO;
+			urb->complete(urb);
+		}
+	}
+	return 0;
+}
+
+static void skw_usb_io_disconnect(struct usb_interface *interface)
+{
+	int infno = interface->cur_altsetting->desc.bInterfaceNumber;
+	struct recovery_data *recovery = SKW_USB_GET_RECOVERY_DATA();
+	struct usb_port_struct *port;
+	unsigned long flags;
+	struct urb *urb;
+
+	port = usb_get_intfdata(interface);
+	if(!port)
+		return;
+	log_port = NULL;
+	port->state = 0;
+	skw_usb_info("interface[%x] disconnected %d\n", infno, modem_status);
+	if(!port->is_dloader) {
+		if (infno > 1)
+			platform_device_unregister(port->pdev);
+		if (infno == 1)
+			wake_up_interruptible(&port->rx_wait);
+		if (modem_status==MODEM_ON) {
+			if(wifi_data_pdev && &port->udev->dev == wifi_data_pdev->dev.parent) {
+				platform_device_unregister(port->pdev);
+				wifi_data_pdev = NULL;
+			}
+		}
+		if (port->pdev == wifi_data_pdev && port->suspend) {
+			modem_notify_event(DEVICE_DISCONNECT_EVENT);
+			tasklet_kill(&port->tasklet);
+			if(!recovery->cp_state){
+				recovery->cp_state = 1;
+				schedule_delayed_work(&skw_except_work , msecs_to_jiffies(20000));
+			}
+		}
+		skw_usb_io_free_suspend_urbs(interface);
+		if(port->read_urb && port->read_urb->context)
+			usb_kill_anchored_urbs(&port->read_submitted);
+		if(port->write_urb && port->write_urb->context)
+			usb_kill_anchored_urbs(&port->write_submitted);		
+		if(port->thread && !port->suspend&& down_timeout(&port->sem, 1000))
+			skw_usb_info("start  to unregister interface[%x]\n", infno);
+	} else
+		flush_work(&port->work);
+	if(port->read_urb && !port->read_urb->context) {
+		kfree(port->read_urb);
+		port->read_urb = NULL;
+	} else skw_usb_info("%s memory leak port.r%d!!!!!!!!\n", __func__, infno);
+	if(port->write_urb && !port->write_urb->context) {
+		kfree(port->write_urb);
+		port->write_urb = NULL;
+	} else skw_usb_info("%s memory leak port.w%d!!!!!!!!\n", __func__, infno);
+	if(port->read_buffer)
+		kfree(port->read_buffer);
+	if(port->write_buffer)
+		kfree(port->write_buffer);
+	spin_lock_irqsave(&port->rx_urb_lock, flags);
+	while(!list_empty(&port->rx_done_urb_list)) {
+		urb = list_first_entry(&port->rx_done_urb_list, struct urb, urb_list);
+		list_del_init(&urb->urb_list);
+		if(urb->transfer_buffer)
+			kfree(urb->transfer_buffer);
+		usb_free_urb(urb);
+	}
+	spin_unlock_irqrestore(&port->rx_urb_lock, flags);
+	usb_ports[infno]->udev = NULL;
+	usb_ports[infno] = NULL;
+	usb_set_intfdata(interface, NULL);
+	usb_put_dev(port->udev);
+	usb_put_intf(interface);
+	kfree(port);
+}
+
+/************************************************************************
+ *Decription:
+ *Author:jiayong.yang
+ *Date:2021-05-27
+ *Modfiy:
+ *
+ ********************************************************************* */
+static int skw_usb_io_pre_reset(struct usb_interface *interface)
+{
+	/* there is a lock to prevent we reset a interface when
+	 * urb submit
+	 */
+	struct usb_port_struct *port;
+
+	port = usb_get_intfdata(interface);
+
+	return 0;
+}
+
+/************************************************************************
+ *Decription:
+ *Author:jiayong.yang
+ *Date:2021-05-27
+ *Modfiy:
+ *
+ ********************************************************************* */
+static int skw_usb_io_post_reset(struct usb_interface *interface)
+{
+	struct usb_port_struct *port;
+
+	port = usb_get_intfdata(interface);
+	return 0;
+}
+#ifdef CONFIG_PM
+static int skw_usb_io_suspend(struct usb_interface *interface, pm_message_t message)
+{
+	struct usb_port_struct *port;
+	struct recovery_data *recovery = SKW_USB_GET_RECOVERY_DATA();
+
+	if (service_state_map & (1<<BT_SERVICE))
+		skw_BT_service_stop();
+
+	port = usb_get_intfdata(interface);
+
+	if(usb_ports[0] && usb_ports[0]->write_urb->context) {
+		msleep(10);
+		skw_usb_info("retry to send WIFI command\n");
+	}
+	if (port->tx_urb_count)
+		usb_kill_anchored_urbs(&port->write_submitted);
+	port->suspend = 1;
+
+	if(port->portno == 1 || port->read_urb->context)
+		usb_kill_anchored_urbs(&port->read_submitted);
+	if(port->write_urb->context)
+		usb_kill_anchored_urbs(&port->write_submitted);
+	if (port->portno==0 && recovery->cp_state) {
+		recovery->cp_state = 0;
+		cancel_delayed_work_sync(&skw_except_work);
+	}
+	skw_usb_info("port%d %s MSG\n", port->portno, PMSG_IS_AUTO(message)? "Auto":"None-auto");
+	return 0;
+}
+static int skw_usb_io_resume(struct usb_interface *interface)
+{
+	struct usb_port_struct *port;
+	struct urb *urb;
+	port = usb_get_intfdata(interface);
+
+	skw_usb_info("port%d enter...\n", port->portno);
+	port->suspend = 0;
+	while(!list_empty(&port->suspend_urb_list)) {
+		urb = list_first_entry(&port->suspend_urb_list, struct urb, urb_list);
+		list_del_init(&urb->urb_list);
+		if(port->portno == wifi_pdata.data_port)
+			urb->context = port;
+		usb_anchor_urb(urb, &port->read_submitted);
+		usb_submit_urb(urb, GFP_KERNEL);
+	}
+	return 0;
+}
+#endif
+
+/************************************************************************
+ *Decription:
+ *Author:jiayong.yang
+ *Date:2021-05-27
+ *Modfiy:
+ *
+ ********************************************************************* */
+struct usb_driver skw_usb_io_driver = {
+	.name = "skw_usb_io",
+	.probe = skw_usb_io_probe,
+	.disconnect = skw_usb_io_disconnect,
+#ifdef CONFIG_PM
+        .suspend   = skw_usb_io_suspend,
+        .resume    = skw_usb_io_resume,
+#endif	
+	.pre_reset = skw_usb_io_pre_reset,
+	.post_reset = skw_usb_io_post_reset,
+	.id_table = skw_usb_io_id_table,
+	.supports_autosuspend = 1,
+};
+
+/**
+ * wcn_usb_io_init() - init wcn_usb_io's memory and register this driver.
+ * @void: void.
+ */
+static int __init skw_usb_io_init(void)
+{
+	wifi_data_pdev = NULL;
+	bluetooth_pdev = NULL;
+	log_port = NULL;
+	usb_boot_data = NULL;
+	cls_recovery_mode_en = 0;
+	wifi_port_share = 0;
+	usb_speed_switching = 0;
+	memset(usb_ports, 0, sizeof(usb_ports));
+	init_completion(&download_done);
+	init_completion(&loop_completion);
+	skw_usb_wakeup_source_init();
+	skw_usb_debugfs_init();
+	skw_usb_log_level_init();
+	chip_en_gpio = -1;
+	modem_status = MODEM_OFF;
+	skw_chipid = wifi_pdata.chipid;
+	mutex_init(&g_recovery_data.except_mutex);
+	INIT_DELAYED_WORK(&skw_except_work, skw_usb_exception_work);
+	INIT_WORK(&add_device_work, add_devices_work);
+	usb_register(&skw_usb_io_driver);
+	return seekwave_boot_init();
+}
+
+/************************************************************************
+ *Copyright(C) 2020-2021: Seekwave tech LTD 		China
+ *Decription:
+ *Author:jiayong.yang
+ *Date:2021-05-27
+ *Modfiy:
+ *
+ ********************************************************************* */
+static void __exit skw_usb_io_exit(void)
+{
+	int ret;
+
+	if (chip_en_gpio >=0) {
+		gpio_set_value(chip_en_gpio, 0);
+		msleep(50);
+	}
+	if (usb_ports[0] && usb_ports[0]->udev) {
+		skw_usb_info("reset SKWUSB device");
+		skw_reset_bus_dev();
+	}
+		
+	if (usb_boot_data && usb_boot_data->pdev && wifi_data_pdev &&
+	    wifi_data_pdev->dev.parent == &usb_boot_data->pdev->dev) {
+		skw_usb_info("unregister WIFI device\n");
+		platform_device_unregister(wifi_data_pdev);
+		wifi_data_pdev = NULL;
+		ret = 0;
+	}
+	seekwave_boot_exit();
+	cancel_delayed_work_sync(&skw_except_work);
+	cancel_work_sync(&add_device_work);
+	mutex_destroy(&g_recovery_data.except_mutex);
+	skw_usb_wakeup_source_destroy();
+	if(bluetooth_pdev)
+		platform_device_put(bluetooth_pdev);
+	usb_deregister(&skw_usb_io_driver);
+	if(wifi_data_pdev)
+		platform_device_put(wifi_data_pdev);
+}
+module_init(skw_usb_io_init)
+module_exit(skw_usb_io_exit)
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/misc/seekwaveplatform_v20/usb/skw_usb_log.c b/drivers/misc/seekwaveplatform_v20/usb/skw_usb_log.c
new file mode 100755
index 000000000000..67f4df6855e7
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/usb/skw_usb_log.c
@@ -0,0 +1,432 @@
+/*****************************************************************************
+ * Copyright(c) 2020-2030  Seekwave Corporation.
+ * SEEKWAVE TECH LTD..CO
+ *
+ *Seekwave Platform the usb log debug fs
+ *FILENAME:skw_usb_log.c
+ *DATE:2022-04-11
+ *MODIFY:
+ *Author:Jones.Jiang
+ **************************************************************************/
+#include <linux/uaccess.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+
+#include "skw_usb_log.h"
+#include "skw_usb.h"
+#include "skw_usb_debugfs.h"
+
+static unsigned long skw_usb_dbg_level;
+
+extern char firmware_version[];
+extern void reboot_to_change_bt_antenna_mode(char *mode);
+extern void get_bt_antenna_mode(char *mode);
+unsigned long skw_usb_log_level(void)
+{
+	return skw_usb_dbg_level;
+}
+
+static void skw_usb_set_log_level(int level)
+{
+	unsigned long dbg_level;
+
+	dbg_level = skw_usb_log_level() & 0xffff0000;
+	dbg_level |= ((level << 1) - 1);
+
+	xchg(&skw_usb_dbg_level, dbg_level);
+}
+
+static void skw_usb_enable_func_log(int func, bool enable)
+{
+	unsigned long dbg_level = skw_usb_log_level();
+
+	if (enable)
+		dbg_level |= func;
+	else
+		dbg_level &= (~func);
+
+	xchg(&skw_usb_dbg_level, dbg_level);
+}
+
+static int skw_usb_log_show(struct seq_file *seq, void *data)
+{
+#define SKW_USB_LOG_STATUS(s) (level & (s) ? "enable" : "disable")
+
+	int i;
+	u32 level = skw_usb_log_level();
+	u8 *log_name[] = {"NONE", "ERROR", "WARNNING", "INFO", "DEBUG"};
+
+	for (i = 0; i < 5; i++) {
+		if (!(level & BIT(i)))
+			break;
+	}
+	if (i >= 5)
+		return 0;
+	seq_printf(seq, "\nlog   level: %s\n", log_name[i]);
+
+	seq_puts(seq, "\n");
+	seq_printf(seq, "port0 log: %s\n", SKW_USB_LOG_STATUS(SKW_USB_PORT0));
+	seq_printf(seq, "port1 log: %s\n", SKW_USB_LOG_STATUS(SKW_USB_PORT1));
+	seq_printf(seq, "port2 log: %s\n", SKW_USB_LOG_STATUS(SKW_USB_PORT2));
+	seq_printf(seq, "port3 log: %s\n", SKW_USB_LOG_STATUS(SKW_USB_PORT3));
+	seq_printf(seq, "port4 log: %s\n", SKW_USB_LOG_STATUS(SKW_USB_PORT4));
+	seq_printf(seq, "port5 log: %s\n", SKW_USB_LOG_STATUS(SKW_USB_PORT5));
+	seq_printf(seq, "port6 log: %s\n", SKW_USB_LOG_STATUS(SKW_USB_PORT6));
+	seq_printf(seq, "port7 log: %s\n", SKW_USB_LOG_STATUS(SKW_USB_PORT7));
+	seq_printf(seq, "savelog  : %s\n", SKW_USB_LOG_STATUS(SKW_USB_SAVELOG));
+	seq_printf(seq, "dump  log: %s\n", SKW_USB_LOG_STATUS(SKW_USB_DUMP));
+
+	return 0;
+}
+
+static int skw_usb_log_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, &skw_usb_log_show, inode->i_private);
+}
+
+static int skw_usb_log_control(const char *cmd, bool enable)
+{
+	if (!strcmp("dump", cmd))
+		skw_usb_enable_func_log(SKW_USB_DUMP, enable);
+	else if (!strcmp("port0", cmd))
+		skw_usb_enable_func_log(SKW_USB_PORT0, enable);
+	else if (!strcmp("port1", cmd))
+		skw_usb_enable_func_log(SKW_USB_PORT1, enable);
+	else if (!strcmp("port2", cmd))
+		skw_usb_enable_func_log(SKW_USB_PORT2, enable);
+	else if (!strcmp("port3", cmd))
+		skw_usb_enable_func_log(SKW_USB_PORT3, enable);
+	else if (!strcmp("port4", cmd))
+		skw_usb_enable_func_log(SKW_USB_PORT4, enable);
+	else if (!strcmp("port5", cmd))
+		skw_usb_enable_func_log(SKW_USB_PORT5, enable);
+    else if (!strcmp("port6", cmd))
+		skw_usb_enable_func_log(SKW_USB_PORT6, enable);
+	else if (!strcmp("port7", cmd))
+		skw_usb_enable_func_log(SKW_USB_PORT7, enable);
+    else if (!strcmp("savelog", cmd))
+		skw_usb_enable_func_log(SKW_USB_SAVELOG, enable);
+	else if (!strcmp("debug", cmd))
+		skw_usb_set_log_level(SKW_USB_DEBUG);
+	else if (!strcmp("info", cmd))
+		skw_usb_set_log_level(SKW_USB_INFO);
+	else if (!strcmp("warn", cmd))
+		skw_usb_set_log_level(SKW_USB_WARNING);
+	else if (!strcmp("error", cmd))
+		skw_usb_set_log_level(SKW_USB_ERROR);
+	else
+		return -EINVAL;
+
+	return 0;
+}
+
+static ssize_t skw_usb_log_write(struct file *fp, const char __user *buffer,
+				size_t len, loff_t *offset)
+{
+	int i, idx;
+	char cmd[32];
+	bool enable = false;
+
+	for (idx = 0, i = 0; i < len; i++) {
+		char c;
+
+		if (get_user(c, buffer))
+			return -EFAULT;
+
+		switch (c) {
+		case ' ':
+			break;
+
+		case ':':
+			cmd[idx] = 0;
+			if (!strcmp("enable", cmd))
+				enable = true;
+			else
+				enable = false;
+
+			idx = 0;
+			break;
+
+		case '|':
+		case '\0':
+		case '\n':
+			cmd[idx] = 0;
+			skw_usb_log_control(cmd, enable);
+			idx = 0;
+			break;
+
+		default:
+			cmd[idx++] = c;
+			idx %= 32;
+
+			break;
+		}
+
+		buffer++;
+	}
+
+	return len;
+}
+
+static const struct file_operations skw_usb_log_fops = {
+	.owner = THIS_MODULE,
+	.open = skw_usb_log_open,
+	.read = seq_read,
+	.release = single_release,
+	.write = skw_usb_log_write,
+};
+
+static int skw_version_show(struct seq_file *seq, void *data)
+{
+	seq_printf(seq, "firmware info:\n %s\n", firmware_version );
+	return 0;
+}
+
+static int skw_version_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, &skw_version_show, inode->i_private);
+}
+
+
+static const struct file_operations skw_version_fops = {
+        .owner = THIS_MODULE,
+        .open = skw_version_open,
+        .read = seq_read,
+        .release = single_release,
+};
+
+
+static int skw_cp_log_show(struct seq_file *seq, void *data)
+{
+        if (!skw_usb_cp_log_status())
+                seq_printf(seq, "Enabled");
+        else
+                seq_printf(seq, "Disabled");
+        return 0;
+}
+static int skw_cp_log_open(struct inode *inode, struct file *file)
+{
+        return single_open(file, &skw_cp_log_show, inode->i_private);
+}
+
+
+static ssize_t skw_cp_log_write(struct file *fp, const char __user *buffer,
+                                size_t len, loff_t *offset)
+{
+        char cmd[16]={0};
+
+        if (len >= sizeof(cmd))
+                return -EINVAL;
+        if (copy_from_user(cmd, buffer, len))
+                return -EFAULT;
+        if (!strncmp("enable", cmd, 6))
+                skw_usb_cp_log(0);
+        else if (!strncmp("disable", cmd, 7))
+                skw_usb_cp_log(1);
+
+        return len;
+}
+
+static const struct file_operations skw_cp_log_fops = {
+        .owner = THIS_MODULE,
+        .open = skw_cp_log_open,
+        .read = seq_read,
+        .release = single_release,
+        .write = skw_cp_log_write,
+};
+
+static int skw_port_statistic_show(struct seq_file *seq, void *data)
+{
+	char *statistic = kzalloc(2048, GFP_KERNEL);
+
+	skw_get_port_statistic(statistic, 2048);
+	seq_printf(seq, "Statistic:\n%s", statistic );
+       	kfree(statistic);
+	return 0;
+}
+
+static int skw_port_statistic_open(struct inode *inode, struct file *file)
+{
+        return single_open(file, &skw_port_statistic_show, inode->i_private);
+}
+
+static const struct file_operations skw_port_statistic_fops = {
+          .owner = THIS_MODULE,
+          .open = skw_port_statistic_open,
+          .read = seq_read,
+          .release = single_release,
+};
+static int skw_bluetooth_antenna_show(struct seq_file *seq, void *data)
+{
+        char result[32];
+
+        memset(result, 0, sizeof(result));
+        get_bt_antenna_mode(result);
+        if(strlen(result))
+                seq_printf(seq, result);
+        return 0;
+}
+static int skw_bluetooth_antenna_open(struct inode *inode, struct file *file)
+{
+        return single_open(file, &skw_bluetooth_antenna_show, inode->i_private);
+}
+
+
+static ssize_t skw_bluetooth_antenna_write(struct file *fp, const char __user *buffer,
+                                size_t len, loff_t *offset)
+{
+        char cmd[32]={0};
+
+        if (len >= sizeof(cmd))
+                return -EINVAL;
+        if (copy_from_user(cmd, buffer, len))
+                return -EFAULT;
+        if (!strncmp("switch", cmd, 6)) {
+                memset(cmd, 0, sizeof(cmd));
+                reboot_to_change_bt_antenna_mode(cmd);
+                printk("%s\n", cmd);
+        }
+        return len;
+}
+
+static const struct file_operations skw_bluetooth_antenna_fops = {
+        .owner = THIS_MODULE,
+        .open = skw_bluetooth_antenna_open,
+        .read = seq_read,
+        .release = single_release,
+        .write = skw_bluetooth_antenna_write,
+};
+
+static int skw_USB_speed_show(struct seq_file *seq, void *data)
+{
+        char result[32];
+
+        memset(result, 0, sizeof(result));
+        get_USB_speed_mode(result);
+        if(strlen(result))
+                seq_printf(seq, result);
+        return 0;
+}
+static int skw_USB_speed_open(struct inode *inode, struct file *file)
+{
+        return single_open(file, &skw_USB_speed_show, inode->i_private);
+}
+
+
+static ssize_t skw_USB_speed_write(struct file *fp, const char __user *buffer,
+                                size_t len, loff_t *offset)
+{
+        char cmd[32]={0};
+
+        if (len >= sizeof(cmd))
+                return -EINVAL;
+        if (copy_from_user(cmd, buffer, len))
+                return -EFAULT;
+        if (!strncmp("HIGH", cmd, 4)) {
+                memset(cmd, 0, sizeof(cmd));
+                reboot_to_change_USB_speed_mode(cmd);
+                printk("%s\n", cmd);
+        }
+        return len;
+}
+
+static const struct file_operations skw_USB_speed_fops = {
+        .owner = THIS_MODULE,
+        .open = skw_USB_speed_open,
+        .read = seq_read,
+        .release = single_release,
+        .write = skw_USB_speed_write,
+};
+
+static int skwusb_recovery_debug_show(struct seq_file *seq, void *data)
+{
+    if (skw_usb_recovery_debug_status())
+        seq_printf(seq, "Disabled");
+    else
+        seq_printf(seq, "Enabled");
+
+    return 0;
+}
+static int skwusb_recovery_debug_open(struct inode *inode, struct file *file)
+{
+        return single_open(file, &skwusb_recovery_debug_show, inode->i_private);
+}
+
+static ssize_t skwusb_recovery_debug_write(struct file *fp, const char __user *buffer,
+                size_t len, loff_t *offset)
+{
+    char cmd[16]={0};
+
+    if (len >= sizeof(cmd))
+        return -EINVAL;
+    if (copy_from_user(cmd, buffer, len))
+        return -EFAULT;
+    if (!strncmp("disable", cmd, 7))
+        skw_usb_recovery_debug(1);
+    else if (!strncmp("enable", cmd, 6))
+        skw_usb_recovery_debug(0);
+
+    return len;
+}
+
+static const struct file_operations skwusb_recovery_debug_fops = {
+    .owner = THIS_MODULE,
+    .open = skwusb_recovery_debug_open,
+    .read = seq_read,
+    .release = single_release,
+    .write = skwusb_recovery_debug_write,
+};
+
+static int skw_bluetooth_UART1_open(struct inode *inode, struct file *file)
+{
+        return single_open(file, NULL, inode->i_private);
+}
+
+
+static ssize_t skw_bluetooth_UART1_write(struct file *fp, const char __user *buffer,
+				size_t len, loff_t *offset)
+{
+	char cmd[32]={0};
+
+	if (len >= sizeof(cmd))
+		return -EINVAL;
+	if (copy_from_user(cmd, buffer, len))
+		return -EFAULT;
+	if (!strncmp("enable", cmd, 6)) {
+		memset(cmd, 0, sizeof(cmd));
+		reboot_to_change_bt_uart1(cmd);
+		printk("%s UART-HCI\n", cmd);
+	}
+	return len;
+}
+
+static const struct file_operations skw_bluetooth_UART1_fops = {
+	.owner = THIS_MODULE,
+	.open = skw_bluetooth_UART1_open,
+	.release = single_release,
+	.write = skw_bluetooth_UART1_write,
+};
+
+void skw_usb_log_level_init(void)
+{
+	skw_usb_set_log_level(SKW_USB_INFO);
+
+	skw_usb_enable_func_log(SKW_USB_DUMP, false);
+	skw_usb_enable_func_log(SKW_USB_PORT0, false);
+	skw_usb_enable_func_log(SKW_USB_PORT1, false);
+	skw_usb_enable_func_log(SKW_USB_PORT2, false);
+	skw_usb_enable_func_log(SKW_USB_PORT3, false);
+	skw_usb_enable_func_log(SKW_USB_PORT4, false);
+	skw_usb_enable_func_log(SKW_USB_PORT5, false);
+	skw_usb_enable_func_log(SKW_USB_PORT6, false);
+	skw_usb_enable_func_log(SKW_USB_SAVELOG, false);
+	skw_usb_enable_func_log(SKW_USB_PORT7, false);
+	skw_usb_add_debugfs("log_level", 0666, NULL, &skw_usb_log_fops);
+	skw_usb_add_debugfs("Version", 0664, NULL, &skw_version_fops);
+	skw_usb_add_debugfs("CPLog", 0666, NULL, &skw_cp_log_fops);
+	skw_usb_add_debugfs("Statistic", 0666, NULL, &skw_port_statistic_fops);
+	skw_usb_add_debugfs("BT_ANT", 0666, NULL, &skw_bluetooth_antenna_fops);
+	skw_usb_add_debugfs("recovery", 0666, NULL, &skwusb_recovery_debug_fops);
+	skw_usb_add_debugfs("USB_SPEED", 0666, NULL, &skw_USB_speed_fops);
+	skw_usb_add_debugfs("BT_UART1", 0666, NULL, &skw_bluetooth_UART1_fops);
+}
diff --git a/drivers/misc/seekwaveplatform_v20/usb/skw_usb_log.h b/drivers/misc/seekwaveplatform_v20/usb/skw_usb_log.h
new file mode 100755
index 000000000000..447e8db35b8b
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/usb/skw_usb_log.h
@@ -0,0 +1,86 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2020-2030  Seekwave Corporation.
+ * DATE: 2022-07-18
+ * MODIFY:
+ * Author:junwei.jiang
+ *
+ *****************************************************************************/
+#ifndef __SKW_USB_LOG_H__
+#define __SKW_USB_LOG_H__
+
+#define SKW_USB_ERROR    BIT(0)
+#define SKW_USB_WARNING  BIT(1)
+#define SKW_USB_INFO     BIT(2)
+#define SKW_USB_DEBUG    BIT(3)
+
+#define SKW_USB_CMD      BIT(16)
+#define SKW_USB_EVENT    BIT(17)
+#define SKW_USB_SCAN     BIT(18)
+#define SKW_USB_TIMER    BIT(19)
+#define SKW_USB_STATE    BIT(20)
+
+#define SKW_USB_PORT0     BIT(21)
+#define SKW_USB_PORT1     BIT(22)
+#define SKW_USB_PORT2     BIT(23)
+#define SKW_USB_PORT3     BIT(24)
+#define SKW_USB_PORT4     BIT(25)
+#define SKW_USB_PORT5     BIT(26)
+#define SKW_USB_PORT6     BIT(27)
+#define SKW_USB_PORT7     BIT(28)
+#define SKW_USB_SAVELOG     BIT(29)
+#define SKW_USB_DUMP     BIT(31)
+
+unsigned long skw_usb_log_level(void);
+void skw_usb_cp_log(int disable);
+int skw_usb_cp_log_status(void);
+void skw_get_port_statistic(char *buffer, int size);
+void reboot_to_change_USB_speed_mode(char *mode);
+void get_USB_speed_mode(char *mode);
+#define skw_usb_log(level, fmt, ...) \
+	do { \
+		if (skw_usb_log_level() & level) \
+			pr_err(fmt,  ##__VA_ARGS__); \
+	} while (0)
+
+#define skw_usb_port_log(port_num, fmt, ...) \
+	do { \
+		if (skw_usb_log_level() &(SKW_USB_PORT0<<port_num)) \
+			pr_err(fmt,  ##__VA_ARGS__); \
+	} while (0)
+
+#define skw_port_log(port_num,fmt, ...) \
+	skw_usb_log((SKW_USB_PORT0<<port_num), "[PORT_LOG] %s: "fmt, __func__, ##__VA_ARGS__)
+
+#define skw_usb_err(fmt, ...) \
+	skw_usb_log(SKW_USB_ERROR, "[SKWUSB ERROR] %s: "fmt, __func__, ##__VA_ARGS__)
+
+#define skw_usb_warn(fmt, ...) \
+	skw_usb_log(SKW_USB_WARNING, "[SKWUSB WARN] %s: "fmt, __func__, ##__VA_ARGS__)
+
+#define skw_usb_info(fmt, ...) \
+	skw_usb_log(SKW_USB_INFO, "[SKWUSB INFO] %s: "fmt, __func__, ##__VA_ARGS__)
+
+#define skw_usb_dbg(fmt, ...) \
+	skw_usb_log(SKW_USB_DEBUG, "[SKWUSB DBG] %s: "fmt, __func__, ##__VA_ARGS__)
+
+#define skw_usb_hex_dump(prefix, buf, len) \
+	do { \
+		if (skw_usb_log_level() & SKW_USB_DUMP) { \
+			u8 str[32] = {0};  \
+			snprintf(str, sizeof(str), "[SKWUSB DUMP] %s", prefix); \
+			print_hex_dump(KERN_ERR, str, \
+				DUMP_PREFIX_OFFSET, 16, 1, buf, len, true); \
+		} \
+	} while (0)
+#if 0
+#define skw_usb_port_log(port_num, fmt, ...) \
+	do { \
+		if (skw_usb_log_level() &(SKW_USB_PORT0<<port_num)) \
+			pr_err("[PORT_LOG] %s:"fmt,__func__,  ##__VA_ARGS__); \
+	} while (0)
+
+#endif
+void skw_usb_log_level_init(void);
+#endif
+
diff --git a/drivers/misc/seekwaveplatform_v20/usb/usb_boot.c b/drivers/misc/seekwaveplatform_v20/usb/usb_boot.c
new file mode 100755
index 000000000000..15254f4f6ba7
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/usb/usb_boot.c
@@ -0,0 +1,456 @@
+/*************************************************************************************
+ *Description: usb download
+ *Seekwave tech LTD
+ *Author: jiayong.yang/junwei.jiang
+ *Date:20210527
+ *Modify:
+ * ***********************************************************************************/
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/slab.h>
+#include <linux/proc_fs.h>
+#include <linux/errno.h>
+#ifdef CONFIG_DEBUG_FS
+#include <linux/debugfs.h>
+#endif
+#include <linux/fs.h>
+#include <linux/buffer_head.h>
+#include <linux/ctype.h>
+#include "skw_usb_log.h"
+#include "usb_boot.h"
+/***************************************************************************
+ * Description:
+ *Seekwave tech LTD
+ *Author:
+ *Date:
+ *Modify:
+ * ************************************************************************/
+static int dl_mps;
+static int dloader_port = 0;
+
+/***************************************************************************
+ * Description:
+ *Seekwave tech LTD
+ *Author:
+ *Date:
+ *Modify:
+ * ************************************************************************/
+static int check_modem_status_from_connect_message(void)
+{
+	struct connect_ack *ack = (void *)&connect_ack[12];
+	memcpy(skw_chipid,ack->chip_id,16);
+	dl_mps = ack->packet_size;
+	if(ack->flags.bitmap.boot)
+		return NORMAL_BOOT;
+	else
+		return NORMAL_BOOT;
+}
+
+/***************************************************************************
+ * Description:
+ *Seekwave tech LTD
+ *Author:
+ *Date:
+ *Modify:
+ * ************************************************************************/
+static int dloader_write(char *msg, int msg_len, int *actual, int timeout)
+{
+	return bulkout_write_timeout(dloader_port, msg, msg_len, actual, timeout);
+}
+
+/***************************************************************************
+ * Description:
+ *Seekwave tech LTD
+ *Author:
+ *Date:
+ *Modify:
+ * ************************************************************************/
+static int dloader_read(char *msg, int msg_len, int *actual, int timeout)
+{
+	return bulkin_read_timeout(dloader_port, msg, msg_len, actual, timeout);
+}
+
+/***************************************************************************
+ * Description:
+ *Seekwave tech LTD
+ *Author:
+ *Date:
+ *Modify:
+ * ************************************************************************/
+static int compare_msg(const char *src, const char *dst, size_t count)
+{
+	unsigned char c1, c2;
+
+	while (count) {
+		c1 = *src++;
+		c2 = *dst++;
+		if (c1 != c2)
+			return c1 < c2 ? -1 : 1;
+		count--;
+	}
+	return 0;
+}
+
+static int dloader_send_data(const char *command, int command_len, const char *ack, int ack_len)
+{
+	int actual_len = 0;
+	int ret;
+	void *data;
+	int data_size = 128;
+
+	data = kzalloc(data_size, GFP_KERNEL);
+
+	if (!data)
+		return -ENOMEM;
+	/* send command */
+	ret = dloader_write((char *)command, command_len, &actual_len, 3000);
+	if (ret <0 || actual_len != command_len) {
+		printk("%s send cmd error ret %d actual_len %d command_len %d\n",
+				__func__, ret, actual_len, command_len);
+	} else {
+		if (ack == NULL)
+			goto OUT;
+
+		/* read ack and check it */
+		ret = dloader_read(data, data_size, &actual_len, 3000);
+		if (ret <0 || ack_len > actual_len || compare_msg(ack, data, ack_len)) {
+			printk("%s ack is NACK:ret-- %d\n", __func__, ret);
+			ret = -EIO;
+		}
+	}
+OUT:
+	kfree(data);
+	return ret;
+}
+
+/***************************************************************************
+ * Description:
+ *Seekwave tech LTD
+ *Author:
+ *Date:
+ *Modify:
+ * ************************************************************************/
+static int dloader_send_command(const char *command,  int command_len, const char *ack, int ack_len)
+{
+	int actual_len = 0;
+	int ret;
+	void *data;
+	int data_size = 128;
+
+	data = kzalloc(data_size, GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+	/* send command */
+	memcpy(data, (char*)command, command_len);
+	ret = dloader_write(data, command_len, &actual_len, 3000);
+	if (ret <0 || actual_len != command_len) {
+		printk("%s send cmd error ret %d actual_len %d command_len %d\n",
+				__func__, ret, actual_len, command_len);
+	} else {
+		/* read ack */
+		ret = dloader_read(data, data_size, &actual_len, 3000);
+		if (ret <0) {
+			printk("%s ack is NACK: acklen ===%d- actual_len ==%d--ret == %d\n",
+				__func__, ret, ack_len, actual_len);
+		}
+	}
+	if(0 == command[8])
+		memcpy(connect_ack, data, actual_len);
+	kfree(data);
+	return ret;
+}
+
+/***************************************************************************
+ * Description:
+ *Seekwave tech LTD
+ *Author:
+ *Date:
+ *Modify:
+ * ************************************************************************/
+static unsigned short crc16_calculate(unsigned char *buf, int len)
+{
+	unsigned int i;
+	unsigned short crc = 0;
+
+	while (len-- != 0) {
+		for (i = 0x80; i != 0; i = i >> 1) {
+			if ((crc & 0x8000) != 0) {
+				crc = crc << 1;
+				crc = crc ^ 0x1021;
+			} else {
+				crc = crc << 1;
+			}
+			if ((*buf & i) != 0)
+				crc = crc ^ 0x1021;
+		}
+		buf++;
+	}
+	return crc;
+}
+
+/***************************************************************************
+ * Description:
+ *Seekwave tech LTD
+ *Author:
+ *Date:
+ *Modify:
+ * ************************************************************************/
+int dloader_command_start_download(unsigned int addr, unsigned int len)
+{
+
+	int command_len = 20;
+	char command[20] = {0x7E, 0x7E, 0x7E, 0x7E,/* head */
+		0x08, 0x00, 0x00, 0x00, /*length */
+		0x01, 0x00, /* message type, 01: start command */
+		0x00, 0x00, /*crc for data body, excludes message header */
+		0x00, 0x00, 0x10, 0x00,/*addr*/
+		0x60, 0xb3, 0x06, 0x00 /*image size*/};
+
+	*((u32 *)&command[12]) = addr;
+	*((u32 *)&command[16]) = len;
+
+	*((u16 *)&command[10]) = cpu_to_be16(crc16_calculate(&command[12], command_len - 12));
+	return dloader_send_command(command, command_len, common_ack, sizeof(common_ack));
+}
+
+/***************************************************************************
+ * Description:
+ *Seekwave tech LTD
+ *Author:
+ *Date:
+ *Modify:
+ * ************************************************************************/
+int dloader_command_exec(unsigned int addr)
+{
+	unsigned short command_len = 16;
+
+	char command[16] = {0x7E,0x7E,0x7E,0x7E, /* head */
+		0x04, 0x00, 0x00, 0x00,
+		0x04, 0x00, /*command type */
+		0x43, 0x63, /*command len */
+		0x00, 0x00, 0x10, 0x00 /*addr*/
+		};
+	*((u32 *)&command[12]) = addr;
+	*((u16 *)&command[10]) = crc16_calculate(&command[12], 4);
+	return dloader_send_command(command, command_len, exec_ack, sizeof(exec_ack));
+}
+
+/***************************************************************************
+ * Description:
+ *Seekwave tech LTD
+ *Author:
+ *Date:
+ *Modify:
+ * ************************************************************************/
+int dloader_setup_usb_connection(struct usb_port_struct *port)
+{
+	int ret;
+
+	dloader_command_client_probe();
+	if (ret < 0) {
+		dev_err(&port->udev->dev, "get version error\n");
+		return ret;
+	}
+	dloader_command_connect();
+	if (ret < 0) {
+		dev_err(&port->udev->dev, "connection  error\n");
+		return ret;
+	}
+	dev_info(&port->udev->dev,"dloader connect susscess...\n");
+	return 0;
+}
+
+/***************************************************************************
+ * Description:
+ *Seekwave tech LTD
+ *Author:
+ *Date:
+ *Modify:
+ * ************************************************************************/
+int dloader_execute_image(struct usb_port_struct *port,unsigned int addr)
+{
+	int ret;
+
+	ret = dloader_command_exec(addr);
+	if (ret < 0) {
+		dev_err(&port->udev->dev, "exec command is error\n");
+		return ret;
+	}
+	return 0;
+}
+/***************************************************************************
+ * Description:
+ *Seekwave tech LTD
+ *Author:junwei.jiang
+ *Date:
+ *Modify:
+ * ************************************************************************/
+static unsigned int dloader_send_pdata(char* buf, const void *pdata, unsigned int len)
+{
+	PACKET_T *packet_ptr = (PACKET_T *)buf;
+	int command_len = len + PACKET_HEADER_SIZE;
+
+	packet_ptr->magic = PACKET_MAGIC;
+	packet_ptr->type = 0x0002;
+	packet_ptr->size = len;
+	packet_ptr->crc = 0x0000;
+	memset(packet_ptr->content, 0 , len);
+	memcpy(packet_ptr->content,pdata, len);
+
+	//crc check sum
+	packet_ptr->crc = cpu_to_be16(crc16_calculate((char*)(&(packet_ptr->content)), command_len));
+
+	return command_len;
+}
+
+/***************************************************************************
+ * Description:
+ *Seekwave tech LTD
+ *Author:
+ *Date:
+ *Modify:
+ * ************************************************************************/
+int usb_download_image(struct usb_port_struct *port, unsigned int addr, unsigned int len)
+{
+	int ret;
+	int size;
+	int offset = 0;
+	int img_size = 0;
+	int temp_size = 0;
+
+	/*the first command connect*/
+	ret = dloader_command_start_download(addr, len);
+	if (ret < 0) {
+		dev_err(&port->udev->dev,"start download command failed\n");
+		return ret;
+	}
+	/*get the data and the sv6160.bin size*/
+	img_size = len;
+
+	while (img_size > 0) {
+		temp_size = MIN(dl_mps, img_size-offset);
+		if(!temp_size)
+			return 0;
+		size  = dloader_send_pdata(port->read_buffer, (void*)(firmware_data)+offset, temp_size);
+		if (size%512==0 && temp_size < dl_mps) {
+			temp_size = temp_size>>1;
+			size  = dloader_send_pdata(port->read_buffer, (void*)(firmware_data)+offset, temp_size);
+		}  
+		ret = dloader_send_data(port->read_buffer, size, common_ack, sizeof(common_ack));
+		if (ret < 0) {
+			dev_err(&port->udev->dev, "donwload img  error\n");
+			return ret;
+		}
+		offset += temp_size;
+	}
+	return 0;
+}
+
+/***************************************************************************
+ * Description:
+ *Seekwave tech LTD
+ *Author:
+ *Date:
+ *Modify:
+ * ************************************************************************/
+int dloader_get_chip_id(void *buf, unsigned int buf_size)
+{
+	int len = strlen(usb_ports[0]->udev->product);
+	memcpy(buf, usb_ports[0]->udev->product, strlen(usb_ports[0]->udev->product));
+	return len;
+}
+
+/***************************************************************************
+ * Description:
+ *Seekwave tech LTD
+ *Author:
+ *Date:
+ *Modify:
+ * ************************************************************************/
+int dloader_dump_from_romcode_usb(unsigned int addr, void *buf, int len)
+{
+	int ret;
+	unsigned short command_len = 16;
+	char command[20] = {0x7E, 0x7E, 0x7E, 0x7E,/* head */
+		0x08, 0x00, 0x00, 0x00, /*for command data len */
+		0x00, 0x09, /*command type */
+		0x00, 0x00, /*for crc*/
+		0x00, 0x00, 0x00, 0x00,/*addr*/
+		0x00, 0x00, 0x00, 0x00,/*data len*/
+		};
+	int actual_len = 0;
+	int size;
+
+	//*((u32 *)&command[12]) = cpu_to_be32(addr);
+	//*((u32 *)&command[16]) = cpu_to_be32(len);
+	*((u32 *)&command[12]) = addr;
+	*((u32 *)&command[16]) = len;
+
+	*((u16 *)&command[10]) = cpu_to_be16(crc16_calculate(&command[1], command_len - 4));
+
+
+	ret = dloader_send_command(command, command_len, NULL, 0);
+	if (ret < 0) {
+		printk("%s send command error\n", __func__);
+		return -EIO;
+	}
+
+	size = dl_mps;
+	while(len > 0) {
+		if (len < size)
+			size = len;
+		ret = dloader_read(buf, size, &actual_len, 3000);
+		if (ret < 0)
+			printk("dloader_read_ack dump memory error\n");
+		else len -= actual_len;
+	}
+	return ret;
+}
+
+/***************************************************************************
+ * Description:
+ *Seekwave tech LTD
+ *Author:
+ *Date:
+ *Modify:
+ * ************************************************************************/
+static int dloader_dump_read_usb(struct usb_port_struct *port)
+{
+	int ret;
+	ret = dloader_dump_from_romcode_usb(START_ADDR, port->read_buffer, MAX_IMAGE_SIZE);
+	return ret;
+}
+
+/***************************************************************************
+ * Description:
+ *Seekwave tech LTD
+ *Author:
+ *Date:
+ *Modify:
+ * ************************************************************************/
+static void dloader_work(struct work_struct *work)
+{
+	struct usb_port_struct *port = container_of(work, struct usb_port_struct, work);
+	int ret;
+	dloader_port = port->portno;
+	dloader_setup_usb_connection(port);
+
+	ret = check_modem_status_from_connect_message();
+	if (ret == HANG_REBOOT){
+		dloader_dump_read_usb(port);
+	}
+	if(usb_boot_data->dram_dl_size > 0){
+		firmware_data = usb_boot_data->dram_img_data;
+		ret = usb_download_image(port, usb_boot_data->dram_dl_addr, usb_boot_data->dram_dl_size);
+		if(ret <0)
+			skw_usb_info("%s dram download img fail !!!!\n", __func__);
+	}
+
+	if(usb_boot_data->iram_dl_size > 0){
+		firmware_data = usb_boot_data->iram_img_data;
+		usb_download_image(port, usb_boot_data->iram_dl_addr, usb_boot_data->iram_dl_size);
+	}
+	dloader_execute_image(port, START_ADDR);
+}
diff --git a/drivers/misc/seekwaveplatform_v20/usb/usb_boot.h b/drivers/misc/seekwaveplatform_v20/usb/usb_boot.h
new file mode 100755
index 000000000000..e50180eadf60
--- /dev/null
+++ b/drivers/misc/seekwaveplatform_v20/usb/usb_boot.h
@@ -0,0 +1,94 @@
+#define MAX_PACKET_SIZE		0x400		//4K
+#define PACKET_MAGIC		0x7e7e7e7e
+/******************************************************************
+ * **Description:download imageaddrress and img size
+ * Seekwave tech LTD
+ * *	StartDownload 	0x0001
+ * *
+ * * MAGIC 4B	Length 4B MessageType 2B  	2B	CRC 0x7E7E7E7E
+ * **
+ * ******************************************************************/
+
+struct connect_ack {
+   unsigned int packet_size;
+   union packet_attr_tag
+   {
+		   struct connect_attr_map
+		   {
+				   unsigned int check_sum	   :1;
+				   unsigned int smp			 :1;
+				   unsigned int boot			:1;
+				   unsigned int res0			:1;
+				   unsigned int strapin		 :2;
+				   unsigned int usb_sdio_dis	:2;
+				   unsigned int res1			:24;
+		   }bitmap;
+		   unsigned int dwValue;
+   }flags;
+   unsigned int  chip_id[4];
+};
+
+typedef struct PACKET_BODY_tag{
+	unsigned int magic;	 //magic
+	unsigned int size;			  //length,length - 12
+	unsigned short type;			  //type,the type defferent cmd
+	unsigned short crc;		//checksum
+	unsigned char content[MAX_PACKET_SIZE];
+}PACKET_T;
+#define PACKET_HEADER_SIZE		(sizeof(struct PACKET_BODY_tag) - MAX_PACKET_SIZE)
+#ifndef MIN
+#define MIN(a,b)			(((a) < (b)) ? (a) : (b))
+#endif
+#ifndef MAX
+#define MAX(a,b)			(((a) > (b)) ? (a) : (b))
+#endif
+#define DEBUG
+#define NORMAL_BOOT 0
+#define HANG_REBOOT 1
+#define START_ADDR	0x100000
+#define MAX_IMAGE_SIZE	0x7a000
+
+static const char client_version[] = { 0x7E, 0x7E, 0x7E, 0x7E }; /* magic only to probe client */
+static const char client_version_ack[] = {0x7E, 0x7E, 0x7E, 0x7E,/* magic */
+	0x18, 0x00, 0x00, 0x00,/*size*/
+	0x81, 0x00, /*message type*/
+	0x00, 0x00, /* crc16 = 0 */
+	0x42, 0x6f, 0x6f, 0x74, 0x20, 0x4c, 0x6f, 0x61, 0x64, 0x65, 0x72, 0x20,
+	0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x31, 0x2e, 0x30, 0x00};
+
+static const char connect[] = {0x7E, 0x7E, 0x7E, 0x7E,/* magic */
+	0x18, 0x00, 0x00, 0x00,/*size*/
+	0x00, 0x00, /* message type, 0: connect command */
+	0x00, 0x00, /*crc16*/
+	0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+static  char connect_ack[] = {0x7E, 0x7E, 0x7E, 0x7E,/* magic */
+	0x18, 0x00, 0x00, 0x00,/*size*/
+	0x80, 0x00, /*message type*/
+	0x00, 0x00, /* crc16 */
+	0x00, 0x10, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x53, 0x56, 0x36, 0x31,
+	0x36, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+static const char common_ack[] = { 0x7e, 0x7e, 0x7e, 0x7e, /* magic */
+	0x00, 0x00, 0x00, 0x00,/*size*/
+	0x80, 0x00, /*message type*/
+	0x00, 0x00};/* crc16 */
+
+static const char exec_ack[] = { 0x7e, 0x7e, 0x7e, 0x7e,
+	0x00, 0x00, 0x00, 0x00,/*size*/
+	0x80, 0x00,/*message type*/
+	0x00, 0x00};/* crc16 */
+
+static int dloader_send_command(const char *command,  int command_len, const char *ack, int ack_len);
+
+#define dloader_command_client_probe()				\
+    do {                         \
+	ret = dloader_send_command(client_version, sizeof(client_version),	\
+			client_version_ack, sizeof(client_version_ack)); \
+    }while(0)
+
+#define dloader_command_connect()				\
+    do {                         \
+	ret = dloader_send_command(connect, sizeof(connect), connect_ack, sizeof(connect_ack)); \
+    }while(0)
-- 
Created with Armbian build tools https://github.com/armbian/build

